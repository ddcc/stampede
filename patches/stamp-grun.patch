diff -x .git -x inputs -Naur stamp-0.9.10/.patched stamp-grun/.patched
--- stamp-0.9.10/.patched	2017-03-21 21:04:54.000000000 +0000
+++ stamp-grun/.patched	2017-03-21 20:57:30.000000000 +0000
@@ -1 +0,0 @@
-patched
diff -x .git -x inputs -Naur stamp-0.9.10/.patched2 stamp-grun/.patched2
--- stamp-0.9.10/.patched2	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/.patched2	2017-03-21 21:05:30.000000000 +0000
@@ -0,0 +1 @@
+patched
diff -x .git -x inputs -Naur stamp-0.9.10/CMakeLists.txt stamp-grun/CMakeLists.txt
--- stamp-0.9.10/CMakeLists.txt	2017-03-21 15:28:47.000000000 +0000
+++ stamp-grun/CMakeLists.txt	2017-03-21 20:19:55.000000000 +0000
@@ -1,25 +1,11 @@
 get_filename_component(LIB_DIR lib REALPATH)
 
-if(CMAKE_CXX_COMPILER_ID MATCHES "XL")
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -qalias=noansi")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qalias=noansi")
-elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99")
-endif()
-
 include_directories(lib)
+include_directories(${Galois_INCLUDE_DIRS})
+include_directories(${tinystm_INCLUDE_DIRS})
 
-if(EXISTS /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/include)
-  set(PAPI_INCLUDE_DIRS /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/include)
-  set(PAPI_LIBRARIES /usr/global/tools/papi/bgqos_0/papi-5.0.1-V1R1M2/lib/libpapi.a rt)
-else()
-  set(PAPI_INCLUDE_DIRS /usr/lib64/papi-5.1.1/usr/include)
-  set(PAPI_LIBRARIES /usr/lib64/papi-5.1.1/usr/lib/libpapi.so rt)
-endif()
-
-if(USE_PAPI)
-  include_directories(${PAPI_INCLUDE_DIRS})
-  add_definitions(-DUSE_PAPI)
+if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99")
 endif()
 
 set(extra_sources)
@@ -28,54 +14,35 @@
   add_definitions(-DSIMULATOR)
   set(extra_sources ${extra_sources} ${LIB_DIR}/memory.c)
 endif()
-if(USE_PAPI OR USE_SALLOC)
-  set(extra_sources ${extra_sources} ${LIB_DIR}/force_cxx_linker.cpp)
-endif()
 
+set(libraries ${Galois_LIBRARIES})
 if(USE_SALLOC)
-  if(EXISTS /g/g14/nguyen91/local-bgq/lib/libtcmalloc_minimal.a)
-    set(SALLOC_LIB /g/g14/nguyen91/local-bgq/lib/libtcmalloc_minimal.a)
-  else()
-    set(SALLOC_LIB /h1/ddn/local/lib/libtcmalloc_minimal.a)
-  endif()
+  set(libraries ${libraries} ${SALLOC_LIB})
 endif()
 
-set(libraries ${CMAKE_THREAD_LIBS_INIT} m)
-
-if(USE_SALLOC)
-  set(libraries ${libraryes} ${SALLOC_LIB})
-endif()
-
-if(USE_PAPI)
-  set(libraries ${libraries} ${PAPI_LIBRARIES})
-endif()
-
-if(USE_STM)
+if(USE_HTM)
+  add_definitions(-DHTM)
+elseif(USE_STM)
   add_definitions(-DSTM)
-  include_directories(${tinystm_INCLUDE_DIRS})
   set(libraries ${libraries} ${tinystm_LIBRARIES})
 elseif(USE_XTM)
   add_definitions(-DSTM)
   add_definitions(-DXTM)
   add_definitions(-DSIMULATOR)
-  if(USE_XTM_INLINE)
-    add_definitions(-DXTM_USE_INLINE_LOCKABLE)
-  endif()
   include_directories(${XTM_INCLUDE_DIRS})
   set(libraries ${libraries} ${XTM_LIBRARIES})
-elseif(USE_HTM)
-  add_definitions(-DHTM)
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -qtm")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qtm")
 endif()
 
 function(app name)
-  add_executable(${name} ${ARGN} ${extra_sources})
-  target_link_libraries(${name} ${libraries})
-  install(TARGETS ${name} RUNTIME DESTINATION bin)
+  if("${USE_STM}" OR "${USE_XTM}")
+    add_executable(${name}grun ${ARGN} ${extra_sources})
+    target_link_libraries(${name}grun m ${libraries})
+    install(TARGETS ${name}grun RUNTIME DESTINATION bin)
+  else()
+    message("skipping ${name}grun")
+  endif()
 endfunction(app)
 
-
 add_subdirectory(bayes)
 add_subdirectory(genome)
 add_subdirectory(intruder)
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/CMakeLists.txt stamp-grun/bayes/CMakeLists.txt
--- stamp-0.9.10/bayes/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/CMakeLists.txt	2017-03-20 15:19:45.000000000 +0000
@@ -10,7 +10,7 @@
         adtree.c
         bayes.c
 	data.c
-	learner.c
+	learner.cpp
 	net.c
 	sort.c
 	${LIB_DIR}/bitmap.c
@@ -18,7 +18,7 @@
 	${LIB_DIR}/mt19937ar.c
 	${LIB_DIR}/queue.c
 	${LIB_DIR}/random.c
-	${LIB_DIR}/thread.c
+	${LIB_DIR}/thread.cpp
 	${LIB_DIR}/vector.c)
 
 app(bayes ${sources})
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/adtree.h stamp-grun/bayes/adtree.h
--- stamp-0.9.10/bayes/adtree.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/adtree.h	2017-03-20 15:19:45.000000000 +0000
@@ -86,6 +86,10 @@
 #include "query.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct adtree_node {
     long index;
     long value;
@@ -140,6 +144,9 @@
 long
 adtree_getCount (adtree_t* adtreePtr, vector_t* queryVectorPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ADTREE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/data.h stamp-grun/bayes/data.h
--- stamp-0.9.10/bayes/data.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/data.h	2017-03-20 15:19:45.000000000 +0000
@@ -77,6 +77,10 @@
 #include "net.h"
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct data {
     long numVar;
     long numRecord;
@@ -151,6 +155,9 @@
 long
 data_findSplit (data_t* dataPtr, long start, long num, long offset);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DATA_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.c stamp-grun/bayes/learner.c
--- stamp-0.9.10/bayes/learner.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/learner.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1644 +0,0 @@
-/* =============================================================================
- *
- * learn.c
- * -- Learns structure of Bayesian net from data
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * The penalized log-likelihood score (Friedman & Yahkani, 1996) is used to
- * evaluated the "goodness" of a Bayesian net:
- *
- *                             M      n_j
- *                            --- --- ---
- *  -N_params * ln(R) / 2 + R >   >   >   P((a_j = v), X_j) ln P(a_j = v | X_j)
- *                            --- --- ---
- *                            j=1 X_j v=1
- *
- * Where:
- *
- *     N_params     total number of parents across all variables
- *     R            number of records
- *     M            number of variables
- *     X_j          parents of the jth variable
- *     n_j          number of attributes of the jth variable
- *     a_j          attribute
- *
- * The second summation of X_j varies across all possible assignments to the
- * values of the parents X_j.
- *
- * In the code:
- *
- *    "local log likelihood" is  P((a_j = v), X_j) ln P(a_j = v | X_j)
- *    "log likelihood" is everything to the right of the '+', i.e., "R ... X_j)"
- *    "base penalty" is -ln(R) / 2
- *    "penalty" is N_params * -ln(R) / 2
- *    "score" is the entire expression
- *
- * For more notes, refer to:
- *
- * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
- * learning with large datasets. Journal of Artificial Intelligence Research 8
- * (1998), pp 67-91.
- *
- * =============================================================================
- *
- * The search strategy uses a combination of local and global structure search.
- * Similar to the technique described in:
- *
- * D. M. Chickering, D. Heckerman, and C. Meek.  A Bayesian approach to learning
- * Bayesian networks with local structure. In Proceedings of Thirteenth
- * Conference on Uncertainty in Artificial Intelligence (1997), pp. 80-89.
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <math.h>
-#include <stdlib.h>
-#include "adtree.h"
-#include "data.h"
-#include "learner.h"
-#include "list.h"
-#include "net.h"
-#include "operation.h"
-#include "query.h"
-#include "random.h"
-#include "thread.h"
-#include "timer.h"
-#include "utility.h"
-#include "vector.h"
-
-struct learner_task {
-    operation_t op;
-    long fromId;
-    long toId;
-    float score;
-};
-
-typedef struct findBestTaskArg {
-    long toId;
-    learner_t* learnerPtr;
-    query_t* queries;
-    vector_t* queryVectorPtr;
-    vector_t* parentQueryVectorPtr;
-    long numTotalParent;
-    float basePenalty;
-    float baseLogLikelihood;
-    bitmap_t* bitmapPtr;
-    queue_t* workQueuePtr;
-    vector_t* aQueryVectorPtr;
-    vector_t* bQueryVectorPtr;
-} findBestTaskArg_t;
-
-#ifdef TEST_LEARNER
-long global_maxNumEdgeLearned = -1L;
-long global_insertPenalty = 1;
-float global_operationQualityFactor = 1.0F;
-#else
-extern long global_insertPenalty;
-extern long global_maxNumEdgeLearned;
-extern float global_operationQualityFactor;
-#endif
-
-/* =============================================================================
- * DECLARATION OF TM_CALLABLE FUNCTIONS
- * =============================================================================
- */
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-TM_CALLABLE
-static learner_task_t
-TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
-
-/* =============================================================================
- * compareTask
- * -- Want greatest score first
- * -- For list
- * =============================================================================
- */
-static long
-compareTask (const void* aPtr, const void* bPtr)
-{
-    learner_task_t* aTaskPtr = (learner_task_t*)aPtr;
-    learner_task_t* bTaskPtr = (learner_task_t*)bPtr;
-    float aScore = aTaskPtr->score;
-    float bScore = bTaskPtr->score;
-
-    if (aScore < bScore) {
-        return 1;
-    } else if (aScore > bScore) {
-        return -1;
-    } else {
-        return (aTaskPtr->toId - bTaskPtr->toId);
-    }
-}
-
-
-/* =============================================================================
- * compareQuery
- * -- Want smallest ID first
- * -- For vector_sort
- * =============================================================================
- */
-static int
-compareQuery (const void* aPtr, const void* bPtr)
-{
-    query_t* aQueryPtr = (query_t*)(*(void**)aPtr);
-    query_t* bQueryPtr = (query_t*)(*(void**)bPtr);
-
-    return (aQueryPtr->index - bQueryPtr->index);
-}
-
-
-/* =============================================================================
- * learner_alloc
- * =============================================================================
- */
-learner_t*
-learner_alloc (data_t* dataPtr, adtree_t* adtreePtr, long numThread)
-{
-    learner_t* learnerPtr;
-
-    learnerPtr = (learner_t*)malloc(sizeof(learner_t));
-    if (learnerPtr) {
-        learnerPtr->adtreePtr = adtreePtr;
-        learnerPtr->netPtr = net_alloc(dataPtr->numVar);
-        assert(learnerPtr->netPtr);
-        learnerPtr->localBaseLogLikelihoods =
-            (LocalBaseLogLikelihood*)malloc(dataPtr->numVar * sizeof(*learnerPtr->localBaseLogLikelihoods));
-        assert(learnerPtr->localBaseLogLikelihoods);
-        XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood) = 0.0F;
-        XTM_LOCKABLE_INIT(learnerPtr->baseLogLikelihood);
-        learnerPtr->tasks =
-            (learner_task_t*)malloc(dataPtr->numVar * sizeof(learner_task_t));
-        assert(learnerPtr->tasks);
-        learnerPtr->taskListPtr = list_alloc(&compareTask);
-        assert(learnerPtr->taskListPtr);
-        XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent) = 0;
-        XTM_LOCKABLE_INIT(learnerPtr->numTotalParent);
-    }
-
-    return learnerPtr;
-}
-
-
-/* =============================================================================
- * learner_free
- * =============================================================================
- */
-void
-learner_free (learner_t* learnerPtr)
-{
-    list_free(learnerPtr->taskListPtr);
-    free(learnerPtr->tasks);
-    free(learnerPtr->localBaseLogLikelihoods);
-    net_free(learnerPtr->netPtr);
-    free(learnerPtr);
-}
-
-
-/* =============================================================================
- * computeSpecificLocalLogLikelihood
- * -- Query vectors should not contain wildcards
- * =============================================================================
- */
-static float
-computeSpecificLocalLogLikelihood (adtree_t* adtreePtr,
-                                   vector_t* queryVectorPtr,
-                                   vector_t* parentQueryVectorPtr)
-{
-    long count = adtree_getCount(adtreePtr, queryVectorPtr);
-    if (count == 0) {
-        return 0.0;
-    }
-
-    double probability = (double)count / (double)adtreePtr->numRecord;
-    long parentCount = adtree_getCount(adtreePtr, parentQueryVectorPtr);
-
-    assert(parentCount >= count);
-    assert(parentCount > 0);
-
-    return (float)(probability * (double)log((double)count/ (double)parentCount));
-}
-
-
-/* =============================================================================
- * createPartition
- * =============================================================================
- */
-static void
-createPartition (long min, long max, long id, long n,
-                 long* startPtr, long* stopPtr)
-{
-    long range = max - min;
-    long chunk = MAX(1, ((range + n/2) / n)); /* rounded */
-    long start = min + chunk * id;
-    long stop;
-    if (id == (n-1)) {
-        stop = max;
-    } else {
-        stop = MIN(max, (start + chunk));
-    }
-
-    *startPtr = start;
-    *stopPtr = stop;
-}
-
-
-/* =============================================================================
- * createTaskList
- * -- baseLogLikelihoods and taskListPtr are updated
- * =============================================================================
- */
-static void
-createTaskList (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    learner_t* learnerPtr = (learner_t*)argPtr;
-    list_t* taskListPtr = learnerPtr->taskListPtr;
-
-    bool_t status;
-
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-    learner_task_t* tasks = learnerPtr->tasks;
-
-    query_t queries[2];
-    vector_t* queryVectorPtr = PVECTOR_ALLOC(2);
-    assert(queryVectorPtr);
-    status = vector_pushBack(queryVectorPtr, (void*)&queries[0]);
-    assert(status);
-
-    query_t parentQuery;
-    vector_t* parentQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(parentQueryVectorPtr);
-
-    long numVar = adtreePtr->numVar;
-    long numRecord = adtreePtr->numRecord;
-    float baseLogLikelihood = 0.0;
-    float penalty = (float)(-0.5 * log((double)numRecord)); /* only add 1 edge */
-
-    long v;
-
-    long v_start;
-    long v_stop;
-    createPartition(0, numVar, myId, numThread, &v_start, &v_stop);
-
-    /*
-     * Compute base log likelihood for each variable and total base loglikelihood
-     */
-
-    for (v = v_start; v < v_stop; v++) {
-
-        float localBaseLogLikelihood = 0.0;
-        queries[0].index = v;
-
-        queries[0].value = 0;
-        localBaseLogLikelihood +=
-            computeSpecificLocalLogLikelihood(adtreePtr,
-                                              queryVectorPtr,
-                                              parentQueryVectorPtr);
-
-        queries[0].value = 1;
-        localBaseLogLikelihood +=
-            computeSpecificLocalLogLikelihood(adtreePtr,
-                                              queryVectorPtr,
-                                              parentQueryVectorPtr);
-
-        XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value) = localBaseLogLikelihood;
-        XTM_LOCKABLE_INIT(localBaseLogLikelihoods[v].value);
-        baseLogLikelihood += localBaseLogLikelihood;
-
-    } /* foreach variable */
-
-    TM_BEGIN();
-    float globalBaseLogLikelihood =
-        TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
-    TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood,
-                      (baseLogLikelihood + globalBaseLogLikelihood));
-    TM_END();
-
-    /*
-     * For each variable, find if the addition of any edge _to_ it is better
-     */
-
-    status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&parentQuery);
-    assert(status);
-
-    for (v = v_start; v < v_stop; v++) {
-
-        /*
-         * Compute base log likelihood for this variable
-         */
-
-        queries[0].index = v;
-        long bestLocalIndex = v;
-        float bestLocalLogLikelihood = XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value);
-
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[1]);
-        assert(status);
-
-        long vv;
-        for (vv = 0; vv < numVar; vv++) {
-
-            if (vv == v) {
-                continue;
-            }
-            parentQuery.index = vv;
-            if (v < vv) {
-                queries[0].index = v;
-                queries[1].index = vv;
-            } else {
-                queries[0].index = vv;
-                queries[1].index = v;
-            }
-
-            float newLocalLogLikelihood = 0.0;
-
-            queries[0].value = 0;
-            queries[1].value = 0;
-            parentQuery.value = 0;
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 0;
-            queries[1].value = 1;
-            parentQuery.value = ((vv < v) ? 0 : 1);
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 1;
-            queries[1].value = 0;
-            parentQuery.value = ((vv < v) ? 1 : 0);
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            queries[0].value = 1;
-            queries[1].value = 1;
-            parentQuery.value = 1;
-            newLocalLogLikelihood +=
-                computeSpecificLocalLogLikelihood(adtreePtr,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-
-            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-                bestLocalIndex = vv;
-                bestLocalLogLikelihood = newLocalLogLikelihood;
-            }
-
-        } /* foreach other variable */
-
-        PVECTOR_POPBACK(queryVectorPtr);
-
-        if (bestLocalIndex != v) {
-            float logLikelihood = numRecord * (baseLogLikelihood +
-                                                + bestLocalLogLikelihood
-                                                - XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value));
-            float score = penalty + logLikelihood;
-            learner_task_t* taskPtr = &tasks[v];
-            taskPtr->op = OPERATION_INSERT;
-            taskPtr->fromId = bestLocalIndex;
-            taskPtr->toId = v;
-            taskPtr->score = score;
-            TM_BEGIN();
-            status = TMLIST_INSERT(taskListPtr, (void*)taskPtr);
-            TM_END();
-            assert(status);
-        }
-
-    } /* for each variable */
-
-    PVECTOR_FREE(queryVectorPtr);
-    PVECTOR_FREE(parentQueryVectorPtr);
-
-#ifdef TEST_LEARNER
-    list_iter_t it;
-    list_iter_reset(&it, taskListPtr);
-    while (list_iter_hasNext(&it, taskListPtr)) {
-        learner_task_t* taskPtr = (learner_task_t*)list_iter_next(&it, taskListPtr);
-        printf("[task] op=%i from=%li to=%li score=%lf\n",
-               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score);
-    }
-#endif /* TEST_LEARNER */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * TMpopTask
- * -- Returns NULL is list is empty
- * =============================================================================
- */
-learner_task_t*
-TMpopTask (TM_ARGDECL  list_t* taskListPtr)
-{
-    learner_task_t* taskPtr = NULL;
-
-    list_iter_t it;
-    TMLIST_ITER_RESET(&it, taskListPtr);
-    if (TMLIST_ITER_HASNEXT(&it, taskListPtr)) {
-        taskPtr = (learner_task_t*)TMLIST_ITER_NEXT(&it, taskListPtr);
-        bool_t status = TMLIST_REMOVE(taskListPtr, (void*)taskPtr);
-        assert(status);
-    }
-
-    return taskPtr;
-}
-
-
-/* =============================================================================
- * populateParentQuery
- * -- Modifies contents of parentQueryVectorPtr
- * =============================================================================
- */
-static void
-populateParentQueryVector (net_t* netPtr,
-                           long id,
-                           query_t* queries,
-                           vector_t* parentQueryVectorPtr)
-{
-    vector_clear(parentQueryVectorPtr);
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
-    list_iter_t it;
-    list_iter_reset(&it, parentIdListPtr);
-    while (list_iter_hasNext(&it, parentIdListPtr)) {
-        long parentId = (long)list_iter_next(&it, parentIdListPtr);
-        bool_t status = vector_pushBack(parentQueryVectorPtr,
-                                        (void*)&queries[parentId]);
-        assert(status);
-    }
-}
-
-
-/* =============================================================================
- * TMpopulateParentQuery
- * -- Modifies contents of parentQueryVectorPtr
- * =============================================================================
- */
-static void
-TMpopulateParentQueryVector (TM_ARGDECL
-                             net_t* netPtr,
-                             long id,
-                             query_t* queries,
-                             vector_t* parentQueryVectorPtr)
-{
-    vector_clear(parentQueryVectorPtr);
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
-    list_iter_t it;
-    TMLIST_ITER_RESET(&it, parentIdListPtr);
-    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-        bool_t status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                         (void*)&queries[parentId]);
-        assert(status);
-    }
-}
-
-
-/* =============================================================================
- * populateQueryVectors
- * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
- * =============================================================================
- */
-static void
-populateQueryVectors (net_t* netPtr,
-                      long id,
-                      query_t* queries,
-                      vector_t* queryVectorPtr,
-                      vector_t* parentQueryVectorPtr)
-{
-    populateParentQueryVector(netPtr, id, queries, parentQueryVectorPtr);
-
-    bool_t status;
-    status = vector_copy(queryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-    status = vector_pushBack(queryVectorPtr, (void*)&queries[id]);
-    assert(status);
-    vector_sort(queryVectorPtr, &compareQuery);
-}
-
-
-/* =============================================================================
- * TMpopulateQueryVectors
- * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
- * =============================================================================
- */
-static void
-TMpopulateQueryVectors (TM_ARGDECL
-                        net_t* netPtr,
-                        long id,
-                        query_t* queries,
-                        vector_t* queryVectorPtr,
-                        vector_t* parentQueryVectorPtr)
-{
-    TMpopulateParentQueryVector(TM_ARG  netPtr, id, queries, parentQueryVectorPtr);
-
-    bool_t status;
-    status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-    status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[id]);
-    assert(status);
-    PVECTOR_SORT(queryVectorPtr, &compareQuery);
-}
-
-
-/* =============================================================================
- * computeLocalLogLikelihoodHelper
- * -- Recursive helper routine
- * =============================================================================
- */
-static float
-computeLocalLogLikelihoodHelper (long i,
-                                 long numParent,
-                                 adtree_t* adtreePtr,
-                                 query_t* queries,
-                                 vector_t* queryVectorPtr,
-                                 vector_t* parentQueryVectorPtr)
-{
-    if (i >= numParent) {
-        return computeSpecificLocalLogLikelihood(adtreePtr,
-                                                 queryVectorPtr,
-                                                 parentQueryVectorPtr);
-    }
-
-    float localLogLikelihood = 0.0;
-
-    query_t* parentQueryPtr = vector_at(parentQueryVectorPtr, i);
-    long parentIndex = parentQueryPtr->index;
-
-    queries[parentIndex].value = 0;
-    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[parentIndex].value = 1;
-    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[parentIndex].value = QUERY_VALUE_WILDCARD;
-
-    return localLogLikelihood;
-}
-
-
-/* =============================================================================
- * computeLocalLogLikelihood
- * -- Populate the query vectors before passing as args
- * =============================================================================
- */
-static float
-computeLocalLogLikelihood (long id,
-                           adtree_t* adtreePtr,
-                           net_t* netPtr,
-                           query_t* queries,
-                           vector_t* queryVectorPtr,
-                           vector_t* parentQueryVectorPtr)
-{
-    long numParent = vector_getSize(parentQueryVectorPtr);
-    float localLogLikelihood = 0.0;
-
-    queries[id].value = 0;
-    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[id].value = 1;
-    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
-                                                          numParent,
-                                                          adtreePtr,
-                                                          queries,
-                                                          queryVectorPtr,
-                                                          parentQueryVectorPtr);
-
-    queries[id].value = QUERY_VALUE_WILDCARD;
-
-    return localLogLikelihood;
-}
-
-
-/* =============================================================================
- * TMfindBestInsertTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                     = argPtr->toId;
-    learner_t* learnerPtr               = argPtr->learnerPtr;
-    query_t*   queries                  = argPtr->queries;
-    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
-    long       numTotalParent           = argPtr->numTotalParent;
-    float      basePenalty              = argPtr->basePenalty;
-    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
-    bitmap_t*  invalidBitmapPtr         = argPtr->bitmapPtr;
-    queue_t*   workQueuePtr             = argPtr->workQueuePtr;
-    vector_t*  baseParentQueryVectorPtr = argPtr->aQueryVectorPtr;
-    vector_t*  baseQueryVectorPtr       = argPtr->bQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr               = learnerPtr->adtreePtr;
-    net_t*    netPtr                  = learnerPtr->netPtr;
-    LocalBaseLogLikelihood*    localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG  netPtr, toId, queries, parentQueryVectorPtr);
-
-    /*
-     * Create base query and parentQuery
-     */
-
-    status = PVECTOR_COPY(baseParentQueryVectorPtr, parentQueryVectorPtr);
-    assert(status);
-
-    status = PVECTOR_COPY(baseQueryVectorPtr, baseParentQueryVectorPtr);
-    assert(status);
-    status = PVECTOR_PUSHBACK(baseQueryVectorPtr, (void*)&queries[toId]);
-    assert(status);
-    PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    float bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-
-    status = TMNET_FINDDESCENDANTS(netPtr, toId, invalidBitmapPtr, workQueuePtr);
-    assert(status);
-    long fromId = -1;
-
-    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, toId);
-
-    long maxNumEdgeLearned = global_maxNumEdgeLearned;
-
-    if ((maxNumEdgeLearned < 0) ||
-        (TMLIST_GETSIZE(parentIdListPtr) <= maxNumEdgeLearned))
-    {
-
-        list_iter_t it;
-        TMLIST_ITER_RESET(&it, parentIdListPtr);
-        while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
-            long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
-            bitmap_set(invalidBitmapPtr, parentId); /* invalid since already have edge */
-        }
-
-        while ((fromId = bitmap_findClear(invalidBitmapPtr, (fromId + 1))) >= 0) {
-
-            if (fromId == toId) {
-                continue;
-            }
-
-            status = PVECTOR_COPY(queryVectorPtr, baseQueryVectorPtr);
-            assert(status);
-            status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
-            assert(status);
-            PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-            status = PVECTOR_COPY(parentQueryVectorPtr, baseParentQueryVectorPtr);
-            assert(status);
-            status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[fromId]);
-            assert(status);
-            PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
-
-            float newLocalLogLikelihood =
-                computeLocalLogLikelihood(toId,
-                                          adtreePtr,
-                                          netPtr,
-                                          queries,
-                                          queryVectorPtr,
-                                          parentQueryVectorPtr);
-
-            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-                bestLocalLogLikelihood = newLocalLogLikelihood;
-                bestFromId = fromId;
-            }
-
-        } /* foreach valid parent */
-
-    } /* if have not exceeded max number of edges to learn */
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_INSERT;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        long numRecord = adtreePtr->numRecord;
-        long numParent = TMLIST_GETSIZE(parentIdListPtr) + 1;
-        float penalty =
-            (numTotalParent + numParent * global_insertPenalty) * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                           + bestLocalLogLikelihood
-                                           - oldLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-
-
-#ifdef LEARNER_TRY_REMOVE
-/* =============================================================================
- * TMfindBestRemoveTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                     = argPtr->toId;
-    learner_t* learnerPtr               = argPtr->learnerPtr;
-    query_t*   queries                  = argPtr->queries;
-    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
-    long       numTotalParent           = argPtr->numTotalParent;
-    float      basePenalty              = argPtr->basePenalty;
-    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
-    vector_t*  origParentQueryVectorPtr = argPtr->aQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG
-                                netPtr, toId, queries, origParentQueryVectorPtr);
-    long numParent = PVECTOR_GETSIZE(origParentQueryVectorPtr);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    float bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-
-    long i;
-    for (i = 0; i < numParent; i++) {
-
-        query_t* queryPtr = (query_t*)PVECTOR_AT(origParentQueryVectorPtr, i);
-        long fromId = queryPtr->index;
-
-        /*
-         * Create parent query (subset of parents since remove an edge)
-         */
-
-        PVECTOR_CLEAR(parentQueryVectorPtr);
-
-        long p;
-        for (p = 0; p < numParent; p++) {
-            if (p != fromId) {
-                query_t* queryPtr = PVECTOR_AT(origParentQueryVectorPtr, p);
-                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                          (void*)&queries[queryPtr->index]);
-                assert(status);
-            }
-        } /* create new parent query */
-
-        /*
-         * Create query
-         */
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        /*
-         * See if removing parent is better
-         */
-
-        float newLocalLogLikelihood =
-            computeLocalLogLikelihood(toId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-            bestLocalLogLikelihood = newLocalLogLikelihood;
-            bestFromId = fromId;
-        }
-
-    } /* for each parent */
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_REMOVE;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        long numRecord = adtreePtr->numRecord;
-        float penalty = (numTotalParent - 1) * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                            + bestLocalLogLikelihood
-                                            - oldLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-#endif /* LEARNER_TRY_REMOVE */
-
-
-#ifdef LEARNER_TRY_REVERSE
-/* =============================================================================
- * TMfindBestReverseTask
- * =============================================================================
- */
-static learner_task_t
-TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
-{
-    long       toId                         = argPtr->toId;
-    learner_t* learnerPtr                   = argPtr->learnerPtr;
-    query_t*   queries                      = argPtr->queries;
-    vector_t*  queryVectorPtr               = argPtr->queryVectorPtr;
-    vector_t*  parentQueryVectorPtr         = argPtr->parentQueryVectorPtr;
-    long       numTotalParent               = argPtr->numTotalParent;
-    float      basePenalty                  = argPtr->basePenalty;
-    float      baseLogLikelihood            = argPtr->baseLogLikelihood;
-    bitmap_t*  visitedBitmapPtr             = argPtr->bitmapPtr;
-    queue_t*   workQueuePtr                 = argPtr->workQueuePtr;
-    vector_t*  toOrigParentQueryVectorPtr   = argPtr->aQueryVectorPtr;
-    vector_t*  fromOrigParentQueryVectorPtr = argPtr->bQueryVectorPtr;
-
-    bool_t status;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-
-    TMpopulateParentQueryVector(TM_ARG
-                                netPtr, toId, queries, toOrigParentQueryVectorPtr);
-    long numParent = PVECTOR_GETSIZE(toOrigParentQueryVectorPtr);
-
-    /*
-     * Search all possible valid operations for better local log likelihood
-     */
-
-    long bestFromId = toId; /* flag for not found */
-    float oldLocalLogLikelihood =
-        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-    float bestLocalLogLikelihood = oldLocalLogLikelihood;
-    long fromId = 0;
-
-    long i;
-    for (i = 0; i < numParent; i++) {
-
-        query_t* queryPtr = (query_t*)PVECTOR_AT(toOrigParentQueryVectorPtr, i);
-        fromId = queryPtr->index;
-
-        bestLocalLogLikelihood =
-            oldLocalLogLikelihood +
-            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-
-        TMpopulateParentQueryVector(TM_ARG
-                                    netPtr,
-                                    fromId,
-                                    queries,
-                                    fromOrigParentQueryVectorPtr);
-
-        /*
-         * Create parent query (subset of parents since remove an edge)
-         */
-
-        PVECTOR_CLEAR(parentQueryVectorPtr);
-
-        long p;
-        for (p = 0; p < numParent; p++) {
-            if (p != fromId) {
-                query_t* queryPtr = PVECTOR_AT(toOrigParentQueryVectorPtr, p);
-                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
-                                          (void*)&queries[queryPtr->index]);
-                assert(status);
-            }
-        } /* create new parent query */
-
-        /*
-         * Create query
-         */
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        /*
-         * Get log likelihood for removing parent from toId
-         */
-
-        float newLocalLogLikelihood =
-            computeLocalLogLikelihood(toId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        /*
-         * Get log likelihood for adding parent to fromId
-         */
-
-        status = PVECTOR_COPY(parentQueryVectorPtr, fromOrigParentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[toId]);
-        assert(status);
-        PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
-
-        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
-        assert(status);
-        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
-        assert(status);
-        PVECTOR_SORT(queryVectorPtr, &compareQuery);
-
-        newLocalLogLikelihood +=
-            computeLocalLogLikelihood(fromId,
-                                      adtreePtr,
-                                      netPtr,
-                                      queries,
-                                      queryVectorPtr,
-                                      parentQueryVectorPtr);
-
-        /*
-         * Record best
-         */
-
-        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
-            bestLocalLogLikelihood = newLocalLogLikelihood;
-            bestFromId = fromId;
-        }
-
-    } /* for each parent */
-
-    /*
-     * Check validity of best
-     */
-
-    if (bestFromId != toId) {
-        bool_t isTaskValid = TRUE;
-        TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, bestFromId, toId);
-        if (TMNET_ISPATH(netPtr,
-                         bestFromId,
-                         toId,
-                         visitedBitmapPtr,
-                         workQueuePtr))
-        {
-            isTaskValid = FALSE;
-        }
-        TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, bestFromId, toId);
-        if (!isTaskValid) {
-            bestFromId = toId;
-        }
-    }
-
-    /*
-     * Return best task; Note: if none is better, fromId will equal toId
-     */
-
-    learner_task_t bestTask;
-    bestTask.op     = OPERATION_REVERSE;
-    bestTask.fromId = bestFromId;
-    bestTask.toId   = toId;
-    bestTask.score  = 0.0;
-
-    if (bestFromId != toId) {
-        float fromLocalLogLikelihood =
-            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[bestFromId].value);
-        long numRecord = adtreePtr->numRecord;
-        float penalty = numTotalParent * basePenalty;
-        float logLikelihood = numRecord * (baseLogLikelihood +
-                                            + bestLocalLogLikelihood
-                                            - oldLocalLogLikelihood
-                                            - fromLocalLogLikelihood);
-        float bestScore = penalty + logLikelihood;
-        bestTask.score  = bestScore;
-    }
-
-    return bestTask;
-}
-#endif /* LEARNER_TRY_REVERSE */
-
-
-/* =============================================================================
- * learnStructure
- *
- * Note it is okay if the score is not exact, as we are relaxing the greedy
- * search. This means we do not need to communicate baseLogLikelihood across
- * threads.
- * =============================================================================
- */
-static void
-learnStructure (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    learner_t* learnerPtr = (learner_t*)argPtr;
-    net_t* netPtr = learnerPtr->netPtr;
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    long numRecord = adtreePtr->numRecord;
-    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
-    list_t* taskListPtr = learnerPtr->taskListPtr;
-
-    float operationQualityFactor = global_operationQualityFactor;
-
-    bitmap_t* visitedBitmapPtr = PBITMAP_ALLOC(learnerPtr->adtreePtr->numVar);
-    assert(visitedBitmapPtr);
-    queue_t* workQueuePtr = PQUEUE_ALLOC(-1);
-    assert(workQueuePtr);
-
-    long numVar = adtreePtr->numVar;
-    query_t* queries = (query_t*)P_MALLOC(numVar * sizeof(query_t));
-    assert(queries);
-    long v;
-    for (v = 0; v < numVar; v++) {
-        queries[v].index = v;
-        queries[v].value = QUERY_VALUE_WILDCARD;
-    }
-
-    float basePenalty = (float)(-0.5 * log((double)numRecord));
-
-    vector_t* queryVectorPtr = PVECTOR_ALLOC(1);
-    assert(queryVectorPtr);
-    vector_t* parentQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(parentQueryVectorPtr);
-    vector_t* aQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(aQueryVectorPtr);
-    vector_t* bQueryVectorPtr = PVECTOR_ALLOC(1);
-    assert(bQueryVectorPtr);
-
-    findBestTaskArg_t arg;
-    arg.learnerPtr           = learnerPtr;
-    arg.queries              = queries;
-    arg.queryVectorPtr       = queryVectorPtr;
-    arg.parentQueryVectorPtr = parentQueryVectorPtr;
-    arg.bitmapPtr            = visitedBitmapPtr;
-    arg.workQueuePtr         = workQueuePtr;
-    arg.aQueryVectorPtr      = aQueryVectorPtr;
-    arg.bQueryVectorPtr      = bQueryVectorPtr;
-
-    while (1) {
-
-        learner_task_t* taskPtr;
-        TM_BEGIN();
-        taskPtr = TMpopTask(TM_ARG  taskListPtr);
-        TM_END();
-        if (taskPtr == NULL) {
-            break;
-        }
-
-        operation_t op = taskPtr->op;
-        long fromId = taskPtr->fromId;
-        long toId = taskPtr->toId;
-
-        bool_t isTaskValid;
-
-        TM_BEGIN();
-
-        /*
-         * Check if task is still valid
-         */
-        isTaskValid = TRUE;
-        switch (op) {
-            case OPERATION_INSERT: {
-                if (TMNET_HASEDGE(netPtr, fromId, toId) ||
-                    TMNET_ISPATH(netPtr,
-                                 toId,
-                                 fromId,
-                                 visitedBitmapPtr,
-                                 workQueuePtr))
-                {
-                    isTaskValid = FALSE;
-                }
-                break;
-            }
-            case OPERATION_REMOVE: {
-                /* Can never create cycle, so always valid */
-                break;
-            }
-            case OPERATION_REVERSE: {
-                /* Temporarily remove edge for check */
-                TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, fromId, toId);
-                if (TMNET_ISPATH(netPtr,
-                                 fromId,
-                                 toId,
-                                 visitedBitmapPtr,
-                                 workQueuePtr))
-                {
-                    isTaskValid = FALSE;
-                }
-                TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, fromId, toId);
-                break;
-            }
-            default:
-                assert(0);
-        }
-
-#ifdef TEST_LEARNER
-        printf("[task] op=%i from=%li to=%li score=%lf valid=%s\n",
-               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score,
-               (isTaskValid ? "yes" : "no"));
-        fflush(stdout);
-#endif
-
-        /*
-         * Perform task: update graph and probabilities
-         */
-
-        if (isTaskValid) {
-            TMNET_APPLYOPERATION(netPtr, op, fromId, toId);
-        }
-
-        TM_END();
-
-        float deltaLogLikelihood = 0.0;
-
-        if (isTaskValid) {
-
-            switch (op) {
-                float newBaseLogLikelihood;
-                case OPERATION_INSERT: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           toId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(toId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float toLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-                    deltaLogLikelihood +=
-                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    TM_BEGIN();
-                    long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-                    TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
-                    TM_END();
-                    break;
-                }
-#ifdef LEARNER_TRY_REMOVE
-                case OPERATION_REMOVE: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           fromId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(fromId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float fromLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-                    deltaLogLikelihood +=
-                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    TM_BEGIN();
-                    long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-                    TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
-                    TM_END();
-                    break;
-                }
-#endif /* LEARNER_TRY_REMOVE */
-#ifdef LEARNER_TRY_REVERSE
-                case OPERATION_REVERSE: {
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           fromId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(fromId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float fromLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
-                    deltaLogLikelihood +=
-                        fromLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-
-                    TM_BEGIN();
-                    TMpopulateQueryVectors(TM_ARG
-                                           netPtr,
-                                           toId,
-                                           queries,
-                                           queryVectorPtr,
-                                           parentQueryVectorPtr);
-                    newBaseLogLikelihood =
-                        computeLocalLogLikelihood(toId,
-                                                  adtreePtr,
-                                                  netPtr,
-                                                  queries,
-                                                  queryVectorPtr,
-                                                  parentQueryVectorPtr);
-                    float toLocalBaseLogLikelihood =
-                        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
-                    deltaLogLikelihood +=
-                        toLocalBaseLogLikelihood - newBaseLogLikelihood;
-                    TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
-                                      newBaseLogLikelihood);
-                    TM_END();
-                    break;
-                }
-#endif /* LEARNER_TRY_REVERSE */
-                default:
-                    assert(0);
-            } /* switch op */
-
-        } /* if isTaskValid */
-
-        /*
-         * Update/read globals
-         */
-
-        float baseLogLikelihood;
-        long numTotalParent;
-
-        TM_BEGIN();
-        float oldBaseLogLikelihood =
-            (float)TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
-        float newBaseLogLikelihood = oldBaseLogLikelihood + deltaLogLikelihood;
-        TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood, newBaseLogLikelihood);
-        baseLogLikelihood = newBaseLogLikelihood;
-        numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
-        TM_END();
-
-        /*
-         * Find next task
-         */
-
-        float baseScore = ((float)numTotalParent * basePenalty)
-                           + (numRecord * baseLogLikelihood);
-
-        learner_task_t bestTask;
-        bestTask.op     = NUM_OPERATION;
-        bestTask.toId   = -1;
-        bestTask.fromId = -1;
-        bestTask.score  = baseScore;
-
-        learner_task_t newTask;
-
-        arg.toId              = toId;
-        arg.numTotalParent    = numTotalParent;
-        arg.basePenalty       = basePenalty;
-        arg.baseLogLikelihood = baseLogLikelihood;
-
-        TM_BEGIN();
-        newTask = TMfindBestInsertTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-
-#ifdef LEARNER_TRY_REMOVE
-        TM_BEGIN();
-        newTask = TMfindBestRemoveTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-#endif /* LEARNER_TRY_REMOVE */
-
-#ifdef LEARNER_TRY_REVERSE
-        TM_BEGIN();
-        newTask = TMfindBestReverseTask(TM_ARG  &arg);
-        TM_END();
-
-        if ((newTask.fromId != newTask.toId) &&
-            (newTask.score > (bestTask.score / operationQualityFactor)))
-        {
-            bestTask = newTask;
-        }
-#endif /* LEARNER_TRY_REVERSE */
-
-        if (bestTask.toId != -1) {
-            learner_task_t* tasks = learnerPtr->tasks;
-            tasks[toId] = bestTask;
-            TM_BEGIN();
-            TMLIST_INSERT(taskListPtr, (void*)&tasks[toId]);
-            TM_END();
-#ifdef TEST_LEARNER
-            printf("[new]  op=%i from=%li to=%li score=%lf\n",
-                   bestTask.op, bestTask.fromId, bestTask.toId, bestTask.score);
-            fflush(stdout);
-#endif
-        }
-
-    } /* while (tasks) */
-
-    PBITMAP_FREE(visitedBitmapPtr);
-    PQUEUE_FREE(workQueuePtr);
-    PVECTOR_FREE(bQueryVectorPtr);
-    PVECTOR_FREE(aQueryVectorPtr);
-    PVECTOR_FREE(queryVectorPtr);
-    PVECTOR_FREE(parentQueryVectorPtr);
-    P_FREE(queries);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * learner_run
- * -- Call adtree_make before this
- * =============================================================================
- */
-void
-learner_run (learner_t* learnerPtr)
-{
-#ifdef OTM
-#pragma omp parallel
-    {
-        createTaskList((void*)learnerPtr);
-    }
-#pragma omp parallel
-    {
-        learnStructure((void*)learnerPtr);
-    }
-#else
-    thread_start(&createTaskList, (void*)learnerPtr);
-    thread_start(&learnStructure, (void*)learnerPtr);
-#endif
-}
-
-
-/* =============================================================================
- * learner_score
- * -- Score entire network
- * =============================================================================
- */
-float
-learner_score (learner_t* learnerPtr)
-{
-    adtree_t* adtreePtr = learnerPtr->adtreePtr;
-    net_t* netPtr = learnerPtr->netPtr;
-
-    vector_t* queryVectorPtr = vector_alloc(1);
-    assert(queryVectorPtr);
-    vector_t* parentQueryVectorPtr = vector_alloc(1);
-    assert(parentQueryVectorPtr);
-
-    long numVar = adtreePtr->numVar;
-    query_t* queries = (query_t*)malloc(numVar * sizeof(query_t));
-    assert(queries);
-    long v;
-    for (v = 0; v < numVar; v++) {
-        queries[v].index = v;
-        queries[v].value = QUERY_VALUE_WILDCARD;
-    }
-
-    long numTotalParent = 0;
-    float logLikelihood = 0.0;
-
-    for (v = 0; v < numVar; v++) {
-
-        list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, v);
-        numTotalParent += list_getSize(parentIdListPtr);
-
-
-        populateQueryVectors(netPtr,
-                             v,
-                             queries,
-                             queryVectorPtr,
-                             parentQueryVectorPtr);
-        float localLogLikelihood = computeLocalLogLikelihood(v,
-                                                             adtreePtr,
-                                                             netPtr,
-                                                             queries,
-                                                             queryVectorPtr,
-                                                             parentQueryVectorPtr);
-        logLikelihood += localLogLikelihood;
-    }
-
-    vector_free(queryVectorPtr);
-    vector_free(parentQueryVectorPtr);
-    free(queries);
-
-    long numRecord = adtreePtr->numRecord;
-    float penalty = (float)(-0.5 * (double)numTotalParent * log((double)numRecord));
-    float score = penalty + numRecord * logLikelihood;
-
-    return score;
-}
-
-
-/* #############################################################################
- * TEST_LEARNER
- * #############################################################################
- */
-#ifdef TEST_LEARNER
-
-#include <stdio.h>
-
-
-static void
-testPartition (long min, long max, long n)
-{
-    long start;
-    long stop;
-
-    printf("min=%li max=%li, n=%li\n", min, max, n);
-
-    long i;
-    for (i = 0; i < n; i++) {
-        createPartition(min, max, i, n, &start, &stop);
-        printf("%li: %li -> %li\n", i, start, stop);
-    }
-    puts("");
-}
-
-
-int
-main (int argc, char* argv[])
-{
-    thread_startup(1);
-
-    puts("Starting...");
-
-    testPartition(0, 4, 8);
-    testPartition(0, 15, 8);
-    testPartition(3, 103, 7);
-
-    long numVar = 56;
-    long numRecord = 256;
-
-    random_t* randomPtr = random_alloc();
-    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
-    assert(dataPtr);
-    data_generate(dataPtr, 0, 10, 10);
-
-    adtree_t* adtreePtr = adtree_alloc();
-    assert(adtreePtr);
-    adtree_make(adtreePtr, dataPtr);
-
-
-    learner_t* learnerPtr = learner_alloc(dataPtr, adtreePtr, 1);
-    assert(learnerPtr);
-
-    data_free(dataPtr);
-
-    learner_run(learnerPtr);
-
-    assert(!net_isCycle(learnerPtr->netPtr));
-
-    float score = learner_score(learnerPtr);
-    printf("score = %lf\n", score);
-
-    learner_free(learnerPtr);
-
-    puts("Done.");
-
-    adtree_free(adtreePtr);
-    random_free(randomPtr);
-
-    thread_shutdown();
-
-    return 0;
-}
-
-#endif /* TEST_LEARNER */
-
-
-/* =============================================================================
- *
- * End of learner.h
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.cpp stamp-grun/bayes/learner.cpp
--- stamp-0.9.10/bayes/learner.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/bayes/learner.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,1904 @@
+/* =============================================================================
+ *
+ * learn.c
+ * -- Learns structure of Bayesian net from data
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * The penalized log-likelihood score (Friedman & Yahkani, 1996) is used to
+ * evaluated the "goodness" of a Bayesian net:
+ *
+ *                             M      n_j
+ *                            --- --- ---
+ *  -N_params * ln(R) / 2 + R >   >   >   P((a_j = v), X_j) ln P(a_j = v | X_j)
+ *                            --- --- ---
+ *                            j=1 X_j v=1
+ *
+ * Where:
+ *
+ *     N_params     total number of parents across all variables
+ *     R            number of records
+ *     M            number of variables
+ *     X_j          parents of the jth variable
+ *     n_j          number of attributes of the jth variable
+ *     a_j          attribute
+ *
+ * The second summation of X_j varies across all possible assignments to the
+ * values of the parents X_j.
+ *
+ * In the code:
+ *
+ *    "local log likelihood" is  P((a_j = v), X_j) ln P(a_j = v | X_j)
+ *    "log likelihood" is everything to the right of the '+', i.e., "R ... X_j)"
+ *    "base penalty" is -ln(R) / 2
+ *    "penalty" is N_params * -ln(R) / 2
+ *    "score" is the entire expression
+ *
+ * For more notes, refer to:
+ *
+ * A. Moore and M.-S. Lee. Cached sufficient statistics for efficient machine
+ * learning with large datasets. Journal of Artificial Intelligence Research 8
+ * (1998), pp 67-91.
+ *
+ * =============================================================================
+ *
+ * The search strategy uses a combination of local and global structure search.
+ * Similar to the technique described in:
+ *
+ * D. M. Chickering, D. Heckerman, and C. Meek.  A Bayesian approach to learning
+ * Bayesian networks with local structure. In Proceedings of Thirteenth
+ * Conference on Uncertainty in Artificial Intelligence (1997), pp. 80-89.
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/Bag.h"
+#include "Galois/Statistic.h"
+#include <boost/iterator/counting_iterator.hpp>
+
+#include <assert.h>
+#include <math.h>
+#include <stdlib.h>
+#include "adtree.h"
+#include "data.h"
+#include "learner.h"
+#include "list.h"
+#include "net.h"
+#include "operation.h"
+#include "query.h"
+#include "random.h"
+#include "thread.h"
+#include "timer.h"
+#include "utility.h"
+#include "vector.h"
+
+struct learner_task {
+    operation_t op;
+    long fromId;
+    XTM_DECL_LOCKABLE(long, toId);
+    float score;
+};
+
+typedef struct findBestTaskArg {
+    long toId;
+    learner_t* learnerPtr;
+    query_t* queries;
+    vector_t* queryVectorPtr;
+    vector_t* parentQueryVectorPtr;
+    long numTotalParent;
+    float basePenalty;
+    float baseLogLikelihood;
+    bitmap_t* bitmapPtr;
+    queue_t* workQueuePtr;
+    vector_t* aQueryVectorPtr;
+    vector_t* bQueryVectorPtr;
+} findBestTaskArg_t;
+
+#ifdef TEST_LEARNER
+long global_maxNumEdgeLearned = -1L;
+long global_insertPenalty = 1;
+float global_operationQualityFactor = 1.0F;
+#else
+extern long global_insertPenalty;
+extern long global_maxNumEdgeLearned;
+extern float global_operationQualityFactor;
+#endif
+
+/* =============================================================================
+ * DECLARATION OF TM_CALLABLE FUNCTIONS
+ * =============================================================================
+ */
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
+
+TM_CALLABLE
+static learner_task_t
+TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr);
+
+/* =============================================================================
+ * compareTask
+ * -- Want greatest score first
+ * -- For list
+ * =============================================================================
+ */
+static long
+compareTask (const void* aPtr, const void* bPtr)
+{
+    learner_task_t* aTaskPtr = (learner_task_t*)aPtr;
+    learner_task_t* bTaskPtr = (learner_task_t*)bPtr;
+    float aScore = aTaskPtr->score;
+    float bScore = bTaskPtr->score;
+
+    if (aScore < bScore) {
+        return 1;
+    } else if (aScore > bScore) {
+        return -1;
+    } else {
+        return (XTM_LOCKABLE_VALUE(aTaskPtr->toId) - XTM_LOCKABLE_VALUE(bTaskPtr->toId));
+    }
+}
+
+struct LearnTask {
+    learner_task_t* task;
+    int phase;
+    learner_task_t newTask;
+};
+
+struct LearnTaskIndexer: public std::unary_function<LearnTask, int> {
+    int operator()(const LearnTask& p) {
+      return -p.task->score / 1000;
+    }
+};
+
+struct TaskCompare {
+    bool operator()(learner_task_t* aTaskPtr, learner_task_t* bTaskPtr) const {
+        float aScore = aTaskPtr->score;
+        float bScore = bTaskPtr->score;
+
+        if (aScore < bScore) {
+            return 1;
+        } else if (aScore > bScore) {
+            return -1;
+        } else {
+            return (XTM_LOCKABLE_VALUE(aTaskPtr->toId) - XTM_LOCKABLE_VALUE(bTaskPtr->toId));
+        }
+    }
+};
+
+
+/* =============================================================================
+ * compareQuery
+ * -- Want smallest ID first
+ * -- For vector_sort
+ * =============================================================================
+ */
+static int
+compareQuery (const void* aPtr, const void* bPtr)
+{
+    query_t* aQueryPtr = (query_t*)(*(void**)aPtr);
+    query_t* bQueryPtr = (query_t*)(*(void**)bPtr);
+
+    return (aQueryPtr->index - bQueryPtr->index);
+}
+
+
+/* =============================================================================
+ * learner_alloc
+ * =============================================================================
+ */
+learner_t*
+learner_alloc (data_t* dataPtr, adtree_t* adtreePtr, long numThread)
+{
+    learner_t* learnerPtr;
+
+    learnerPtr = (learner_t*)malloc(sizeof(learner_t));
+    if (learnerPtr) {
+        learnerPtr->adtreePtr = adtreePtr;
+        learnerPtr->netPtr = net_alloc(dataPtr->numVar);
+        assert(learnerPtr->netPtr);
+        learnerPtr->localBaseLogLikelihoods =
+            (LocalBaseLogLikelihood*)malloc(dataPtr->numVar * sizeof(*learnerPtr->localBaseLogLikelihoods));
+        assert(learnerPtr->localBaseLogLikelihoods);
+        XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood) = 0.0F;
+        XTM_LOCKABLE_INIT(learnerPtr->baseLogLikelihood);
+        learnerPtr->tasks =
+            (learner_task_t*)malloc(dataPtr->numVar * sizeof(learner_task_t));
+        assert(learnerPtr->tasks);
+        learnerPtr->taskListPtr = list_alloc(&compareTask);
+        assert(learnerPtr->taskListPtr);
+        XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent) = 0;
+        XTM_LOCKABLE_INIT(learnerPtr->numTotalParent);
+    }
+
+    return learnerPtr;
+}
+
+
+/* =============================================================================
+ * learner_free
+ * =============================================================================
+ */
+void
+learner_free (learner_t* learnerPtr)
+{
+    list_free(learnerPtr->taskListPtr);
+    free(learnerPtr->tasks);
+    free(learnerPtr->localBaseLogLikelihoods);
+    net_free(learnerPtr->netPtr);
+    free(learnerPtr);
+}
+
+
+/* =============================================================================
+ * computeSpecificLocalLogLikelihood
+ * -- Query vectors should not contain wildcards
+ * =============================================================================
+ */
+static float
+computeSpecificLocalLogLikelihood (adtree_t* adtreePtr,
+                                   vector_t* queryVectorPtr,
+                                   vector_t* parentQueryVectorPtr)
+{
+    long count = adtree_getCount(adtreePtr, queryVectorPtr);
+    if (count == 0) {
+        return 0.0;
+    }
+
+    double probability = (double)count / (double)adtreePtr->numRecord;
+    long parentCount = adtree_getCount(adtreePtr, parentQueryVectorPtr);
+
+    assert(parentCount >= count);
+    assert(parentCount > 0);
+
+    return (float)(probability * (double)log((double)count/ (double)parentCount));
+}
+
+
+/* =============================================================================
+ * createPartition
+ * =============================================================================
+ */
+static void
+createPartition (long min, long max, long id, long n,
+                 long* startPtr, long* stopPtr)
+{
+    long range = max - min;
+    long chunk = 1 > (range + n/2) / n ? 1 : (range + n/2) / n; // MAX(1, ((range + n/2) / n)); /* rounded */
+    long start = min + chunk * id;
+    long stop;
+    if (id == (n-1)) {
+        stop = max;
+    } else {
+        stop = max < (start + chunk) ? max : (start + chunk); //MIN(max, (start + chunk));
+    }
+
+    *startPtr = start;
+    *stopPtr = stop;
+}
+
+struct Fn1 {
+    adtree_t* adtreePtr;
+    LocalBaseLogLikelihood* localBaseLogLikelihoods;
+    Galois::GAccumulator<float>& accum;
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+
+    void operator()(long v) {
+        query_t queries[1];
+        vector_t*& queryVectorPtr = *queryVectorPtrs.getLocal();
+        vector_t*& parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        if (!queryVectorPtr)
+            queryVectorPtr = PVECTOR_ALLOC(2);
+        if (!parentQueryVectorPtr)
+            parentQueryVectorPtr = PVECTOR_ALLOC(1);
+
+        vector_clear(queryVectorPtr);
+        vector_pushBack(queryVectorPtr, (void*)&queries[0]);
+
+        float localBaseLogLikelihood = 0.0;
+        queries[0].index = v;
+
+        queries[0].value = 0;
+        localBaseLogLikelihood +=
+            computeSpecificLocalLogLikelihood(adtreePtr,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+
+        queries[0].value = 1;
+        localBaseLogLikelihood +=
+            computeSpecificLocalLogLikelihood(adtreePtr,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+
+        XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value) = localBaseLogLikelihood;
+        XTM_LOCKABLE_INIT(localBaseLogLikelihoods[v].value);
+        accum.update(localBaseLogLikelihood);
+    } /* foreach variable */
+};
+
+struct Fn2 {
+    adtree_t* adtreePtr;
+    LocalBaseLogLikelihood* localBaseLogLikelihoods;
+    float baseLogLikelihood;
+    float penalty;
+    long numVar;
+    long numRecord;
+    learner_task_t* tasks;
+    Galois::InsertBag<LearnTask>& taskList;
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+
+    void operator()(long v) {
+        /*
+         * Compute base log likelihood for this variable
+         */
+        query_t queries[2];
+        query_t parentQuery;
+        vector_t*& queryVectorPtr = *queryVectorPtrs.getLocal();
+        vector_t*& parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        if (!queryVectorPtr)
+            queryVectorPtr = PVECTOR_ALLOC(2);
+        if (!parentQueryVectorPtr)
+            parentQueryVectorPtr = PVECTOR_ALLOC(1);
+
+        queries[0].index = v;
+        long bestLocalIndex = v;
+        float bestLocalLogLikelihood = XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value);
+        PVECTOR_CLEAR(queryVectorPtr);
+        PVECTOR_CLEAR(parentQueryVectorPtr);
+        PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&parentQuery);
+        PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[0]);
+        PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[1]);
+
+        long vv;
+        for (vv = 0; vv < numVar; vv++) {
+
+            if (vv == v) {
+                continue;
+            }
+            parentQuery.index = vv;
+            if (v < vv) {
+                queries[0].index = v;
+                queries[1].index = vv;
+            } else {
+                queries[0].index = vv;
+                queries[1].index = v;
+            }
+
+            float newLocalLogLikelihood = 0.0;
+
+            queries[0].value = 0;
+            queries[1].value = 0;
+            parentQuery.value = 0;
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  queryVectorPtr,
+                                                  parentQueryVectorPtr);
+
+            queries[0].value = 0;
+            queries[1].value = 1;
+            parentQuery.value = ((vv < v) ? 0 : 1);
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  queryVectorPtr,
+                                                  parentQueryVectorPtr);
+
+            queries[0].value = 1;
+            queries[1].value = 0;
+            parentQuery.value = ((vv < v) ? 1 : 0);
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  queryVectorPtr,
+                                                  parentQueryVectorPtr);
+
+            queries[0].value = 1;
+            queries[1].value = 1;
+            parentQuery.value = 1;
+            newLocalLogLikelihood +=
+                computeSpecificLocalLogLikelihood(adtreePtr,
+                                                  queryVectorPtr,
+                                                  parentQueryVectorPtr);
+
+            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+                bestLocalIndex = vv;
+                bestLocalLogLikelihood = newLocalLogLikelihood;
+            }
+
+        } /* foreach other variable */
+
+
+        if (bestLocalIndex != v) {
+            float logLikelihood = numRecord * (baseLogLikelihood +
+                                                + bestLocalLogLikelihood
+                                                - XTM_LOCKABLE_VALUE(localBaseLogLikelihoods[v].value));
+            float score = penalty + logLikelihood;
+            learner_task_t* taskPtr = &tasks[v];
+            taskPtr->op = OPERATION_INSERT;
+            taskPtr->fromId = bestLocalIndex;
+            XTM_LOCKABLE_VALUE(taskPtr->toId) = v;
+            XTM_LOCKABLE_INIT(taskPtr->toId);
+            taskPtr->score = score;
+            LearnTask t = { taskPtr, 0 };
+            taskList.push(t);
+        }
+    } /* for each variable */
+};
+
+struct Fn6 {
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        if (*queryVectorPtrs.getLocal())
+            PVECTOR_FREE(*queryVectorPtrs.getLocal());
+        if (*parentQueryVectorPtrs.getLocal())
+            PVECTOR_FREE(*parentQueryVectorPtrs.getLocal());
+    }
+};
+
+/* =============================================================================
+ * createTaskList
+ * -- baseLogLikelihoods and taskListPtr are updated
+ * =============================================================================
+ */
+static void
+createTaskList (void* argPtr, Galois::InsertBag<LearnTask>& taskList)
+{
+    TM_THREAD_ENTER();
+    Galois::Runtime::PerThreadStorage<vector_t*> queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*> parentQueryVectorPtrs;
+
+    learner_t* learnerPtr = (learner_t*)argPtr;
+
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+    learner_task_t* tasks = learnerPtr->tasks;
+
+    long numVar = adtreePtr->numVar;
+    long numRecord = adtreePtr->numRecord;
+    //float baseLogLikelihood = 0.0;
+    float penalty = (float)(-0.5 * log((double)numRecord)); /* only add 1 edge */
+
+    /*
+     * Compute base log likelihood for each variable and total base loglikelihood
+     */
+    Galois::GAccumulator<float> accum;
+    Fn1 fn1 = { adtreePtr, localBaseLogLikelihoods, accum, queryVectorPtrs, parentQueryVectorPtrs };
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numVar), fn1);
+
+    XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood) = accum.reduce();
+
+    /*
+     * For each variable, find if the addition of any edge _to_ it is better
+     */
+    // XXX in original: baseLogLikelihood instead of learnerPtr->baseLogLikelihood
+    Fn2 fn2 = { adtreePtr, localBaseLogLikelihoods, XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood), penalty, numVar, numRecord, tasks, taskList, queryVectorPtrs, parentQueryVectorPtrs };
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numVar), fn2);
+
+#ifdef TEST_LEARNER
+    list_iter_t it;
+    list_iter_reset(&it, taskListPtr);
+    while (list_iter_hasNext(&it, taskListPtr)) {
+        learner_task_t* taskPtr = (learner_task_t*)list_iter_next(&it, taskListPtr);
+        printf("[task] op=%i from=%li to=%li score=%lf\n",
+               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score);
+    }
+#endif /* TEST_LEARNER */
+
+    Fn6 fn6 = { queryVectorPtrs, parentQueryVectorPtrs };
+    Galois::on_each(fn6);
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * TMpopTask
+ * -- Returns NULL is list is empty
+ * =============================================================================
+ */
+learner_task_t*
+TMpopTask (TM_ARGDECL  list_t* taskListPtr)
+{
+    learner_task_t* taskPtr = NULL;
+
+    list_iter_t it;
+    TMLIST_ITER_RESET(&it, taskListPtr);
+    if (TMLIST_ITER_HASNEXT(&it, taskListPtr)) {
+        taskPtr = (learner_task_t*)TMLIST_ITER_NEXT(&it, taskListPtr);
+        bool_t status = TMLIST_REMOVE(taskListPtr, (void*)taskPtr);
+        assert(status);
+    }
+
+    return taskPtr;
+}
+
+
+/* =============================================================================
+ * populateParentQuery
+ * -- Modifies contents of parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+populateParentQueryVector (net_t* netPtr,
+                           long id,
+                           query_t* queries,
+                           vector_t* parentQueryVectorPtr)
+{
+    vector_clear(parentQueryVectorPtr);
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
+    list_iter_t it;
+    list_iter_reset(&it, parentIdListPtr);
+    while (list_iter_hasNext(&it, parentIdListPtr)) {
+        long parentId = (long)list_iter_next(&it, parentIdListPtr);
+        bool_t status = vector_pushBack(parentQueryVectorPtr,
+                                        (void*)&queries[parentId]);
+        assert(status);
+    }
+}
+
+
+/* =============================================================================
+ * TMpopulateParentQuery
+ * -- Modifies contents of parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+TMpopulateParentQueryVector (TM_ARGDECL
+                             net_t* netPtr,
+                             long id,
+                             query_t* queries,
+                             vector_t* parentQueryVectorPtr)
+{
+    vector_clear(parentQueryVectorPtr);
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, id);
+    list_iter_t it;
+    TMLIST_ITER_RESET(&it, parentIdListPtr);
+    while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
+        long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
+        bool_t status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                         (void*)&queries[parentId]);
+        assert(status);
+    }
+}
+
+
+/* =============================================================================
+ * populateQueryVectors
+ * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+populateQueryVectors (net_t* netPtr,
+                      long id,
+                      query_t* queries,
+                      vector_t* queryVectorPtr,
+                      vector_t* parentQueryVectorPtr)
+{
+    populateParentQueryVector(netPtr, id, queries, parentQueryVectorPtr);
+
+    bool_t status;
+    status = vector_copy(queryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+    status = vector_pushBack(queryVectorPtr, (void*)&queries[id]);
+    assert(status);
+    vector_sort(queryVectorPtr, &compareQuery);
+}
+
+
+/* =============================================================================
+ * TMpopulateQueryVectors
+ * -- Modifies contents of queryVectorPtr and parentQueryVectorPtr
+ * =============================================================================
+ */
+static void
+TMpopulateQueryVectors (TM_ARGDECL
+                        net_t* netPtr,
+                        long id,
+                        query_t* queries,
+                        vector_t* queryVectorPtr,
+                        vector_t* parentQueryVectorPtr)
+{
+    TMpopulateParentQueryVector(TM_ARG  netPtr, id, queries, parentQueryVectorPtr);
+
+    bool_t status;
+    status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+    status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[id]);
+    assert(status);
+    PVECTOR_SORT(queryVectorPtr, &compareQuery);
+}
+
+
+/* =============================================================================
+ * computeLocalLogLikelihoodHelper
+ * -- Recursive helper routine
+ * =============================================================================
+ */
+static float
+computeLocalLogLikelihoodHelper (long i,
+                                 long numParent,
+                                 adtree_t* adtreePtr,
+                                 query_t* queries,
+                                 vector_t* queryVectorPtr,
+                                 vector_t* parentQueryVectorPtr)
+{
+    if (i >= numParent) {
+        return computeSpecificLocalLogLikelihood(adtreePtr,
+                                                 queryVectorPtr,
+                                                 parentQueryVectorPtr);
+    }
+
+    float localLogLikelihood = 0.0;
+
+    query_t* parentQueryPtr = (query_t*) vector_at(parentQueryVectorPtr, i);
+    long parentIndex = parentQueryPtr->index;
+
+    queries[parentIndex].value = 0;
+    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[parentIndex].value = 1;
+    localLogLikelihood += computeLocalLogLikelihoodHelper((i + 1),
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[parentIndex].value = QUERY_VALUE_WILDCARD;
+
+    return localLogLikelihood;
+}
+
+
+/* =============================================================================
+ * computeLocalLogLikelihood
+ * -- Populate the query vectors before passing as args
+ * =============================================================================
+ */
+static float
+computeLocalLogLikelihood (long id,
+                           adtree_t* adtreePtr,
+                           net_t* netPtr,
+                           query_t* queries,
+                           vector_t* queryVectorPtr,
+                           vector_t* parentQueryVectorPtr)
+{
+    long numParent = vector_getSize(parentQueryVectorPtr);
+    float localLogLikelihood = 0.0;
+
+    queries[id].value = 0;
+    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[id].value = 1;
+    localLogLikelihood += computeLocalLogLikelihoodHelper(0,
+                                                          numParent,
+                                                          adtreePtr,
+                                                          queries,
+                                                          queryVectorPtr,
+                                                          parentQueryVectorPtr);
+
+    queries[id].value = QUERY_VALUE_WILDCARD;
+
+    return localLogLikelihood;
+}
+
+
+/* =============================================================================
+ * TMfindBestInsertTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestInsertTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
+{
+    long       toId                     = argPtr->toId;
+    learner_t* learnerPtr               = argPtr->learnerPtr;
+    query_t*   queries                  = argPtr->queries;
+    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
+    long       numTotalParent           = argPtr->numTotalParent;
+    float      basePenalty              = argPtr->basePenalty;
+    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
+    bitmap_t*  invalidBitmapPtr         = argPtr->bitmapPtr;
+    queue_t*   workQueuePtr             = argPtr->workQueuePtr;
+    vector_t*  baseParentQueryVectorPtr = argPtr->aQueryVectorPtr;
+    vector_t*  baseQueryVectorPtr       = argPtr->bQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr               = learnerPtr->adtreePtr;
+    net_t*    netPtr                  = learnerPtr->netPtr;
+    LocalBaseLogLikelihood*    localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG  netPtr, toId, queries, parentQueryVectorPtr);
+
+    /*
+     * Create base query and parentQuery
+     */
+
+    status = PVECTOR_COPY(baseParentQueryVectorPtr, parentQueryVectorPtr);
+    assert(status);
+
+    status = PVECTOR_COPY(baseQueryVectorPtr, baseParentQueryVectorPtr);
+    assert(status);
+    status = PVECTOR_PUSHBACK(baseQueryVectorPtr, (void*)&queries[toId]);
+    assert(status);
+    PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    float bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+
+    status = TMNET_FINDDESCENDANTS(netPtr, toId, invalidBitmapPtr, workQueuePtr);
+    assert(status);
+    long fromId = -1;
+
+    list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, toId);
+
+    long maxNumEdgeLearned = global_maxNumEdgeLearned;
+
+    if ((maxNumEdgeLearned < 0) ||
+        (TMLIST_GETSIZE(parentIdListPtr) <= maxNumEdgeLearned))
+    {
+
+        list_iter_t it;
+        TMLIST_ITER_RESET(&it, parentIdListPtr);
+        while (TMLIST_ITER_HASNEXT(&it, parentIdListPtr)) {
+            long parentId = (long)TMLIST_ITER_NEXT(&it, parentIdListPtr);
+            bitmap_set(invalidBitmapPtr, parentId); /* invalid since already have edge */
+        }
+
+        while ((fromId = bitmap_findClear(invalidBitmapPtr, (fromId + 1))) >= 0) {
+
+            if (fromId == toId) {
+                continue;
+            }
+
+            status = PVECTOR_COPY(queryVectorPtr, baseQueryVectorPtr);
+            assert(status);
+            status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
+            assert(status);
+            PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+            status = PVECTOR_COPY(parentQueryVectorPtr, baseParentQueryVectorPtr);
+            assert(status);
+            status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[fromId]);
+            assert(status);
+            PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
+
+            float newLocalLogLikelihood =
+                computeLocalLogLikelihood(toId,
+                                          adtreePtr,
+                                          netPtr,
+                                          queries,
+                                          queryVectorPtr,
+                                          parentQueryVectorPtr);
+
+            if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+                bestLocalLogLikelihood = newLocalLogLikelihood;
+                bestFromId = fromId;
+            }
+
+        } /* foreach valid parent */
+
+    } /* if have not exceeded max number of edges to learn */
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_INSERT;
+    bestTask.fromId = bestFromId;
+    XTM_LOCKABLE_VALUE(bestTask.toId)   = toId;
+    XTM_LOCKABLE_INIT(bestTask.toId);
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        long numRecord = adtreePtr->numRecord;
+        long numParent = TMLIST_GETSIZE(parentIdListPtr) + 1;
+        float penalty =
+            (numTotalParent + numParent * global_insertPenalty) * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                           + bestLocalLogLikelihood
+                                           - oldLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+
+
+#ifdef LEARNER_TRY_REMOVE
+/* =============================================================================
+ * TMfindBestRemoveTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestRemoveTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
+{
+    long       toId                     = argPtr->toId;
+    learner_t* learnerPtr               = argPtr->learnerPtr;
+    query_t*   queries                  = argPtr->queries;
+    vector_t*  queryVectorPtr           = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr     = argPtr->parentQueryVectorPtr;
+    long       numTotalParent           = argPtr->numTotalParent;
+    float      basePenalty              = argPtr->basePenalty;
+    float      baseLogLikelihood        = argPtr->baseLogLikelihood;
+    vector_t*  origParentQueryVectorPtr = argPtr->aQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG
+                                netPtr, toId, queries, origParentQueryVectorPtr);
+    long numParent = PVECTOR_GETSIZE(origParentQueryVectorPtr);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    float bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+
+    long i;
+    for (i = 0; i < numParent; i++) {
+
+        query_t* queryPtr = (query_t*)PVECTOR_AT(origParentQueryVectorPtr, i);
+        long fromId = queryPtr->index;
+
+        /*
+         * Create parent query (subset of parents since remove an edge)
+         */
+
+        PVECTOR_CLEAR(parentQueryVectorPtr);
+
+        long p;
+        for (p = 0; p < numParent; p++) {
+            if (p != fromId) {
+                query_t* queryPtr = (query_t*) PVECTOR_AT(origParentQueryVectorPtr, p);
+                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                          (void*)&queries[queryPtr->index]);
+                assert(status);
+            }
+        } /* create new parent query */
+
+        /*
+         * Create query
+         */
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        /*
+         * See if removing parent is better
+         */
+
+        float newLocalLogLikelihood =
+            computeLocalLogLikelihood(toId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+            bestLocalLogLikelihood = newLocalLogLikelihood;
+            bestFromId = fromId;
+        }
+
+    } /* for each parent */
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_REMOVE;
+    bestTask.fromId = bestFromId;
+    XTM_LOCKABLE_VALUE(bestTask.toId)   = toId;
+    XTM_LOCKABLE_INIT(bestTask.toId);
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        long numRecord = adtreePtr->numRecord;
+        float penalty = (numTotalParent - 1) * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                            + bestLocalLogLikelihood
+                                            - oldLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+#endif /* LEARNER_TRY_REMOVE */
+
+
+#ifdef LEARNER_TRY_REVERSE
+/* =============================================================================
+ * TMfindBestReverseTask
+ * =============================================================================
+ */
+static learner_task_t
+TMfindBestReverseTask (TM_ARGDECL  findBestTaskArg_t* argPtr)
+{
+    long       toId                         = argPtr->toId;
+    learner_t* learnerPtr                   = argPtr->learnerPtr;
+    query_t*   queries                      = argPtr->queries;
+    vector_t*  queryVectorPtr               = argPtr->queryVectorPtr;
+    vector_t*  parentQueryVectorPtr         = argPtr->parentQueryVectorPtr;
+    long       numTotalParent               = argPtr->numTotalParent;
+    float      basePenalty                  = argPtr->basePenalty;
+    float      baseLogLikelihood            = argPtr->baseLogLikelihood;
+    bitmap_t*  visitedBitmapPtr             = argPtr->bitmapPtr;
+    queue_t*   workQueuePtr                 = argPtr->workQueuePtr;
+    vector_t*  toOrigParentQueryVectorPtr   = argPtr->aQueryVectorPtr;
+    vector_t*  fromOrigParentQueryVectorPtr = argPtr->bQueryVectorPtr;
+
+    bool_t status;
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+    LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+    TMpopulateParentQueryVector(TM_ARG
+                                netPtr, toId, queries, toOrigParentQueryVectorPtr);
+    long numParent = PVECTOR_GETSIZE(toOrigParentQueryVectorPtr);
+
+    /*
+     * Search all possible valid operations for better local log likelihood
+     */
+
+    long bestFromId = toId; /* flag for not found */
+    float oldLocalLogLikelihood =
+        (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
+    float bestLocalLogLikelihood = oldLocalLogLikelihood;
+    long fromId = 0;
+
+    long i;
+    for (i = 0; i < numParent; i++) {
+
+        query_t* queryPtr = (query_t*)PVECTOR_AT(toOrigParentQueryVectorPtr, i);
+        fromId = queryPtr->index;
+
+        bestLocalLogLikelihood =
+            oldLocalLogLikelihood +
+            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
+
+        TMpopulateParentQueryVector(TM_ARG
+                                    netPtr,
+                                    fromId,
+                                    queries,
+                                    fromOrigParentQueryVectorPtr);
+
+        /*
+         * Create parent query (subset of parents since remove an edge)
+         */
+
+        PVECTOR_CLEAR(parentQueryVectorPtr);
+
+        long p;
+        for (p = 0; p < numParent; p++) {
+            if (p != fromId) {
+                query_t* queryPtr = (query_t*) PVECTOR_AT(toOrigParentQueryVectorPtr, p);
+                status = PVECTOR_PUSHBACK(parentQueryVectorPtr,
+                                          (void*)&queries[queryPtr->index]);
+                assert(status);
+            }
+        } /* create new parent query */
+
+        /*
+         * Create query
+         */
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        /*
+         * Get log likelihood for removing parent from toId
+         */
+
+        float newLocalLogLikelihood =
+            computeLocalLogLikelihood(toId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        /*
+         * Get log likelihood for adding parent to fromId
+         */
+
+        status = PVECTOR_COPY(parentQueryVectorPtr, fromOrigParentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(parentQueryVectorPtr, (void*)&queries[toId]);
+        assert(status);
+        PVECTOR_SORT(parentQueryVectorPtr, &compareQuery);
+
+        status = PVECTOR_COPY(queryVectorPtr, parentQueryVectorPtr);
+        assert(status);
+        status = PVECTOR_PUSHBACK(queryVectorPtr, (void*)&queries[fromId]);
+        assert(status);
+        PVECTOR_SORT(queryVectorPtr, &compareQuery);
+
+        newLocalLogLikelihood +=
+            computeLocalLogLikelihood(fromId,
+                                      adtreePtr,
+                                      netPtr,
+                                      queries,
+                                      queryVectorPtr,
+                                      parentQueryVectorPtr);
+
+        /*
+         * Record best
+         */
+
+        if (newLocalLogLikelihood > bestLocalLogLikelihood) {
+            bestLocalLogLikelihood = newLocalLogLikelihood;
+            bestFromId = fromId;
+        }
+
+    } /* for each parent */
+
+    /*
+     * Check validity of best
+     */
+
+    if (bestFromId != toId) {
+        bool_t isTaskValid = TRUE;
+        TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, bestFromId, toId);
+        if (TMNET_ISPATH(netPtr,
+                         bestFromId,
+                         toId,
+                         visitedBitmapPtr,
+                         workQueuePtr))
+        {
+            isTaskValid = FALSE;
+        }
+        TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, bestFromId, toId);
+        if (!isTaskValid) {
+            bestFromId = toId;
+        }
+    }
+
+    /*
+     * Return best task; Note: if none is better, fromId will equal toId
+     */
+
+    learner_task_t bestTask;
+    bestTask.op     = OPERATION_REVERSE;
+    bestTask.fromId = bestFromId;
+    XTM_LOCKABLE_VALUE(bestTask.toId)   = toId;
+    XTM_LOCKABLE_INIT(bestTask.toId);
+    bestTask.score  = 0.0;
+
+    if (bestFromId != toId) {
+        float fromLocalLogLikelihood =
+            (float)TM_SHARED_READ_F(localBaseLogLikelihoods[bestFromId].value);
+        long numRecord = adtreePtr->numRecord;
+        float penalty = numTotalParent * basePenalty;
+        float logLikelihood = numRecord * (baseLogLikelihood +
+                                            + bestLocalLogLikelihood
+                                            - oldLocalLogLikelihood
+                                            - fromLocalLogLikelihood);
+        float bestScore = penalty + logLikelihood;
+        bestTask.score  = bestScore;
+    }
+
+    return bestTask;
+}
+#endif /* LEARNER_TRY_REVERSE */
+
+
+/* =============================================================================
+ * learnStructure
+ *
+ * Note it is okay if the score is not exact, as we are relaxing the greedy
+ * search. This means we do not need to communicate baseLogLikelihood across
+ * threads.
+ * =============================================================================
+ */
+
+struct Fn3 {
+    learner_t* learnerPtr;
+    Galois::Runtime::PerThreadStorage<query_t*>& localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*>& visitedBitmapPtrs;
+    Galois::Runtime::PerThreadStorage<queue_t*>& workQueuePtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& aQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& bQueryVectorPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numVar = adtreePtr->numVar;
+
+        query_t* queries = (query_t*)P_MALLOC(numVar * sizeof(query_t));
+        long v;
+        for (v = 0; v < numVar; v++) {
+            queries[v].index = v;
+            queries[v].value = QUERY_VALUE_WILDCARD;
+        }
+        *localQueries.getLocal() = queries;
+        
+        *visitedBitmapPtrs.getLocal() = PBITMAP_ALLOC(learnerPtr->adtreePtr->numVar);
+        *workQueuePtrs.getLocal() = PQUEUE_ALLOC(-1);
+        *queryVectorPtrs.getLocal() = PVECTOR_ALLOC(1);
+        *parentQueryVectorPtrs.getLocal() = PVECTOR_ALLOC(1);
+        *aQueryVectorPtrs.getLocal() = PVECTOR_ALLOC(1);
+        *bQueryVectorPtrs.getLocal() = PVECTOR_ALLOC(1);
+    }
+};
+
+struct Fn4 {
+    learner_t* learnerPtr;
+    float basePenalty;
+    Galois::Runtime::PerThreadStorage<query_t*>& localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*>& visitedBitmapPtrs;
+    Galois::Runtime::PerThreadStorage<queue_t*>& workQueuePtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& aQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& bQueryVectorPtrs;
+
+    void operator()(const LearnTask& p, Galois::UserContext<LearnTask>& ctx) {
+        TM_SHARED_READ(p.task->toId);
+        switch (p.phase) {
+            case 0: applyOperation(p.task, true, ctx); break;
+            case 1: computeLikelihood(p.task, true, ctx); break;
+            case 2: findNewInsertTask(p.task, ctx); break;
+            case 3: findNewRemoveTask(p.task, p.newTask, ctx); break;
+            case 4: findNewReverseTask(p.task, p.newTask, ctx); break;
+            default: abort();
+        }
+    }
+
+    bool applyOperation(learner_task_t* taskPtr, bool continuation, Galois::UserContext<LearnTask>& ctx) {
+        net_t* netPtr = learnerPtr->netPtr;
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+
+        float operationQualityFactor = global_operationQualityFactor;
+
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        queue_t* workQueuePtr = *workQueuePtrs.getLocal();
+        query_t* queries = *localQueries.getLocal();
+        assert(queries);
+
+        vector_t* queryVectorPtr = *queryVectorPtrs.getLocal();
+        vector_t* parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        vector_t* aQueryVectorPtr = *aQueryVectorPtrs.getLocal();
+        vector_t* bQueryVectorPtr = *bQueryVectorPtrs.getLocal();
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = *queryVectorPtrs.getLocal();
+        arg.parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = *workQueuePtrs.getLocal();
+        arg.aQueryVectorPtr      = *aQueryVectorPtrs.getLocal();
+        arg.bQueryVectorPtr      = *bQueryVectorPtrs.getLocal();
+
+        operation_t op = taskPtr->op;
+        long fromId = taskPtr->fromId;
+        long toId = XTM_LOCKABLE_VALUE(taskPtr->toId);
+
+        bool_t isTaskValid;
+
+        TM_BEGIN();
+
+        /*
+         * Check if task is still valid
+         */
+        isTaskValid = TRUE;
+        switch (op) {
+            case OPERATION_INSERT: {
+                if (TMNET_HASEDGE(netPtr, fromId, toId) ||
+                    TMNET_ISPATH(netPtr,
+                                 toId,
+                                 fromId,
+                                 visitedBitmapPtr,
+                                 workQueuePtr))
+                {
+                    isTaskValid = FALSE;
+                }
+                break;
+            }
+            case OPERATION_REMOVE: {
+                /* Can never create cycle, so always valid */
+                if (TMNET_HASEDGE(netPtr, fromId, toId))
+                    isTaskValid = FALSE;
+                break;
+            }
+            case OPERATION_REVERSE: {
+                /* Temporarily remove edge for check */
+                if (!TMNET_HASEDGE(netPtr, fromId, toId)) {
+                    isTaskValid = FALSE;
+                } else {
+                    TMNET_APPLYOPERATION(netPtr, OPERATION_REMOVE, fromId, toId);
+                    if (TMNET_ISPATH(netPtr,
+                                     fromId,
+                                     toId,
+                                     visitedBitmapPtr,
+                                     workQueuePtr))
+                    {
+                        isTaskValid = FALSE;
+                    }
+                    TMNET_APPLYOPERATION(netPtr, OPERATION_INSERT, fromId, toId);
+                }
+                break;
+            }
+            default:
+                assert(0);
+        }
+
+#ifdef TEST_LEARNER
+        printf("[task] op=%i from=%li to=%li score=%lf valid=%s\n",
+               taskPtr->op, taskPtr->fromId, taskPtr->toId, taskPtr->score,
+               (isTaskValid ? "yes" : "no"));
+        fflush(stdout);
+#endif
+
+        /*
+         * Perform task: update graph and probabilities
+         */
+
+        if (isTaskValid) {
+            TMNET_APPLYOPERATION(netPtr, op, fromId, toId);
+        }
+
+        TM_END();
+        if (isTaskValid == TRUE) {
+            LearnTask t = { taskPtr, 1 };
+            if (continuation)
+                ctx.push(t);
+            return true;
+        } else {
+            LearnTask t = { taskPtr, 1 };
+            if (continuation)
+                ctx.push(t);
+            return false;
+        }
+    }
+
+
+    void computeLikelihood(learner_task_t* taskPtr, bool continuation, Galois::UserContext<LearnTask>& ctx) {
+        net_t* netPtr = learnerPtr->netPtr;
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        LocalBaseLogLikelihood* localBaseLogLikelihoods = learnerPtr->localBaseLogLikelihoods;
+        vector_t* queryVectorPtr = *queryVectorPtrs.getLocal();
+        vector_t* parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        query_t* queries = *localQueries.getLocal();
+        float deltaLogLikelihood = 0.0;
+        long deltaNumTotalParent = 0;
+
+        operation_t op = taskPtr->op;
+        long fromId = taskPtr->fromId;
+        long toId = XTM_LOCKABLE_VALUE(taskPtr->toId);
+        switch (op) {
+            float newBaseLogLikelihood;
+            case OPERATION_INSERT: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       toId,
+                                       queries,
+                                       queryVectorPtr,
+                                       parentQueryVectorPtr);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(toId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+                float toLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
+                deltaLogLikelihood +=
+                    toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
+                                  newBaseLogLikelihood);
+                TM_END();
+                TM_BEGIN();
+                deltaNumTotalParent = 1;
+                long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
+                TM_END();
+                break;
+            }
+#ifdef LEARNER_TRY_REMOVE
+            case OPERATION_REMOVE: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       fromId,
+                                       queries,
+                                       queryVectorPtr,
+                                       parentQueryVectorPtr);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(fromId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+                float fromLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
+                deltaLogLikelihood +=
+                    fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
+                                  newBaseLogLikelihood);
+                TM_END();
+                TM_BEGIN();
+                deltaNumTotalParent = -1;
+                long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+                TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
+                TM_END();
+                break;
+            }
+#endif /* LEARNER_TRY_REMOVE */
+#ifdef LEARNER_TRY_REVERSE
+            case OPERATION_REVERSE: {
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       fromId,
+                                       queries,
+                                       queryVectorPtr,
+                                       parentQueryVectorPtr);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(fromId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+                float fromLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[fromId].value);
+                deltaLogLikelihood +=
+                    fromLocalBaseLogLikelihood - newBaseLogLikelihood;
+                TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId].value,
+                                  newBaseLogLikelihood);
+                TM_END();
+
+                TM_BEGIN();
+                TMpopulateQueryVectors(TM_ARG
+                                       netPtr,
+                                       toId,
+                                       queries,
+                                       queryVectorPtr,
+                                       parentQueryVectorPtr);
+                newBaseLogLikelihood =
+                    computeLocalLogLikelihood(toId,
+                                              adtreePtr,
+                                              netPtr,
+                                              queries,
+                                              queryVectorPtr,
+                                              parentQueryVectorPtr);
+                float toLocalBaseLogLikelihood =
+                    (float)TM_SHARED_READ_F(localBaseLogLikelihoods[toId].value);
+                deltaLogLikelihood +=
+                    toLocalBaseLogLikelihood - newBaseLogLikelihood;
+                TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId].value,
+                                  newBaseLogLikelihood);
+                TM_END();
+                break;
+            }
+#endif /* LEARNER_TRY_REVERSE */
+            default:
+                abort();
+        } /* switch op */
+
+        TM_BEGIN();
+        float oldBaseLogLikelihood =
+            (float)TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
+        float newBaseLogLikelihood = oldBaseLogLikelihood + deltaLogLikelihood;
+        TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood, newBaseLogLikelihood);
+        //baseLogLikelihood = newBaseLogLikelihood;
+        //numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
+        TM_END();
+  
+        if (continuation) {
+            LearnTask t = { taskPtr, 2 };
+            ctx.push(t);
+        }
+    }
+
+    void findNewInsertTask(learner_task_t* taskPtr, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = XTM_LOCKABLE_VALUE(taskPtr->toId);
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood);
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent);
+        
+        /*
+         * Find next task
+         */
+
+        float baseScore = ((float)numTotalParent * basePenalty)
+                           + (numRecord * baseLogLikelihood);
+
+        learner_task_t bestTask;
+        bestTask.op     = NUM_OPERATION;
+        XTM_LOCKABLE_VALUE(bestTask.toId)   = -1;
+        XTM_LOCKABLE_INIT(bestTask.toId);
+        bestTask.fromId = -1;
+        bestTask.score  = baseScore;
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = *queryVectorPtrs.getLocal();
+        arg.parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = *workQueuePtrs.getLocal();
+        arg.aQueryVectorPtr      = *aQueryVectorPtrs.getLocal();
+        arg.bQueryVectorPtr      = *bQueryVectorPtrs.getLocal();
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+        TM_BEGIN();
+        newTask = TMfindBestInsertTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != XTM_LOCKABLE_VALUE(newTask.toId)) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+        LearnTask t = { taskPtr, 3, bestTask };
+        ctx.push(t);
+    }
+
+    void findNewRemoveTask(learner_task_t* taskPtr, learner_task_t bestTask, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = XTM_LOCKABLE_VALUE(taskPtr->toId);
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood);
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent);
+        
+        /*
+         * Find next task
+         */
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = *queryVectorPtrs.getLocal();
+        arg.parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = *workQueuePtrs.getLocal();
+        arg.aQueryVectorPtr      = *aQueryVectorPtrs.getLocal();
+        arg.bQueryVectorPtr      = *bQueryVectorPtrs.getLocal();
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+#ifdef LEARNER_TRY_REMOVE
+        TM_BEGIN();
+        newTask = TMfindBestRemoveTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != XTM_LOCKABLE_VALUE(newTask.toId)) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REMOVE */
+        LearnTask t = { taskPtr, 4, bestTask };
+        ctx.push(t);
+    }
+
+    void findNewReverseTask(learner_task_t* taskPtr, learner_task_t bestTask, Galois::UserContext<LearnTask>& ctx) {
+        adtree_t* adtreePtr = learnerPtr->adtreePtr;
+        long numRecord = adtreePtr->numRecord;
+        vector_t queryVector;
+        vector_t parentQueryVector;
+        vector_t aQueryVector;
+        vector_t bQueryVector;
+        bitmap_t* visitedBitmapPtr = *visitedBitmapPtrs.getLocal();
+        assert(visitedBitmapPtr);
+
+        float operationQualityFactor = global_operationQualityFactor;
+        query_t* queries = *localQueries.getLocal();
+        long toId = XTM_LOCKABLE_VALUE(taskPtr->toId);
+
+        // NB: racy read of learnerPtr->numTotalParent
+        float baseLogLikelihood = XTM_LOCKABLE_VALUE(learnerPtr->baseLogLikelihood);
+        // NB: racy read of learnerPtr->numTotalParent
+        long numTotalParent = XTM_LOCKABLE_VALUE(learnerPtr->numTotalParent);
+        
+        /*
+         * Find next task
+         */
+
+        learner_task_t newTask;
+
+        findBestTaskArg_t arg;
+        arg.learnerPtr           = learnerPtr;
+        arg.queries              = queries;
+        arg.queryVectorPtr       = *queryVectorPtrs.getLocal();
+        arg.parentQueryVectorPtr = *parentQueryVectorPtrs.getLocal();
+        arg.bitmapPtr            = visitedBitmapPtr;
+        arg.workQueuePtr         = *workQueuePtrs.getLocal();
+        arg.aQueryVectorPtr      = *aQueryVectorPtrs.getLocal();
+        arg.bQueryVectorPtr      = *bQueryVectorPtrs.getLocal();
+        arg.toId              = toId;
+        arg.numTotalParent    = numTotalParent;
+        arg.basePenalty       = basePenalty;
+        arg.baseLogLikelihood = baseLogLikelihood;
+
+#ifdef LEARNER_TRY_REVERSE
+        TM_BEGIN();
+        newTask = TMfindBestReverseTask(TM_ARG  &arg);
+        TM_END();
+
+        if ((newTask.fromId != XTM_LOCKABLE_VALUE(newTask.toId)) &&
+            (newTask.score > (bestTask.score / operationQualityFactor)))
+        {
+            bestTask = newTask;
+        }
+#endif /* LEARNER_TRY_REVERSE */
+
+        if (XTM_LOCKABLE_VALUE(bestTask.toId) != -1) {
+            learner_task_t* tasks = learnerPtr->tasks;
+            TM_SHARED_WRITE(tasks[toId].toId, XTM_LOCKABLE_VALUE(bestTask.toId));
+            // XXX(ddn): copy by hand to avoid clobbering XTM fields
+            tasks[toId].op = bestTask.op;
+            tasks[toId].fromId = bestTask.fromId;
+            XTM_LOCKABLE_VALUE(tasks[toId].toId) = XTM_LOCKABLE_VALUE(bestTask.toId);
+            tasks[toId].score = bestTask.score;
+
+            TM_BEGIN();
+            LearnTask t = { &tasks[toId], 0 };
+            ctx.push(t);
+            TM_END();
+#ifdef TEST_LEARNER
+            printf("[new]  op=%i from=%li to=%li score=%lf\n",
+                   bestTask.op, bestTask.fromId, bestTask.toId, bestTask.score);
+            fflush(stdout);
+#endif
+        }
+    }
+};
+
+struct Fn5 {
+    Galois::Runtime::PerThreadStorage<query_t*>& localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*>& visitedBitmapPtrs;
+    Galois::Runtime::PerThreadStorage<queue_t*>& workQueuePtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& parentQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& aQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*>& bQueryVectorPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        P_FREE(*localQueries.getLocal());
+        PBITMAP_FREE(*visitedBitmapPtrs.getLocal());
+        PQUEUE_FREE(*workQueuePtrs.getLocal());
+        PVECTOR_FREE(*queryVectorPtrs.getLocal());
+        PVECTOR_FREE(*parentQueryVectorPtrs.getLocal());
+        PVECTOR_FREE(*aQueryVectorPtrs.getLocal());
+        PVECTOR_FREE(*bQueryVectorPtrs.getLocal());
+    }
+};
+
+static void
+learnStructure (void* argPtr, Galois::InsertBag<LearnTask>& taskList)
+{
+    learner_t* learnerPtr = (learner_t*)argPtr;
+
+    Galois::Runtime::PerThreadStorage<query_t*> localQueries;
+    Galois::Runtime::PerThreadStorage<bitmap_t*> visitedBitmapPtrs;
+    Galois::Runtime::PerThreadStorage<queue_t*> workQueuePtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*> queryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*> parentQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*> aQueryVectorPtrs;
+    Galois::Runtime::PerThreadStorage<vector_t*> bQueryVectorPtrs;
+    Fn3 fn3 = { learnerPtr, localQueries, visitedBitmapPtrs, workQueuePtrs, queryVectorPtrs, parentQueryVectorPtrs, aQueryVectorPtrs, bQueryVectorPtrs };
+
+    Galois::on_each(fn3);
+    
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    long numRecord = adtreePtr->numRecord;
+    float basePenalty = (float)(-0.5 * log((double)numRecord));
+    Fn4 fn4 = { learnerPtr, basePenalty, localQueries, visitedBitmapPtrs, workQueuePtrs, queryVectorPtrs, parentQueryVectorPtrs, aQueryVectorPtrs, bQueryVectorPtrs };
+    typedef Galois::WorkList::OrderedByIntegerMetric<LearnTaskIndexer, Galois::WorkList::dChunkedFIFO<4> > WL;
+    //typedef Galois::WorkList::OrderedList<TaskPairCompare> WL; // XXX
+    Galois::for_each(taskList.begin(), taskList.end(), fn4, Galois::wl<WL>());
+
+    Fn5 fn5 = { localQueries, visitedBitmapPtrs, workQueuePtrs, queryVectorPtrs, parentQueryVectorPtrs, aQueryVectorPtrs, bQueryVectorPtrs };
+    Galois::on_each(fn5);
+}
+
+
+/* =============================================================================
+ * learner_run
+ * -- Call adtree_make before this
+ * =============================================================================
+ */
+void
+learner_run (learner_t* learnerPtr)
+{
+    Galois::InsertBag<LearnTask> taskList;
+    createTaskList((void*)learnerPtr, taskList);
+
+    learnStructure((void*)learnerPtr, taskList);
+}
+
+
+/* =============================================================================
+ * learner_score
+ * -- Score entire network
+ * =============================================================================
+ */
+float
+learner_score (learner_t* learnerPtr)
+{
+    adtree_t* adtreePtr = learnerPtr->adtreePtr;
+    net_t* netPtr = learnerPtr->netPtr;
+
+    vector_t* queryVectorPtr = vector_alloc(1);
+    assert(queryVectorPtr);
+    vector_t* parentQueryVectorPtr = vector_alloc(1);
+    assert(parentQueryVectorPtr);
+
+    long numVar = adtreePtr->numVar;
+    query_t* queries = (query_t*)malloc(numVar * sizeof(query_t));
+    assert(queries);
+    long v;
+    for (v = 0; v < numVar; v++) {
+        queries[v].index = v;
+        queries[v].value = QUERY_VALUE_WILDCARD;
+    }
+
+    long numTotalParent = 0;
+    float logLikelihood = 0.0;
+
+    for (v = 0; v < numVar; v++) {
+
+        list_t* parentIdListPtr = net_getParentIdListPtr(netPtr, v);
+        numTotalParent += list_getSize(parentIdListPtr);
+
+
+        populateQueryVectors(netPtr,
+                             v,
+                             queries,
+                             queryVectorPtr,
+                             parentQueryVectorPtr);
+        float localLogLikelihood = computeLocalLogLikelihood(v,
+                                                             adtreePtr,
+                                                             netPtr,
+                                                             queries,
+                                                             queryVectorPtr,
+                                                             parentQueryVectorPtr);
+        logLikelihood += localLogLikelihood;
+    }
+
+    vector_free(queryVectorPtr);
+    vector_free(parentQueryVectorPtr);
+    free(queries);
+
+    long numRecord = adtreePtr->numRecord;
+    float penalty = (float)(-0.5 * (double)numTotalParent * log((double)numRecord));
+    float score = penalty + numRecord * logLikelihood;
+
+    return score;
+}
+
+
+/* #############################################################################
+ * TEST_LEARNER
+ * #############################################################################
+ */
+#ifdef TEST_LEARNER
+
+#include <stdio.h>
+
+
+static void
+testPartition (long min, long max, long n)
+{
+    long start;
+    long stop;
+
+    printf("min=%li max=%li, n=%li\n", min, max, n);
+
+    long i;
+    for (i = 0; i < n; i++) {
+        createPartition(min, max, i, n, &start, &stop);
+        printf("%li: %li -> %li\n", i, start, stop);
+    }
+    puts("");
+}
+
+
+int
+main (int argc, char* argv[])
+{
+    thread_startup(1);
+
+    puts("Starting...");
+
+    testPartition(0, 4, 8);
+    testPartition(0, 15, 8);
+    testPartition(3, 103, 7);
+
+    long numVar = 56;
+    long numRecord = 256;
+
+    random_t* randomPtr = random_alloc();
+    data_t* dataPtr = data_alloc(numVar, numRecord, randomPtr);
+    assert(dataPtr);
+    data_generate(dataPtr, 0, 10, 10);
+
+    adtree_t* adtreePtr = adtree_alloc();
+    assert(adtreePtr);
+    adtree_make(adtreePtr, dataPtr);
+
+
+    learner_t* learnerPtr = learner_alloc(dataPtr, adtreePtr, 1);
+    assert(learnerPtr);
+
+    data_free(dataPtr);
+
+    learner_run(learnerPtr);
+
+    assert(!net_isCycle(learnerPtr->netPtr));
+
+    float score = learner_score(learnerPtr);
+    printf("score = %lf\n", score);
+
+    learner_free(learnerPtr);
+
+    puts("Done.");
+
+    adtree_free(adtreePtr);
+    random_free(randomPtr);
+
+    thread_shutdown();
+
+    return 0;
+}
+
+#endif /* TEST_LEARNER */
+
+
+/* =============================================================================
+ *
+ * End of learner.h
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/learner.h stamp-grun/bayes/learner.h
--- stamp-0.9.10/bayes/learner.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/learner.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,10 @@
 #include "net.h"
 #include "query.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct learner_task learner_task_t;
 
 #define CACHE_LINE_SIZE (64)
@@ -134,6 +138,9 @@
 float
 learner_score (learner_t* learnerPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* LEARNER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/net.h stamp-grun/bayes/net.h
--- stamp-0.9.10/bayes/net.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/net.h	2017-03-20 15:19:45.000000000 +0000
@@ -79,6 +79,10 @@
 #include "queue.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct net net_t;
 
 
@@ -271,6 +275,9 @@
                                                                           bmp, \
                                                                           wq)
 
+#ifdef __cplusplus
+}
+#endif
 #endif /* NET_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/operation.h stamp-grun/bayes/operation.h
--- stamp-0.9.10/bayes/operation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/operation.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef OPERATION_H
 #define OPERATION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * All operations are performed from:other to:this
  */
@@ -83,6 +87,9 @@
     NUM_OPERATION
 } operation_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* OPERATION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/query.h stamp-grun/bayes/query.h
--- stamp-0.9.10/bayes/query.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/query.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef QUERY_H
 #define QUERY_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #define QUERY_VALUE_WILDCARD (-1L)
 
@@ -80,6 +83,9 @@
     long value;
 } query_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* QUERY_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/bayes/sort.h stamp-grun/bayes/sort.h
--- stamp-0.9.10/bayes/sort.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/bayes/sort.h	2017-03-20 15:19:45.000000000 +0000
@@ -103,6 +103,9 @@
 #ifndef SORT_H
 #define SORT_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /* =============================================================================
  * sort
@@ -116,6 +119,9 @@
       long n,
       long offset);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SORT_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/CMakeLists.txt stamp-grun/genome/CMakeLists.txt
--- stamp-0.9.10/genome/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/CMakeLists.txt	2017-03-20 15:19:45.000000000 +0000
@@ -10,7 +10,7 @@
 	gene.c 
 	genome.c 
 	segments.c 
-	sequencer.c 
+	sequencer.cpp 
 	table.c 
 	${LIB_DIR}/bitmap.c 
 	${LIB_DIR}/hash.c 
@@ -19,7 +19,7 @@
 	${LIB_DIR}/random.c 
 	${LIB_DIR}/list.c 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/thread.c 
+	${LIB_DIR}/thread.cpp 
 	${LIB_DIR}/vector.c)
 
 app(genome ${sources})
diff -x .git -x inputs -Naur stamp-0.9.10/genome/gene.h stamp-grun/genome/gene.h
--- stamp-0.9.10/genome/gene.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/gene.h	2017-03-20 15:19:45.000000000 +0000
@@ -77,6 +77,9 @@
 #include "bitmap.h"
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct gene {
     long length;
@@ -111,6 +114,9 @@
 void
 gene_free (gene_t* genePtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* GENE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/genome.c stamp-grun/genome/genome.c
--- stamp-0.9.10/genome/genome.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/genome.c	2017-03-20 15:19:45.000000000 +0000
@@ -229,14 +229,9 @@
     TIMER_READ(start);
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        sequencer_run(sequencerPtr);
-    }
-#else
-    thread_start(sequencer_run, (void*)sequencerPtr);
-#endif
+    
+    sequencer_run(sequencerPtr);
+
     thread_end_timing();
     GOTO_REAL();
     TIMER_READ(stop);
diff -x .git -x inputs -Naur stamp-0.9.10/genome/nucleotide.h stamp-grun/genome/nucleotide.h
--- stamp-0.9.10/genome/nucleotide.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/nucleotide.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef NUCLEOTIDE_H
 #define NUCLEOTIDE_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef enum nucleotide_type {
     NUCLEOTIDE_ADENINE  = 'a',
@@ -81,6 +84,9 @@
     NUCLEOTIDE_NUM_TYPE = 4
 } nucleotide_type_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* NUCLEOTIDE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/segments.h stamp-grun/genome/segments.h
--- stamp-0.9.10/genome/segments.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/segments.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,9 @@
 #include "random.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct segments {
     long length;
@@ -116,6 +119,9 @@
 void
 segments_free (segments_t* segmentsPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SEGMENTS_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.c stamp-grun/genome/sequencer.c
--- stamp-0.9.10/genome/sequencer.c	2017-03-21 17:41:16.000000000 +0000
+++ stamp-grun/genome/sequencer.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,948 +0,0 @@
-/* =============================================================================
- *
- * sequencer.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * Algorithm overview:
- *
- * 1) Remove duplicate segments by using hash-set
- * 2) Match segments using hash-based comparisons
- *    - Cycles are prevented by tracking starts/ends of matched chains
- * 3) Build sequence
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include "tm.h"
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include "hash.h"
-#include "hashtable.h"
-#include "segments.h"
-#include "sequencer.h"
-#include "table.h"
-#include "thread.h"
-#include "utility.h"
-#include "vector.h"
-#include "types.h"
-
-
-struct endInfoEntry {
-    bool_t isEnd;
-    long jumpToNext;
-};
-
-struct constructEntry {
-    XTM_DECL_LOCKABLE(bool_t, isStart);
-    XTM_DECL_LOCKABLE(char*, segment);
-    ulong_t endHash;
-    XTM_DECL_LOCKABLE(struct constructEntry*, startPtr);
-    struct constructEntry* nextPtr;
-    XTM_DECL_LOCKABLE(struct constructEntry*, endPtr);
-    XTM_DECL_LOCKABLE(long, overlap);
-    XTM_DECL_LOCKABLE(long, length);
-};
-
-
-/* =============================================================================
- * hashString
- * -- uses sdbm hash function
- * =============================================================================
- */
-static ulong_t
-hashString (char* str)
-{
-    ulong_t hash = 0;
-    long c;
-
-    /* Note: Do not change this hashing scheme */
-    while ((c = *str++) != '\0') {
-        hash = c + (hash << 6) + (hash << 16) - hash;
-    }
-
-    return (ulong_t)hash;
-}
-
-
-/* =============================================================================
- * hashSegment
- * -- For hashtable
- * =============================================================================
- */
-static ulong_t
-hashSegment (const void* keyPtr)
-{
-    return (ulong_t)hash_sdbm((char*)keyPtr); /* can be any "good" hash function */
-}
-
-
-/* =============================================================================
- * compareSegment
- * -- For hashtable
- * =============================================================================
- */
-static long
-compareSegment (const pair_t* a, const pair_t* b)
-{
-    return strcmp((char*)(a->firstPtr), (char*)(b->firstPtr));
-}
-
-
-/* =============================================================================
- * sequencer_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-sequencer_t*
-sequencer_alloc (long geneLength, long segmentLength, segments_t* segmentsPtr)
-{
-    sequencer_t* sequencerPtr;
-    long maxNumUniqueSegment = geneLength - segmentLength + 1;
-    long i;
-
-    sequencerPtr = (sequencer_t*)malloc(sizeof(sequencer_t));
-    if (sequencerPtr == NULL) {
-        return NULL;
-    }
-
-    sequencerPtr->uniqueSegmentsPtr =
-        hashtable_alloc(geneLength, &hashSegment, &compareSegment, -1, -1);
-    if (sequencerPtr->uniqueSegmentsPtr == NULL) {
-        return NULL;
-    }
-
-    /* For finding a matching entry */
-    sequencerPtr->endInfoEntries =
-        (endInfoEntry_t*)malloc(maxNumUniqueSegment * sizeof(endInfoEntry_t));
-    for (i = 0; i < maxNumUniqueSegment; i++) {
-        endInfoEntry_t* endInfoEntryPtr = &sequencerPtr->endInfoEntries[i];
-        endInfoEntryPtr->isEnd = TRUE;
-        endInfoEntryPtr->jumpToNext = 1;
-    }
-    sequencerPtr->startHashToConstructEntryTables =
-        (table_t**)malloc(segmentLength * sizeof(table_t*));
-    if (sequencerPtr->startHashToConstructEntryTables == NULL) {
-        return NULL;
-    }
-    for (i = 1; i < segmentLength; i++) { /* 0 is dummy entry */
-        sequencerPtr->startHashToConstructEntryTables[i] =
-            table_alloc(geneLength, NULL);
-        if (sequencerPtr->startHashToConstructEntryTables[i] == NULL) {
-            return NULL;
-        }
-    }
-    sequencerPtr->segmentLength = segmentLength;
-
-    /* For constructing sequence */
-    sequencerPtr->constructEntries =
-        (constructEntry_t*)malloc(maxNumUniqueSegment * sizeof(constructEntry_t));
-    if (sequencerPtr->constructEntries == NULL) {
-        return NULL;
-    }
-    for (i= 0; i < maxNumUniqueSegment; i++) {
-        constructEntry_t* constructEntryPtr = &sequencerPtr->constructEntries[i];
-        XTM_LOCKABLE_VALUE(constructEntryPtr->isStart) = TRUE;
-        XTM_LOCKABLE_INIT(constructEntryPtr->isStart);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->segment) = NULL;
-        XTM_LOCKABLE_INIT(constructEntryPtr->segment);
-        constructEntryPtr->endHash = 0;
-        XTM_LOCKABLE_VALUE(constructEntryPtr->startPtr) = constructEntryPtr;
-        XTM_LOCKABLE_INIT(constructEntryPtr->startPtr);
-        constructEntryPtr->nextPtr = NULL;
-        XTM_LOCKABLE_VALUE(constructEntryPtr->endPtr) = constructEntryPtr;
-        XTM_LOCKABLE_INIT(constructEntryPtr->endPtr);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->overlap) = 0;
-        XTM_LOCKABLE_INIT(constructEntryPtr->overlap);
-        XTM_LOCKABLE_VALUE(constructEntryPtr->length) = segmentLength;
-        XTM_LOCKABLE_INIT(constructEntryPtr->length);
-    }
-    sequencerPtr->hashToConstructEntryTable = table_alloc(geneLength, NULL);
-    if (sequencerPtr->hashToConstructEntryTable == NULL) {
-        return NULL;
-    }
-
-    sequencerPtr->segmentsPtr = segmentsPtr;
-
-    return sequencerPtr;
-}
-
-
-/* =============================================================================
- * sequencer_run
- * =============================================================================
- */
-void
-sequencer_run (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long threadId = thread_getId();
-
-    sequencer_t* sequencerPtr = (sequencer_t*)argPtr;
-
-    hashtable_t*      uniqueSegmentsPtr;
-    endInfoEntry_t*   endInfoEntries;
-    table_t**         startHashToConstructEntryTables;
-    constructEntry_t* constructEntries;
-    table_t*          hashToConstructEntryTable;
-
-    uniqueSegmentsPtr               = sequencerPtr->uniqueSegmentsPtr;
-    endInfoEntries                  = sequencerPtr->endInfoEntries;
-    startHashToConstructEntryTables = sequencerPtr->startHashToConstructEntryTables;
-    constructEntries                = sequencerPtr->constructEntries;
-    hashToConstructEntryTable       = sequencerPtr->hashToConstructEntryTable;
-
-    segments_t* segmentsPtr         = sequencerPtr->segmentsPtr;
-    assert(segmentsPtr);
-    vector_t*   segmentsContentsPtr = segmentsPtr->contentsPtr;
-    long        numSegment          = vector_getSize(segmentsContentsPtr);
-    long        segmentLength       = segmentsPtr->length;
-
-    long i;
-    long j;
-    long i_start;
-    long i_stop;
-    long numUniqueSegment;
-    long substringLength;
-    long entryIndex;
-
-    /*
-     * Step 1: Remove duplicate segments
-     */
-#if defined(HTM) || defined(STM)
-    long numThread = thread_getNumThread();
-    {
-        /* Choose disjoint segments [i_start,i_stop) for each thread */
-        long partitionSize = (numSegment + numThread/2) / numThread; /* with rounding */
-        i_start = threadId * partitionSize;
-        if (threadId == (numThread - 1)) {
-            i_stop = numSegment;
-        } else {
-            i_stop = i_start + partitionSize;
-        }
-    }
-#else /* !(HTM || STM) */
-    i_start = 0;
-    i_stop = numSegment;
-#endif /* !(HTM || STM) */
-    for (i = i_start; i < i_stop; i+=CHUNK_STEP1) {
-        TM_BEGIN();
-        {
-            long ii;
-            long ii_stop = MIN(i_stop, (i+CHUNK_STEP1));
-            for (ii = i; ii < ii_stop; ii++) {
-                void* segment = vector_at(segmentsContentsPtr, ii);
-                TMHASHTABLE_INSERT(uniqueSegmentsPtr,
-                                   segment,
-                                   segment);
-            } /* ii */
-        }
-        TM_END();
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Step 2a: Iterate over unique segments and compute hashes.
-     *
-     * For the gene "atcg", the hashes for the end would be:
-     *
-     *     "t", "tc", and "tcg"
-     *
-     * And for the gene "tcgg", the hashes for the start would be:
-     *
-     *    "t", "tc", and "tcg"
-     *
-     * The names are "end" and "start" because if a matching pair is found,
-     * they are the substring of the end part of the pair and the start
-     * part of the pair respectively. In the above example, "tcg" is the
-     * matching substring so:
-     *
-     *     (end)    (start)
-     *     a[tcg] + [tcg]g  = a[tcg]g    (overlap = "tcg")
-     */
-
-    /* uniqueSegmentsPtr is constant now */
-    numUniqueSegment = hashtable_getSize(uniqueSegmentsPtr);
-    entryIndex = 0;
-
-#if defined(HTM) || defined(STM)
-    {
-        /* Choose disjoint segments [i_start,i_stop) for each thread */
-        long num = uniqueSegmentsPtr->numBucket;
-        long partitionSize = (num + numThread/2) / numThread; /* with rounding */
-        i_start = threadId * partitionSize;
-        if (threadId == (numThread - 1)) {
-            i_stop = num;
-        } else {
-            i_stop = i_start + partitionSize;
-        }
-    }
-    {
-        /* Approximate disjoint segments of element allocation in constructEntries */
-        long partitionSize = (numUniqueSegment + numThread/2) / numThread; /* with rounding */
-        entryIndex = threadId * partitionSize;
-    }
-#else /* !(HTM || STM) */
-    i_start = 0;
-    i_stop = uniqueSegmentsPtr->numBucket;
-    entryIndex = 0;
-#endif /* !(HTM || STM) */
-
-    for (i = i_start; i < i_stop; i++) {
-
-        list_t* chainPtr = uniqueSegmentsPtr->buckets[i];
-        list_iter_t it;
-        list_iter_reset(&it, chainPtr);
-
-        while (list_iter_hasNext(&it, chainPtr)) {
-
-            char* segment =
-                (char*)((pair_t*)list_iter_next(&it, chainPtr))->firstPtr;
-            constructEntry_t* constructEntryPtr;
-            long j;
-            ulong_t startHash;
-            bool_t status;
-
-            /* Find an empty constructEntries entry */
-            TM_BEGIN();
-            while (((void*)TM_SHARED_READ_P(constructEntries[entryIndex].segment)) != NULL) {
-                entryIndex = (entryIndex + 1) % numUniqueSegment; /* look for empty */
-            }
-            constructEntryPtr = &constructEntries[entryIndex];
-            TM_SHARED_WRITE_P(constructEntryPtr->segment, segment);
-            TM_END();
-            entryIndex = (entryIndex + 1) % numUniqueSegment;
-
-            /*
-             * Save hashes (sdbm algorithm) of segment substrings
-             *
-             * endHashes will be computed for shorter substrings after matches
-             * have been made (in the next phase of the code). This will reduce
-             * the number of substrings for which hashes need to be computed.
-             *
-             * Since we can compute startHashes incrementally, we go ahead
-             * and compute all of them here.
-             */
-            /* constructEntryPtr is local now */
-            constructEntryPtr->endHash = (ulong_t)hashString(&segment[1]);
-
-            startHash = 0;
-            for (j = 1; j < segmentLength; j++) {
-                startHash = (ulong_t)segment[j-1] +
-                            (startHash << 6) + (startHash << 16) - startHash;
-                TM_BEGIN();
-                status = TMTABLE_INSERT(startHashToConstructEntryTables[j],
-                                        (ulong_t)startHash,
-                                        (void*)constructEntryPtr );
-                TM_END();
-                assert(status);
-            }
-
-            /*
-             * For looking up construct entries quickly
-             */
-            startHash = (ulong_t)segment[j-1] +
-                        (startHash << 6) + (startHash << 16) - startHash;
-            TM_BEGIN();
-            status = TMTABLE_INSERT(hashToConstructEntryTable,
-                                    (ulong_t)startHash,
-                                    (void*)constructEntryPtr);
-            TM_END();
-            assert(status);
-        }
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Step 2b: Match ends to starts by using hash-based string comparison.
-     */
-    for (substringLength = segmentLength-1; substringLength > 0; substringLength--) {
-
-        table_t* startHashToConstructEntryTablePtr =
-            startHashToConstructEntryTables[substringLength];
-        list_t** buckets = startHashToConstructEntryTablePtr->buckets;
-        long numBucket = startHashToConstructEntryTablePtr->numBucket;
-
-        long index_start;
-        long index_stop;
-
-#if defined(HTM) || defined(STM)
-        {
-            /* Choose disjoint segments [index_start,index_stop) for each thread */
-            long partitionSize = (numUniqueSegment + numThread/2) / numThread; /* with rounding */
-            index_start = threadId * partitionSize;
-            if (threadId == (numThread - 1)) {
-                index_stop = numUniqueSegment;
-            } else {
-                index_stop = index_start + partitionSize;
-            }
-        }
-#else /* !(HTM || STM) */
-        index_start = 0;
-        index_stop = numUniqueSegment;
-#endif /* !(HTM || STM) */
-
-        /* Iterating over disjoint itervals in the range [0, numUniqueSegment) */
-        for (entryIndex = index_start;
-             entryIndex < index_stop;
-             entryIndex += endInfoEntries[entryIndex].jumpToNext)
-        {
-            if (!endInfoEntries[entryIndex].isEnd) {
-                continue;
-            }
-
-            /*  ConstructEntries[entryIndex] is local data */
-            constructEntry_t* endConstructEntryPtr =
-                &constructEntries[entryIndex];
-            char* endSegment = XTM_LOCKABLE_VALUE(endConstructEntryPtr->segment);
-            ulong_t endHash = endConstructEntryPtr->endHash;
-
-            list_t* chainPtr = buckets[endHash % numBucket]; /* buckets: constant data */
-            list_iter_t it;
-            list_iter_reset(&it, chainPtr);
-
-            /* Linked list at chainPtr is constant */
-            while (list_iter_hasNext(&it, chainPtr)) {
-
-                constructEntry_t* startConstructEntryPtr =
-                    (constructEntry_t*)list_iter_next(&it, chainPtr);
-                char* startSegment = XTM_LOCKABLE_VALUE(startConstructEntryPtr->segment);
-                long newLength = 0;
-
-                /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
-                TM_BEGIN();
-
-                /* Check if matches */
-                if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
-                    (TM_SHARED_READ_P(endConstructEntryPtr->startPtr) != startConstructEntryPtr) &&
-                    (strncmp(startSegment,
-                             &endSegment[segmentLength - substringLength],
-                             substringLength) == 0))
-                {
-                    TM_SHARED_WRITE(startConstructEntryPtr->isStart, FALSE);
-
-                    constructEntry_t* startConstructEntry_endPtr;
-                    constructEntry_t* endConstructEntry_startPtr;
-
-                    /* Update endInfo (appended something so no longer end) */
-                    TM_LOCAL_WRITE(endInfoEntries[entryIndex].isEnd, FALSE);
-
-                    /* Update segment chain construct info */
-                    startConstructEntry_endPtr =
-                        (constructEntry_t*)TM_SHARED_READ_P(startConstructEntryPtr->endPtr);
-                    endConstructEntry_startPtr =
-                        (constructEntry_t*)TM_SHARED_READ_P(endConstructEntryPtr->startPtr);
-
-                    assert(startConstructEntry_endPtr);
-                    assert(endConstructEntry_startPtr);
-                    TM_SHARED_WRITE_P(startConstructEntry_endPtr->startPtr,
-                                      endConstructEntry_startPtr);
-                    TM_LOCAL_WRITE_P(endConstructEntryPtr->nextPtr,
-                                     startConstructEntryPtr);
-                    TM_SHARED_WRITE_P(endConstructEntry_startPtr->endPtr,
-                                      startConstructEntry_endPtr);
-                    TM_SHARED_WRITE(endConstructEntryPtr->overlap, substringLength);
-                    newLength = (long)TM_SHARED_READ(endConstructEntry_startPtr->length) +
-                                (long)TM_SHARED_READ(startConstructEntryPtr->length) -
-                                substringLength;
-                    TM_SHARED_WRITE(endConstructEntry_startPtr->length, newLength);
-                } /* if (matched) */
-
-                TM_END();
-
-                if (!endInfoEntries[entryIndex].isEnd) { /* if there was a match */
-                    break;
-                }
-            } /* iterate over chain */
-
-        } /* for (endIndex < numUniqueSegment) */
-
-        thread_barrier_wait();
-
-        /*
-         * Step 2c: Update jump values and hashes
-         *
-         * endHash entries of all remaining ends are updated to the next
-         * substringLength. Additionally jumpToNext entries are updated such
-         * that they allow to skip non-end entries. Currently this is sequential
-         * because parallelization did not perform better.
-.        */
-
-        if (threadId == 0) {
-            if (substringLength > 1) {
-                long index = segmentLength - substringLength + 1;
-                /* initialization if j and i: with i being the next end after j=0 */
-                for (i = 1; !endInfoEntries[i].isEnd; i+=endInfoEntries[i].jumpToNext) {
-                    /* find first non-null */
-                }
-                /* entry 0 is handled seperately from the loop below */
-                endInfoEntries[0].jumpToNext = i;
-                if (endInfoEntries[0].isEnd) {
-                    constructEntry_t* constructEntryPtr = &constructEntries[0];
-                    char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
-                    constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
-                }
-                /* Continue scanning (do not reset i) */
-                for (j = 0; i < numUniqueSegment; i+=endInfoEntries[i].jumpToNext) {
-                    if (endInfoEntries[i].isEnd) {
-                        constructEntry_t* constructEntryPtr = &constructEntries[i];
-                        char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
-                        constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
-                        endInfoEntries[j].jumpToNext = MAX(1, (i - j));
-                        j = i;
-                    }
-                }
-                endInfoEntries[j].jumpToNext = i - j;
-            }
-        }
-
-        thread_barrier_wait();
-
-    } /* for (substringLength > 0) */
-
-
-    thread_barrier_wait();
-
-    /*
-     * Step 3: Build sequence string
-     */
-    if (threadId == 0) {
-
-        long totalLength = 0;
-
-        for (i = 0; i < numUniqueSegment; i++) {
-            constructEntry_t* constructEntryPtr = &constructEntries[i];
-            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
-              totalLength += XTM_LOCKABLE_VALUE(constructEntryPtr->length);
-            }
-        }
-
-        sequencerPtr->sequence = (char*)P_MALLOC((totalLength+1) * sizeof(char));
-        char* sequence = sequencerPtr->sequence;
-        assert(sequence);
-
-        char* copyPtr = sequence;
-        long sequenceLength = 0;
-
-        for (i = 0; i < numUniqueSegment; i++) {
-            constructEntry_t* constructEntryPtr = &constructEntries[i];
-            /* If there are several start segments, we append in arbitrary order  */
-            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
-                long newSequenceLength = sequenceLength + XTM_LOCKABLE_VALUE(constructEntryPtr->length);
-                assert( newSequenceLength <= totalLength );
-                copyPtr = sequence + sequenceLength;
-                sequenceLength = newSequenceLength;
-                do {
-                    long numChar = segmentLength - XTM_LOCKABLE_VALUE(constructEntryPtr->overlap);
-                    if ((copyPtr + numChar) > (sequence + newSequenceLength)) {
-                        TM_PRINT0("ERROR: sequence length != actual length\n");
-                        break;
-                    }
-                    memcpy(copyPtr,
-                           XTM_LOCKABLE_VALUE(constructEntryPtr->segment),
-                           (numChar * sizeof(char)));
-                    copyPtr += numChar;
-                } while ((constructEntryPtr = constructEntryPtr->nextPtr) != NULL);
-                assert(copyPtr <= (sequence + sequenceLength));
-            }
-        }
-
-        assert(sequence != NULL);
-        sequence[sequenceLength] = '\0';
-    }
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * sequencer_free
- * =============================================================================
- */
-void
-sequencer_free (sequencer_t* sequencerPtr)
-{
-    long i;
-
-    table_free(sequencerPtr->hashToConstructEntryTable);
-    free(sequencerPtr->constructEntries);
-    for (i = 1; i < sequencerPtr->segmentLength; i++) {
-        table_free(sequencerPtr->startHashToConstructEntryTables[i]);
-    }
-    free(sequencerPtr->startHashToConstructEntryTables);
-    free(sequencerPtr->endInfoEntries);
-#if 0
-    /* TODO: fix mixed sequential/parallel allocation */
-    hashtable_free(sequencerPtr->uniqueSegmentsPtr);
-    if (sequencerPtr->sequence != NULL) {
-        free(sequencerPtr->sequence);
-    }
-#endif
-    free(sequencerPtr);
-}
-
-
-/* =============================================================================
- * TEST_SEQUENCER
- * =============================================================================
- */
-#ifdef TEST_SEQUENCER
-
-
-#include <assert.h>
-#include <stdio.h>
-#include "segments.h"
-
-
-char* gene1 = "gatcggcagc";
-char* segments1[] = {
-    "atcg",
-    "gcag",
-    "tcgg",
-    "cagc",
-    "gatc",
-    NULL
-};
-
-char* gene2 = "aaagc";
-char* segments2[] = {
-    "aaa",
-    "aag",
-    "agc",
-    NULL
-};
-
-char* gene3 = "aaacaaagaaat";
-char* segments3[] = {
-    "aaac",
-    "aaag",
-    "aaat",
-    NULL
-};
-
-char* gene4 = "ttggctacgtatcgcacggt";
-char* segments4[] = {
-    "cgtatcgc",
-    "tcgcacgg",
-    "gtatcgca",
-    "tatcgcac",
-    "atcgcacg",
-    "ttggctac",
-    "ctacgtat",
-    "acgtatcg",
-    "ctacgtat",
-    "cgtatcgc",
-    "atcgcacg",
-    "ggctacgt",
-    "tacgtatc",
-    "tcgcacgg",
-    "ttggctac",
-    "ggctacgt",
-    "atcgcacg",
-    "tatcgcac",
-    "cgtatcgc",
-    "acgtatcg",
-    "gtatcgca",
-    "gtatcgca",
-    "cgcacggt",
-    "tatcgcac",
-    "ttggctac",
-    "atcgcacg",
-    "acgtatcg",
-    "gtatcgca",
-    "ttggctac",
-    "tggctacg",
-    NULL
-};
-
-char* gene5 = "gatcggcagctggtacggcg";
-char* segments5[] = {
-    "atcggcag",
-    "gtacggcg",
-    "gatcggca",
-    "cagctggt",
-    "tggtacgg",
-    "gatcggca",
-    "gatcggca",
-    "tcggcagc",
-    "ggtacggc",
-    "tggtacgg",
-    "tcggcagc",
-    "gcagctgg",
-    "gatcggca",
-    "gctggtac",
-    "gatcggca",
-    "ctggtacg",
-    "ggcagctg",
-    "tcggcagc",
-    "gtacggcg",
-    "gcagctgg",
-    "ggcagctg",
-    "tcggcagc",
-    "cagctggt",
-    "tggtacgg",
-    "cagctggt",
-    "gcagctgg",
-    "gctggtac",
-    "cggcagct",
-    "agctggta",
-    "ctggtacg",
-    NULL
-};
-
-char* gene6 = "ttggtgagccgtaagactcc";
-char* segments6[] = {
-    "cgtaagac",
-    "taagactc",
-    "gtgagccg",
-    "gagccgta",
-    "gccgtaag",
-    "tgagccgt",
-    "gccgtaag",
-    "cgtaagac",
-    "ttggtgag",
-    "agccgtaa",
-    "gccgtaag",
-    "aagactcc",
-    "ggtgagcc",
-    "ttggtgag",
-    "agccgtaa",
-    "gagccgta",
-    "aagactcc",
-    "ttggtgag",
-    "gtaagact",
-    "ccgtaaga",
-    "ttggtgag",
-    "gagccgta",
-    "ggtgagcc",
-    "gagccgta",
-    "gccgtaag",
-    "aagactcc",
-    "gtaagact",
-    "ccgtaaga",
-    "tgagccgt",
-    "ttggtgag",
-    NULL
-};
-
-char* gene7 = "gatcggcagctggtacggcg";
-char* segments7[] = {
-    "atcggcag",
-    "gtacggcg",
-    "gatcggca",
-    "cagctggt",
-    "tggtacgg",
-    "gatcggca",
-    "gatcggca",
-    "tcggcagc",
-    "ggtacggc",
-    "tggtacgg",
-    "tcggcagc",
-    "gcagctgg",
-    "gatcggca",
-    "gctggtac",
-    "gatcggca",
-    "ctggtacg",
-    "ggcagctg",
-    "tcggcagc",
-    "gtacggcg",
-    "gcagctgg",
-    "ggcagctg",
-    "tcggcagc",
-    "cagctggt",
-    "tggtacgg",
-    "cagctggt",
-    "gcagctgg",
-    "gctggtac",
-    "cggcagct",
-    "agctggta",
-    "ctggtacg",
-    NULL
-};
-
-char* gene8 = "ttggtgagccgtaagactcc";
-char* segments8[] = {
-    "cgtaagac",
-    "taagactc",
-    "gtgagccg",
-    "gagccgta",
-    "gccgtaag",
-    "tgagccgt",
-    "gccgtaag",
-    "cgtaagac",
-    "ttggtgag",
-    "agccgtaa",
-    "gccgtaag",
-    "aagactcc",
-    "ggtgagcc",
-    "ttggtgag",
-    "agccgtaa",
-    "gagccgta",
-    "aagactcc",
-    "ttggtgag",
-    "gtaagact",
-    "ccgtaaga",
-    "ttggtgag",
-    "gagccgta",
-    "ggtgagcc",
-    "gagccgta",
-    "gccgtaag",
-    "aagactcc",
-    "gtaagact",
-    "ccgtaaga",
-    "tgagccgt",
-    "ttggtgag",
-    NULL
-};
-
-
-static segments_t*
-createSegments (char* segments[])
-{
-    long i = 0;
-    segments_t* segmentsPtr = (segments_t*)malloc(sizeof(segments));
-
-    segmentsPtr->length = strlen(segments[0]);
-    segmentsPtr->contentsPtr = vector_alloc(1);
-
-    while (segments[i] != NULL) {
-        bool_t status = vector_pushBack(segmentsPtr->contentsPtr,
-                                        (void*)segments[i]);
-        assert(status);
-        i++;
-    }
-
-    segmentsPtr->minNum = vector_getSize(segmentsPtr->contentsPtr);
-
-    return segmentsPtr;
-}
-
-
-static void
-tester (char* gene, char* segments[])
-{
-    segments_t* segmentsPtr;
-    sequencer_t* sequencerPtr;
-
-    segmentsPtr = createSegments(segments);
-    sequencerPtr = sequencer_alloc(strlen(gene), segmentsPtr->length, segmentsPtr);
-
-    sequencer_run((void*)sequencerPtr);
-
-    printf("gene     = %s\n", gene);
-    printf("sequence = %s\n", sequencerPtr->sequence);
-    assert(strcmp(sequencerPtr->sequence, gene) == 0);
-
-    sequencer_free(sequencerPtr);
-}
-
-
-int
-main ()
-{
-    bool_t status = memory_init(1, 4, 2);
-    assert(status);
-    thread_startup(1);
-
-    puts("Starting...");
-
-    /* Simple test */
-    tester(gene1, segments1);
-
-    /* Simple test with aliasing segments */
-    tester(gene2, segments2);
-
-    /* Simple test with non-overlapping segments */
-    tester(gene3, segments3);
-
-    /* Complex tests */
-    tester(gene4, segments4);
-    tester(gene5, segments5);
-    tester(gene6, segments6);
-    tester(gene7, segments7);
-    tester(gene8, segments8);
-
-    puts("Passed all tests.");
-
-    return 0;
-}
-
-
-#endif /* TEST_SEQUENCER */
-
-
-/* =============================================================================
- *
- * End of sequencer.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.cpp stamp-grun/genome/sequencer.cpp
--- stamp-0.9.10/genome/sequencer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/genome/sequencer.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,904 @@
+/* =============================================================================
+ *
+ * sequencer.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * Algorithm overview:
+ *
+ * 1) Remove duplicate segments by using hash-set
+ * 2) Match segments using hash-based comparisons
+ *    - Cycles are prevented by tracking starts/ends of matched chains
+ * 3) Build sequence
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+#include <boost/iterator/counting_iterator.hpp>
+#include <boost/iterator/iterator_adaptor.hpp>
+
+#include "tm.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "hash.h"
+#include "hashtable.h"
+#include "segments.h"
+#include "sequencer.h"
+#include "table.h"
+#include "thread.h"
+#include "utility.h"
+#include "vector.h"
+#include "types.h"
+
+
+struct endInfoEntry {
+    XTM_DECL_LOCKABLE(bool_t, isEnd);
+    long jumpToNext;
+};
+
+struct constructEntry {
+    XTM_DECL_LOCKABLE(bool_t, isStart);
+    XTM_DECL_LOCKABLE(char*, segment);
+    ulong_t endHash;
+    XTM_DECL_LOCKABLE(struct constructEntry*, startPtr);
+    XTM_DECL_LOCKABLE(struct constructEntry*, nextPtr);
+    XTM_DECL_LOCKABLE(struct constructEntry*, endPtr);
+    XTM_DECL_LOCKABLE(long, overlap);
+    XTM_DECL_LOCKABLE(long, length);
+};
+
+
+/* =============================================================================
+ * hashString
+ * -- uses sdbm hash function
+ * =============================================================================
+ */
+static ulong_t
+hashString (char* str)
+{
+    ulong_t hash = 0;
+    long c;
+
+    /* Note: Do not change this hashing scheme */
+    while ((c = *str++) != '\0') {
+        hash = c + (hash << 6) + (hash << 16) - hash;
+    }
+
+    return (ulong_t)hash;
+}
+
+
+/* =============================================================================
+ * hashSegment
+ * -- For hashtable
+ * =============================================================================
+ */
+static ulong_t
+hashSegment (const void* keyPtr)
+{
+    return (ulong_t)hash_sdbm((char*)keyPtr); /* can be any "good" hash function */
+}
+
+
+/* =============================================================================
+ * compareSegment
+ * -- For hashtable
+ * =============================================================================
+ */
+static long
+compareSegment (const pair_t* a, const pair_t* b)
+{
+    return strcmp((char*)(a->firstPtr), (char*)(b->firstPtr));
+}
+
+
+/* =============================================================================
+ * sequencer_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+sequencer_t*
+sequencer_alloc (long geneLength, long segmentLength, segments_t* segmentsPtr)
+{
+    sequencer_t* sequencerPtr;
+    long maxNumUniqueSegment = geneLength - segmentLength + 1;
+    long i;
+
+    sequencerPtr = (sequencer_t*)malloc(sizeof(sequencer_t));
+    if (sequencerPtr == NULL) {
+        return NULL;
+    }
+
+    sequencerPtr->uniqueSegmentsPtr =
+        hashtable_alloc(geneLength, &hashSegment, &compareSegment, -1, -1);
+    if (sequencerPtr->uniqueSegmentsPtr == NULL) {
+        return NULL;
+    }
+
+    /* For finding a matching entry */
+    sequencerPtr->endInfoEntries =
+        (endInfoEntry_t*)malloc(maxNumUniqueSegment * sizeof(endInfoEntry_t));
+    for (i = 0; i < maxNumUniqueSegment; i++) {
+        endInfoEntry_t* endInfoEntryPtr = &sequencerPtr->endInfoEntries[i];
+        XTM_LOCKABLE_VALUE(endInfoEntryPtr->isEnd) = TRUE;
+        XTM_LOCKABLE_INIT(endInfoEntryPtr->isEnd);
+        endInfoEntryPtr->jumpToNext = 1;
+    }
+    sequencerPtr->startHashToConstructEntryTables =
+        (table_t**)malloc(segmentLength * sizeof(table_t*));
+    if (sequencerPtr->startHashToConstructEntryTables == NULL) {
+        return NULL;
+    }
+    for (i = 1; i < segmentLength; i++) { /* 0 is dummy entry */
+        sequencerPtr->startHashToConstructEntryTables[i] =
+            table_alloc(geneLength, NULL);
+        if (sequencerPtr->startHashToConstructEntryTables[i] == NULL) {
+            return NULL;
+        }
+    }
+    sequencerPtr->segmentLength = segmentLength;
+
+    /* For constructing sequence */
+    sequencerPtr->constructEntries =
+        (constructEntry_t*)malloc(maxNumUniqueSegment * sizeof(constructEntry_t));
+    if (sequencerPtr->constructEntries == NULL) {
+        return NULL;
+    }
+    for (i= 0; i < maxNumUniqueSegment; i++) {
+        constructEntry_t* constructEntryPtr = &sequencerPtr->constructEntries[i];
+        XTM_LOCKABLE_VALUE(constructEntryPtr->isStart) = TRUE;
+        XTM_LOCKABLE_INIT(constructEntryPtr->isStart);
+        XTM_LOCKABLE_VALUE(constructEntryPtr->segment) = NULL;
+        XTM_LOCKABLE_INIT(constructEntryPtr->segment);
+        constructEntryPtr->endHash = 0;
+        XTM_LOCKABLE_VALUE(constructEntryPtr->startPtr) = constructEntryPtr;
+        XTM_LOCKABLE_INIT(constructEntryPtr->startPtr);
+        XTM_LOCKABLE_VALUE(constructEntryPtr->nextPtr) = NULL;
+        XTM_LOCKABLE_INIT(constructEntryPtr->nextPtr);
+        XTM_LOCKABLE_VALUE(constructEntryPtr->endPtr) = constructEntryPtr;
+        XTM_LOCKABLE_INIT(constructEntryPtr->endPtr);
+        XTM_LOCKABLE_VALUE(constructEntryPtr->overlap) = 0;
+        XTM_LOCKABLE_INIT(constructEntryPtr->overlap);
+        XTM_LOCKABLE_VALUE(constructEntryPtr->length) = segmentLength;
+        XTM_LOCKABLE_INIT(constructEntryPtr->length);
+    }
+    sequencerPtr->hashToConstructEntryTable = table_alloc(geneLength, NULL);
+    if (sequencerPtr->hashToConstructEntryTable == NULL) {
+        return NULL;
+    }
+
+    sequencerPtr->segmentsPtr = segmentsPtr;
+
+    return sequencerPtr;
+}
+
+struct Fn1 {
+    vector_t*   segmentsContentsPtr;
+    hashtable_t* uniqueSegmentsPtr;
+
+    void operator()(long ii, Galois::UserContext<long>&) {
+        void* segment = vector_at(segmentsContentsPtr, ii);
+        TMHASHTABLE_INSERT(uniqueSegmentsPtr,
+                           segment,
+                           segment);
+    }
+};
+
+struct Fn2 {
+    struct ArgType {
+      char* segment;
+      long entryIndex;
+      long index;
+      ulong_t hash;
+    };
+
+    table_t**         startHashToConstructEntryTables;
+    constructEntry_t* constructEntries;
+    table_t*          hashToConstructEntryTable;
+    long segmentLength;
+
+    void operator()(const ArgType& p, Galois::UserContext<ArgType>& ctx) {
+        char* segment = p.segment;
+        long entryIndex = p.entryIndex;
+        constructEntry_t* constructEntryPtr = &constructEntries[entryIndex];
+
+        if (p.index == 0) {
+            XTM_LOCKABLE_VALUE(constructEntryPtr->segment) = segment;
+            constructEntryPtr->endHash = (ulong_t)hashString(&segment[1]);
+            ArgType n = { p.segment, p.entryIndex, p.index + 1, p.hash };
+            ctx.push(n);
+        } else if (p.index < segmentLength) {
+            bool_t status;
+            ulong_t startHash = (ulong_t)segment[p.index-1] + (p.hash << 6) + (p.hash << 16) - p.hash;
+            status = TMTABLE_INSERT(startHashToConstructEntryTables[p.index],
+                                    (ulong_t)startHash,
+                                    (void*)constructEntryPtr );
+            //assert(status);
+            ArgType n = { p.segment, p.entryIndex, p.index + 1, startHash };
+            ctx.push(n);
+        } else {
+            bool_t status;
+            ulong_t startHash = (ulong_t)segment[p.index-1] + (p.hash << 6) + (p.hash << 16) - p.hash;
+            status = TMTABLE_INSERT(hashToConstructEntryTable,
+                                    (ulong_t)startHash,
+                                    (void*)constructEntryPtr);
+            //assert(status);
+        }
+    }
+};
+
+struct Fn4 {
+    constructEntry_t* constructEntries;
+    endInfoEntry_t*   endInfoEntries;
+    table_t* startHashToConstructEntryTablePtr;
+    long segmentLength;
+    long substringLength;
+
+    void execute(long entryIndex) {
+        /*  ConstructEntries[entryIndex] is local data */
+        constructEntry_t* endConstructEntryPtr = &constructEntries[entryIndex];
+        char* endSegment = XTM_LOCKABLE_VALUE(endConstructEntryPtr->segment);
+        ulong_t endHash = endConstructEntryPtr->endHash;
+        list_t** buckets = startHashToConstructEntryTablePtr->buckets;
+        long numBucket = startHashToConstructEntryTablePtr->numBucket;
+
+        // find from startHash
+        list_t* chainPtr = (list_t*) buckets[endHash % numBucket];
+        list_iter_t it;
+        list_iter_reset(&it, chainPtr);
+
+        /* Linked list at chainPtr is constant */
+        while (list_iter_hasNext(&it, chainPtr)) {
+            constructEntry_t* startConstructEntryPtr =
+                (constructEntry_t*)list_iter_next(&it, chainPtr);
+            char* startSegment = XTM_LOCKABLE_VALUE(startConstructEntryPtr->segment);
+            long newLength = 0;
+
+            /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
+            TM_BEGIN();
+
+            /* Check if matches */
+            if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
+                (TM_SHARED_READ_P(endConstructEntryPtr->startPtr) != startConstructEntryPtr) &&
+                (strncmp(startSegment,
+                         &endSegment[segmentLength - substringLength],
+                         substringLength) == 0))
+            {
+                TM_SHARED_WRITE(startConstructEntryPtr->isStart, FALSE);
+
+                constructEntry_t* startConstructEntry_endPtr;
+                constructEntry_t* endConstructEntry_startPtr;
+
+                /* Update endInfo (appended something so no longer end) */
+                TM_SHARED_WRITE(endInfoEntries[entryIndex].isEnd, FALSE);
+
+                /* Update segment chain construct info */
+                startConstructEntry_endPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(startConstructEntryPtr->endPtr);
+                endConstructEntry_startPtr =
+                    (constructEntry_t*)TM_SHARED_READ_P(endConstructEntryPtr->startPtr);
+                assert(startConstructEntry_endPtr);
+                assert(endConstructEntry_startPtr);
+                TM_SHARED_WRITE_P(startConstructEntry_endPtr->startPtr,
+                                  endConstructEntry_startPtr);
+                TM_SHARED_WRITE_P(endConstructEntryPtr->nextPtr,
+                                 startConstructEntryPtr);
+                TM_SHARED_WRITE_P(endConstructEntry_startPtr->endPtr,
+                                  startConstructEntry_endPtr);
+                TM_SHARED_WRITE(endConstructEntryPtr->overlap, substringLength);
+                newLength = (long)TM_SHARED_READ(endConstructEntry_startPtr->length) +
+                            (long)TM_SHARED_READ(startConstructEntryPtr->length) -
+                            substringLength;
+                TM_SHARED_WRITE(endConstructEntry_startPtr->length, newLength);
+            } /* if (matched) */
+
+            TM_END();
+
+            if (!TM_SHARED_READ(endInfoEntries[entryIndex].isEnd)) { /* if there was a match */
+                break;
+            }
+        } /* iterate over chain */
+    }
+
+    void operator()(long entryIndex, Galois::UserContext<long>&) {
+        if (!TM_SHARED_READ(endInfoEntries[entryIndex].isEnd)) {
+            return;
+        }
+        execute(entryIndex);
+    }
+};
+
+struct Fn02 {
+    Galois::InsertBag<long>& indices;
+    Fn02(Galois::InsertBag<long>& i): indices(i) { }
+    void operator()(long i) {
+        indices.push(i);
+    }
+};
+/* =============================================================================
+ * sequencer_run
+ * =============================================================================
+ */
+void
+sequencer_run (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    long threadId = 0; //thread_getId();
+
+    sequencer_t* sequencerPtr = (sequencer_t*)argPtr;
+
+    hashtable_t*      uniqueSegmentsPtr;
+    endInfoEntry_t*   endInfoEntries;
+    table_t**         startHashToConstructEntryTables;
+    constructEntry_t* constructEntries;
+    table_t*          hashToConstructEntryTable;
+
+    uniqueSegmentsPtr               = sequencerPtr->uniqueSegmentsPtr;
+    endInfoEntries                  = sequencerPtr->endInfoEntries;
+    startHashToConstructEntryTables = sequencerPtr->startHashToConstructEntryTables;
+    constructEntries                = sequencerPtr->constructEntries;
+    hashToConstructEntryTable       = sequencerPtr->hashToConstructEntryTable;
+
+    segments_t* segmentsPtr         = sequencerPtr->segmentsPtr;
+    assert(segmentsPtr);
+    vector_t*   segmentsContentsPtr = segmentsPtr->contentsPtr;
+    long        numSegment          = vector_getSize(segmentsContentsPtr);
+    long        segmentLength       = segmentsPtr->length;
+
+    long i;
+    long j;
+    long i_start;
+    long i_stop;
+    long numUniqueSegment;
+    long substringLength;
+    long entryIndex;
+
+    /*
+     * Step 1: Remove duplicate segments
+     */
+    Fn1 fn1 = { segmentsContentsPtr, uniqueSegmentsPtr };
+    Galois::for_each(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numSegment), fn1, Galois::wl<Galois::WorkList::dChunkedFIFO<128> >());
+
+    /*
+     * Step 2a: Iterate over unique segments and compute hashes.
+     *
+     * For the gene "atcg", the hashes for the end would be:
+     *
+     *     "t", "tc", and "tcg"
+     *
+     * And for the gene "tcgg", the hashes for the start would be:
+     *
+     *    "t", "tc", and "tcg"
+     *
+     * The names are "end" and "start" because if a matching pair is found,
+     * they are the substring of the end part of the pair and the start
+     * part of the pair respectively. In the above example, "tcg" is the
+     * matching substring so:
+     *
+     *     (end)    (start)
+     *     a[tcg] + [tcg]g  = a[tcg]g    (overlap = "tcg")
+     */
+    numUniqueSegment = 0;
+    typedef std::deque<Fn2::ArgType> UniqueEntries;
+    UniqueEntries uniqueEntries;
+
+    for (long ii = 0; ii < uniqueSegmentsPtr->numBucket; ++ii) {
+         list_t* chainPtr = uniqueSegmentsPtr->buckets[ii];
+         list_iter_t it;
+         list_iter_reset(&it, chainPtr);
+         while (list_iter_hasNext(&it, chainPtr)) {
+              pair_t* pair = (pair_t*) list_iter_next(&it, chainPtr);
+              char* segment = (char*) pair->firstPtr;
+              Fn2::ArgType p = { segment, numUniqueSegment++, 0, 0 };
+              uniqueEntries.push_back(p);
+         }
+    }
+
+    Fn2 fn2 = { startHashToConstructEntryTables, constructEntries, hashToConstructEntryTable, segmentLength };
+    Galois::for_each(uniqueEntries.begin(), uniqueEntries.end(), fn2, Galois::wl<Galois::WorkList::dChunkedLIFO<64> >());
+    Galois::InsertBag<long> indices;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numUniqueSegment),
+        Fn02(indices));
+
+    /*
+     * Step 2b: Match ends to starts by using hash-based string comparison.
+     */
+    for (substringLength = segmentLength-1; substringLength > 0; substringLength--) {
+
+        table_t* startHashToConstructEntryTablePtr =
+            startHashToConstructEntryTables[substringLength];
+        list_t** buckets = startHashToConstructEntryTablePtr->buckets;
+        long numBucket = startHashToConstructEntryTablePtr->numBucket;
+
+        Fn4 fn4 = { constructEntries, endInfoEntries, startHashToConstructEntryTablePtr, segmentLength, substringLength };
+        Galois::for_each_local(indices, fn4);
+
+        /*
+         * Step 2c: Update jump values and hashes
+         *
+         * endHash entries of all remaining ends are updated to the next
+         * substringLength. Additionally jumpToNext entries are updated such
+         * that they allow to skip non-end entries. Currently this is sequential
+         * because parallelization did not perform better.
+         */
+
+        if (threadId == 0) {
+            if (substringLength > 1) {
+                long index = segmentLength - substringLength + 1;
+                /* initialization if j and i: with i being the next end after j=0 */
+                for (i = 1; !XTM_LOCKABLE_VALUE(endInfoEntries[i].isEnd); i+=endInfoEntries[i].jumpToNext) {
+                    /* find first non-null */
+                }
+                /* entry 0 is handled seperately from the loop below */
+                endInfoEntries[0].jumpToNext = i;
+                if (XTM_LOCKABLE_VALUE(endInfoEntries[0].isEnd)) {
+                    constructEntry_t* constructEntryPtr = &constructEntries[0];
+                    char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
+                    constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
+                }
+                /* Continue scanning (do not reset i) */
+                for (j = 0; i < numUniqueSegment; i+=endInfoEntries[i].jumpToNext) {
+                    if (XTM_LOCKABLE_VALUE(endInfoEntries[i].isEnd)) {
+                        constructEntry_t* constructEntryPtr = &constructEntries[i];
+                        char* segment = XTM_LOCKABLE_VALUE(constructEntryPtr->segment);
+                        constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
+                        endInfoEntries[j].jumpToNext = (1 > (i - j)) ? 1 : (i - j); // MAX(1, (i - j));
+                        j = i;
+                    }
+                }
+                endInfoEntries[j].jumpToNext = i - j;
+            }
+            // Populate insert bag with right entries
+            indices.clear();
+            // XXX TODO LOCAL
+            for (i = 0; i < numUniqueSegment; i += endInfoEntries[i].jumpToNext) {
+                if (XTM_LOCKABLE_VALUE(endInfoEntries[i].isEnd))
+                    continue;
+                indices.push(i);
+            }
+        }
+
+    } /* for (substringLength > 0) */
+
+    /*
+     * Step 3: Build sequence string
+     */
+    if (threadId == 0) {
+
+        long totalLength = 0;
+
+        for (i = 0; i < numUniqueSegment; i++) {
+            constructEntry_t* constructEntryPtr = &constructEntries[i];
+            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
+              totalLength += XTM_LOCKABLE_VALUE(constructEntryPtr->length);
+            }
+        }
+
+        sequencerPtr->sequence = (char*)P_MALLOC((totalLength+1) * sizeof(char));
+        char* sequence = sequencerPtr->sequence;
+        assert(sequence);
+
+        char* copyPtr = sequence;
+        long sequenceLength = 0;
+
+        for (i = 0; i < numUniqueSegment; i++) {
+            constructEntry_t* constructEntryPtr = &constructEntries[i];
+            /* If there are several start segments, we append in arbitrary order  */
+            if (XTM_LOCKABLE_VALUE(constructEntryPtr->isStart)) {
+                long newSequenceLength = sequenceLength + XTM_LOCKABLE_VALUE(constructEntryPtr->length);
+                assert( newSequenceLength <= totalLength );
+                copyPtr = sequence + sequenceLength;
+                sequenceLength = newSequenceLength;
+                do {
+                    long numChar = segmentLength - XTM_LOCKABLE_VALUE(constructEntryPtr->overlap);
+                    if ((copyPtr + numChar) > (sequence + newSequenceLength)) {
+                        TM_PRINT0("ERROR: sequence length != actual length\n");
+                        break;
+                    }
+                    memcpy(copyPtr,
+                           XTM_LOCKABLE_VALUE(constructEntryPtr->segment),
+                           (numChar * sizeof(char)));
+                    copyPtr += numChar;
+                } while ((constructEntryPtr = XTM_LOCKABLE_VALUE(constructEntryPtr->nextPtr)) != NULL);
+                assert(copyPtr <= (sequence + sequenceLength));
+            }
+        }
+
+        assert(sequence != NULL);
+        sequence[sequenceLength] = '\0';
+    }
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * sequencer_free
+ * =============================================================================
+ */
+void
+sequencer_free (sequencer_t* sequencerPtr)
+{
+    long i;
+
+    table_free(sequencerPtr->hashToConstructEntryTable);
+    free(sequencerPtr->constructEntries);
+    for (i = 1; i < sequencerPtr->segmentLength; i++) {
+        table_free(sequencerPtr->startHashToConstructEntryTables[i]);
+    }
+    free(sequencerPtr->startHashToConstructEntryTables);
+    free(sequencerPtr->endInfoEntries);
+#if 0
+    /* TODO: fix mixed sequential/parallel allocation */
+    hashtable_free(sequencerPtr->uniqueSegmentsPtr);
+    if (sequencerPtr->sequence != NULL) {
+        free(sequencerPtr->sequence);
+    }
+#endif
+    free(sequencerPtr);
+}
+
+
+/* =============================================================================
+ * TEST_SEQUENCER
+ * =============================================================================
+ */
+#ifdef TEST_SEQUENCER
+
+
+#include <assert.h>
+#include <stdio.h>
+#include "segments.h"
+
+
+char* gene1 = "gatcggcagc";
+char* segments1[] = {
+    "atcg",
+    "gcag",
+    "tcgg",
+    "cagc",
+    "gatc",
+    NULL
+};
+
+char* gene2 = "aaagc";
+char* segments2[] = {
+    "aaa",
+    "aag",
+    "agc",
+    NULL
+};
+
+char* gene3 = "aaacaaagaaat";
+char* segments3[] = {
+    "aaac",
+    "aaag",
+    "aaat",
+    NULL
+};
+
+char* gene4 = "ttggctacgtatcgcacggt";
+char* segments4[] = {
+    "cgtatcgc",
+    "tcgcacgg",
+    "gtatcgca",
+    "tatcgcac",
+    "atcgcacg",
+    "ttggctac",
+    "ctacgtat",
+    "acgtatcg",
+    "ctacgtat",
+    "cgtatcgc",
+    "atcgcacg",
+    "ggctacgt",
+    "tacgtatc",
+    "tcgcacgg",
+    "ttggctac",
+    "ggctacgt",
+    "atcgcacg",
+    "tatcgcac",
+    "cgtatcgc",
+    "acgtatcg",
+    "gtatcgca",
+    "gtatcgca",
+    "cgcacggt",
+    "tatcgcac",
+    "ttggctac",
+    "atcgcacg",
+    "acgtatcg",
+    "gtatcgca",
+    "ttggctac",
+    "tggctacg",
+    NULL
+};
+
+char* gene5 = "gatcggcagctggtacggcg";
+char* segments5[] = {
+    "atcggcag",
+    "gtacggcg",
+    "gatcggca",
+    "cagctggt",
+    "tggtacgg",
+    "gatcggca",
+    "gatcggca",
+    "tcggcagc",
+    "ggtacggc",
+    "tggtacgg",
+    "tcggcagc",
+    "gcagctgg",
+    "gatcggca",
+    "gctggtac",
+    "gatcggca",
+    "ctggtacg",
+    "ggcagctg",
+    "tcggcagc",
+    "gtacggcg",
+    "gcagctgg",
+    "ggcagctg",
+    "tcggcagc",
+    "cagctggt",
+    "tggtacgg",
+    "cagctggt",
+    "gcagctgg",
+    "gctggtac",
+    "cggcagct",
+    "agctggta",
+    "ctggtacg",
+    NULL
+};
+
+char* gene6 = "ttggtgagccgtaagactcc";
+char* segments6[] = {
+    "cgtaagac",
+    "taagactc",
+    "gtgagccg",
+    "gagccgta",
+    "gccgtaag",
+    "tgagccgt",
+    "gccgtaag",
+    "cgtaagac",
+    "ttggtgag",
+    "agccgtaa",
+    "gccgtaag",
+    "aagactcc",
+    "ggtgagcc",
+    "ttggtgag",
+    "agccgtaa",
+    "gagccgta",
+    "aagactcc",
+    "ttggtgag",
+    "gtaagact",
+    "ccgtaaga",
+    "ttggtgag",
+    "gagccgta",
+    "ggtgagcc",
+    "gagccgta",
+    "gccgtaag",
+    "aagactcc",
+    "gtaagact",
+    "ccgtaaga",
+    "tgagccgt",
+    "ttggtgag",
+    NULL
+};
+
+char* gene7 = "gatcggcagctggtacggcg";
+char* segments7[] = {
+    "atcggcag",
+    "gtacggcg",
+    "gatcggca",
+    "cagctggt",
+    "tggtacgg",
+    "gatcggca",
+    "gatcggca",
+    "tcggcagc",
+    "ggtacggc",
+    "tggtacgg",
+    "tcggcagc",
+    "gcagctgg",
+    "gatcggca",
+    "gctggtac",
+    "gatcggca",
+    "ctggtacg",
+    "ggcagctg",
+    "tcggcagc",
+    "gtacggcg",
+    "gcagctgg",
+    "ggcagctg",
+    "tcggcagc",
+    "cagctggt",
+    "tggtacgg",
+    "cagctggt",
+    "gcagctgg",
+    "gctggtac",
+    "cggcagct",
+    "agctggta",
+    "ctggtacg",
+    NULL
+};
+
+char* gene8 = "ttggtgagccgtaagactcc";
+char* segments8[] = {
+    "cgtaagac",
+    "taagactc",
+    "gtgagccg",
+    "gagccgta",
+    "gccgtaag",
+    "tgagccgt",
+    "gccgtaag",
+    "cgtaagac",
+    "ttggtgag",
+    "agccgtaa",
+    "gccgtaag",
+    "aagactcc",
+    "ggtgagcc",
+    "ttggtgag",
+    "agccgtaa",
+    "gagccgta",
+    "aagactcc",
+    "ttggtgag",
+    "gtaagact",
+    "ccgtaaga",
+    "ttggtgag",
+    "gagccgta",
+    "ggtgagcc",
+    "gagccgta",
+    "gccgtaag",
+    "aagactcc",
+    "gtaagact",
+    "ccgtaaga",
+    "tgagccgt",
+    "ttggtgag",
+    NULL
+};
+
+
+static segments_t*
+createSegments (char* segments[])
+{
+    long i = 0;
+    segments_t* segmentsPtr = (segments_t*)malloc(sizeof(segments));
+
+    segmentsPtr->length = strlen(segments[0]);
+    segmentsPtr->contentsPtr = vector_alloc(1);
+
+    while (segments[i] != NULL) {
+        bool_t status = vector_pushBack(segmentsPtr->contentsPtr,
+                                        (void*)segments[i]);
+        assert(status);
+        i++;
+    }
+
+    segmentsPtr->minNum = vector_getSize(segmentsPtr->contentsPtr);
+
+    return segmentsPtr;
+}
+
+
+static void
+tester (char* gene, char* segments[])
+{
+    segments_t* segmentsPtr;
+    sequencer_t* sequencerPtr;
+
+    segmentsPtr = createSegments(segments);
+    sequencerPtr = sequencer_alloc(strlen(gene), segmentsPtr->length, segmentsPtr);
+
+    sequencer_run((void*)sequencerPtr);
+
+    printf("gene     = %s\n", gene);
+    printf("sequence = %s\n", sequencerPtr->sequence);
+    assert(strcmp(sequencerPtr->sequence, gene) == 0);
+
+    sequencer_free(sequencerPtr);
+}
+
+
+int
+main ()
+{
+    bool_t status = memory_init(1, 4, 2);
+    assert(status);
+    thread_startup(1);
+
+    puts("Starting...");
+
+    /* Simple test */
+    tester(gene1, segments1);
+
+    /* Simple test with aliasing segments */
+    tester(gene2, segments2);
+
+    /* Simple test with non-overlapping segments */
+    tester(gene3, segments3);
+
+    /* Complex tests */
+    tester(gene4, segments4);
+    tester(gene5, segments5);
+    tester(gene6, segments6);
+    tester(gene7, segments7);
+    tester(gene8, segments8);
+
+    puts("Passed all tests.");
+
+    return 0;
+}
+
+
+#endif /* TEST_SEQUENCER */
+
+
+/* =============================================================================
+ *
+ * End of sequencer.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/genome/sequencer.h stamp-grun/genome/sequencer.h
--- stamp-0.9.10/genome/sequencer.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/sequencer.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,9 @@
 #include "table.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct endInfoEntry endInfoEntry_t;
 typedef struct constructEntry constructEntry_t;
@@ -143,6 +146,9 @@
 void
 sequencer_free (sequencer_t* sequencerPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* SEQUENCER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/genome/table.h stamp-grun/genome/table.h
--- stamp-0.9.10/genome/table.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/genome/table.h	2017-03-20 15:19:45.000000000 +0000
@@ -77,6 +77,9 @@
 #include "list.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct table {
     list_t** buckets;
@@ -130,6 +133,10 @@
 
 #define TMTABLE_INSERT(t, h, d)         TMtable_insert(TM_ARG  t, h, d)
 
+#ifdef __cplusplus
+}
+#endif
+
 
 #endif /* TABLE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/CMakeLists.txt stamp-grun/intruder/CMakeLists.txt
--- stamp-0.9.10/intruder/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/CMakeLists.txt	2017-03-20 15:19:45.000000000 +0000
@@ -10,7 +10,7 @@
 	decoder.c 
 	detector.c 
 	dictionary.c 
-	intruder.c 
+	intruder.cpp 
 	packet.c 
 	preprocessor.c 
 	stream.c 
@@ -20,7 +20,7 @@
 	${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
 	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c 
+	${LIB_DIR}/thread.cpp 
 	${LIB_DIR}/vector.c)
 
 app(intruder ${sources})
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/decoder.c stamp-grun/intruder/decoder.c
--- stamp-0.9.10/intruder/decoder.c	2017-03-21 17:39:12.000000000 +0000
+++ stamp-grun/intruder/decoder.c	2017-03-21 18:21:18.000000000 +0000
@@ -92,6 +92,11 @@
 } decoded_t;
 
 
+MAP_T*
+decoder_getMap(decoder_t* decoderPtr) {
+  return decoderPtr->fragmentedMapPtr;
+}
+
 /* =============================================================================
  * decoder_alloc
  * =============================================================================
@@ -130,7 +135,7 @@
  * decoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 decoder_process (decoder_t* decoderPtr, char* bytes, long numByte)
 {
     bool_t status;
@@ -294,7 +299,7 @@
  * TMdecoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 TMdecoder_process (TM_ARGDECL  decoder_t* decoderPtr, char* bytes, long numByte)
 {
     bool_t status;
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/decoder.h stamp-grun/intruder/decoder.h
--- stamp-0.9.10/intruder/decoder.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/decoder.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,9 +72,14 @@
 #define DECODER_H 1
 
 
+#include "map.h"
 #include "error.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct decoder decoder_t;
 
 
@@ -98,7 +103,7 @@
  * decoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 decoder_process (decoder_t* decoderPtr, char* bytes, long numByte);
 
 
@@ -106,7 +111,7 @@
  * TMdecoder_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 TMdecoder_process (TM_ARGDECL  decoder_t* decoderPtr, char* bytes, long numByte);
 
 
@@ -127,10 +132,15 @@
 char*
 TMdecoder_getComplete (TM_ARGDECL  decoder_t* decoderPtr, long* decodedFlowIdPtr);
 
+MAP_T*
+decoder_getMap(decoder_t* decoderPtr);
 
 #define TMDECODER_PROCESS(d, b, n)      TMdecoder_process(TM_ARG  d, b, n)
 #define TMDECODER_GETCOMPLETE(d, f)     TMdecoder_getComplete(TM_ARG  d, f)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DECODER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/detector.c stamp-grun/intruder/detector.c
--- stamp-0.9.10/intruder/detector.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/detector.c	2017-03-20 15:19:45.000000000 +0000
@@ -170,7 +170,7 @@
  * detector_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 detector_process (detector_t* detectorPtr, char* str)
 {
     /*
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/detector.h stamp-grun/intruder/detector.h
--- stamp-0.9.10/intruder/detector.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/detector.h	2017-03-20 15:19:45.000000000 +0000
@@ -76,6 +76,10 @@
 #include "error.h"
 #include "preprocessor.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct detector detector_t;
 
 
@@ -123,7 +127,7 @@
  * detector_process
  * =============================================================================
  */
-error_t
+intruder_error_t
 detector_process (detector_t* detectorPtr, char* str);
 
 
@@ -132,6 +136,9 @@
 #define PDETECTOR_PROCESS(d, s)         detector_process(d, s)
 #define PDETECTOR_ADDPREPROCESSOR(d, s) detector_addPreprocessor(d, s)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DETECTOR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/dictionary.h stamp-grun/intruder/dictionary.h
--- stamp-0.9.10/intruder/dictionary.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/dictionary.h	2017-03-20 15:19:45.000000000 +0000
@@ -76,6 +76,10 @@
 #include "vector.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 
 typedef vector_t dictionary_t;
 
@@ -143,6 +147,9 @@
 #define PDICTIONARY_ALLOC()             Pdictionary_alloc()
 #define PDICTIONARY_FREE(d)             Pdictionary_free(d)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* DICTIONARY_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/error.h stamp-grun/intruder/error.h
--- stamp-0.9.10/intruder/error.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/error.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,8 +72,11 @@
 #ifndef ERROR_H
 #define ERROR_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-typedef enum error {
+typedef enum intruder_error {
     ERROR_NONE        = 0,
     ERROR_SHORT       = 1,
     ERROR_FLOWID      = 2,
@@ -83,8 +86,11 @@
     ERROR_INCOMPLETE  = 6,
     ERROR_SIGNATURE   = 7,
     NUM_ERROR
-} error_t;
+} intruder_error_t;
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ERROR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/intruder.c stamp-grun/intruder/intruder.c
--- stamp-0.9.10/intruder/intruder.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/intruder.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,375 +0,0 @@
-/* =============================================================================
- *
- * intruder.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "decoder.h"
-#include "detector.h"
-#include "dictionary.h"
-#include "packet.h"
-#include "stream.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-
-enum param_types {
-    PARAM_ATTACK = (unsigned char)'a',
-    PARAM_LENGTH = (unsigned char)'l',
-    PARAM_NUM    = (unsigned char)'n',
-    PARAM_SEED   = (unsigned char)'s',
-    PARAM_THREAD = (unsigned char)'t',
-};
-
-enum param_defaults {
-    PARAM_DEFAULT_ATTACK = 10,
-    PARAM_DEFAULT_LENGTH = 16,
-    PARAM_DEFAULT_NUM    = 1 << 20,
-    PARAM_DEFAULT_SEED   = 1,
-    PARAM_DEFAULT_THREAD = 1,
-};
-
-long global_params[256] = { /* 256 = ascii limit */
-    [PARAM_ATTACK] = PARAM_DEFAULT_ATTACK,
-    [PARAM_LENGTH] = PARAM_DEFAULT_LENGTH,
-    [PARAM_NUM]    = PARAM_DEFAULT_NUM,
-    [PARAM_SEED]   = PARAM_DEFAULT_SEED,
-    [PARAM_THREAD] = PARAM_DEFAULT_THREAD,
-};
-
-typedef struct arg {
-  /* input: */
-    stream_t* streamPtr;
-    decoder_t* decoderPtr;
-  /* output: */
-    vector_t** errorVectors;
-} arg_t;
-
-
-/* =============================================================================
- * displayUsage
- * =============================================================================
- */
-static void
-displayUsage (const char* appName)
-{
-    printf("Usage: %s [options]\n", appName);
-    puts("\nOptions:                            (defaults)\n");
-    printf("    a <UINT>   Percent [a]ttack     (%i)\n", PARAM_DEFAULT_ATTACK);
-    printf("    l <UINT>   Max data [l]ength    (%i)\n", PARAM_DEFAULT_LENGTH);
-    printf("    n <UINT>   [n]umber of flows    (%i)\n", PARAM_DEFAULT_NUM);
-    printf("    s <UINT>   Random [s]eed        (%i)\n", PARAM_DEFAULT_SEED);
-    printf("    t <UINT>   Number of [t]hreads  (%i)\n", PARAM_DEFAULT_THREAD);
-    exit(1);
-}
-
-
-/* =============================================================================
- * parseArgs
- * =============================================================================
- */
-static void
-parseArgs (long argc, char* const argv[])
-{
-    long i;
-    long opt;
-
-    opterr = 0;
-
-    while ((opt = getopt(argc, argv, "a:l:n:s:t:")) != -1) {
-        switch (opt) {
-            case 'a':
-            case 'l':
-            case 'n':
-            case 's':
-            case 't':
-                global_params[(unsigned char)opt] = atol(optarg);
-                break;
-            case '?':
-            default:
-                opterr++;
-                break;
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
-        opterr++;
-    }
-
-    if (opterr) {
-        displayUsage(argv[0]);
-    }
-}
-
-
-/* =============================================================================
- * processPackets
- * =============================================================================
- */
-void
-processPackets (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long threadId = thread_getId();
-
-    stream_t*   streamPtr    = ((arg_t*)argPtr)->streamPtr;
-    decoder_t*  decoderPtr   = ((arg_t*)argPtr)->decoderPtr;
-    vector_t**  errorVectors = ((arg_t*)argPtr)->errorVectors;
-
-    detector_t* detectorPtr = PDETECTOR_ALLOC();
-    assert(detectorPtr);
-    PDETECTOR_ADDPREPROCESSOR(detectorPtr, &preprocessor_toLower);
-
-    vector_t* errorVectorPtr = errorVectors[threadId];
-
-    while (1) {
-
-        char* bytes;
-        TM_BEGIN();
-        bytes = TMSTREAM_GETPACKET(streamPtr);
-        TM_END();
-        if (!bytes) {
-            break;
-        }
-
-        packet_t* packetPtr = (packet_t*)bytes;
-        long flowId = packetPtr->flowId;
-
-        error_t error;
-        TM_BEGIN();
-        error = TMDECODER_PROCESS(decoderPtr,
-                                  bytes,
-                                  (PACKET_HEADER_LENGTH + packetPtr->length));
-        TM_END();
-        if (error) {
-            /*
-             * Currently, stream_generate() does not create these errors.
-             */
-            assert(0);
-            bool_t status = PVECTOR_PUSHBACK(errorVectorPtr, (void*)flowId);
-            assert(status);
-        }
-
-        char* data;
-        long decodedFlowId;
-        TM_BEGIN();
-        data = TMDECODER_GETCOMPLETE(decoderPtr, &decodedFlowId);
-        TM_END();
-        if (data) {
-            error_t error = PDETECTOR_PROCESS(detectorPtr, data);
-            //P_FREE(data);
-            //TM_FREE(data);
-            if (error) {
-                bool_t status = PVECTOR_PUSHBACK(errorVectorPtr,
-                                                 (void*)decodedFlowId);
-                assert(status);
-            }
-        }
-
-    }
-
-    PDETECTOR_FREE(detectorPtr);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * main
- * =============================================================================
- */
-MAIN(argc, argv)
-{
-    GOTO_REAL();
-
-    /*
-     * Initialization
-     */
-
-    parseArgs(argc, (char** const)argv);
-    long numThread = global_params[PARAM_THREAD];
-    SIM_GET_NUM_CPU(numThread);
-    TM_STARTUP(numThread);
-    P_MEMORY_STARTUP(numThread);
-    thread_startup(numThread);
-
-    long percentAttack = global_params[PARAM_ATTACK];
-    long maxDataLength = global_params[PARAM_LENGTH];
-    long numFlow       = global_params[PARAM_NUM];
-    long randomSeed    = global_params[PARAM_SEED];
-    printf("Percent attack  = %li\n", percentAttack);
-    printf("Max data length = %li\n", maxDataLength);
-    printf("Num flow        = %li\n", numFlow);
-    printf("Random seed     = %li\n", randomSeed);
-
-    dictionary_t* dictionaryPtr = dictionary_alloc();
-    assert(dictionaryPtr);
-    stream_t* streamPtr = stream_alloc(percentAttack);
-    assert(streamPtr);
-    long numAttack = stream_generate(streamPtr,
-                                     dictionaryPtr,
-                                     numFlow,
-                                     randomSeed,
-                                     maxDataLength);
-    printf("Num attack      = %li\n", numAttack);
-
-    decoder_t* decoderPtr = decoder_alloc();
-    assert(decoderPtr);
-
-    vector_t** errorVectors = (vector_t**)malloc(numThread * sizeof(vector_t*));
-    assert(errorVectors);
-    long i;
-    for (i = 0; i < numThread; i++) {
-        vector_t* errorVectorPtr = vector_alloc(numFlow);
-        assert(errorVectorPtr);
-        errorVectors[i] = errorVectorPtr;
-    }
-
-    arg_t arg;
-    arg.streamPtr    = streamPtr;
-    arg.decoderPtr   = decoderPtr;
-    arg.errorVectors = errorVectors;
-
-    /*
-     * Run transactions
-     */
-
-    TIMER_T startTime;
-    TIMER_READ(startTime);
-    GOTO_SIM();
-    thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        processPackets((void*)&arg);
-    }
-    
-#else
-    thread_start(processPackets, (void*)&arg);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
-    TIMER_T stopTime;
-    TIMER_READ(stopTime);
-    printf("Elapsed time    = %f seconds\n", TIMER_DIFF_SECONDS(startTime, stopTime));
-    printf("STAMP time = %f\n", TIMER_DIFF_SECONDS(startTime, stopTime));
-
-    /*
-     * Check solution
-     */
-
-    long numFound = 0;
-    for (i = 0; i < numThread; i++) {
-        vector_t* errorVectorPtr = errorVectors[i];
-        long e;
-        long numError = vector_getSize(errorVectorPtr);
-        numFound += numError;
-        for (e = 0; e < numError; e++) {
-            long flowId = (long)vector_at(errorVectorPtr, e);
-            bool_t status = stream_isAttack(streamPtr, flowId);
-            assert(status);
-        }
-    }
-    printf("Num found       = %li\n", numFound);
-    assert(numFound == numAttack);
-
-    /*
-     * Clean up
-     */
-
-    for (i = 0; i < numThread; i++) {
-        vector_free(errorVectors[i]);
-    }
-    free(errorVectors);
-    decoder_free(decoderPtr);
-    stream_free(streamPtr);
-    dictionary_free(dictionaryPtr);
-
-    TM_SHUTDOWN();
-    P_MEMORY_SHUTDOWN();
-
-    GOTO_SIM();
-
-    thread_shutdown();
-
-    MAIN_RETURN(0);
-}
-
-
-/* =============================================================================
- *
- * End of intruder.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/intruder.cpp stamp-grun/intruder/intruder.cpp
--- stamp-0.9.10/intruder/intruder.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/intruder/intruder.cpp	2017-03-21 18:23:14.000000000 +0000
@@ -0,0 +1,516 @@
+/* =============================================================================
+ *
+ * intruder.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "decoder.h"
+#include "detector.h"
+#include "dictionary.h"
+#include "packet.h"
+#include "stream.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+#include "list.h"
+
+enum param_types {
+    PARAM_ATTACK = (unsigned char)'a',
+    PARAM_LENGTH = (unsigned char)'l',
+    PARAM_NUM    = (unsigned char)'n',
+    PARAM_SEED   = (unsigned char)'s',
+    PARAM_THREAD = (unsigned char)'t',
+};
+
+enum param_defaults {
+    PARAM_DEFAULT_ATTACK = 10,
+    PARAM_DEFAULT_LENGTH = 16,
+    PARAM_DEFAULT_NUM    = 1 << 20,
+    PARAM_DEFAULT_SEED   = 1,
+    PARAM_DEFAULT_THREAD = 1,
+};
+
+long global_params[256] = { /* 256 = ascii limit */
+//    [PARAM_ATTACK] = PARAM_DEFAULT_ATTACK,
+//    [PARAM_LENGTH] = PARAM_DEFAULT_LENGTH,
+//    [PARAM_NUM]    = PARAM_DEFAULT_NUM,
+//    [PARAM_SEED]   = PARAM_DEFAULT_SEED,
+//    [PARAM_THREAD] = PARAM_DEFAULT_THREAD,
+};
+
+typedef struct arg {
+  /* input: */
+    stream_t* streamPtr;
+    decoder_t* decoderPtr;
+  /* output: */
+    vector_t** errorVectors;
+} arg_t;
+
+
+/* =============================================================================
+ * displayUsage
+ * =============================================================================
+ */
+static void
+displayUsage (const char* appName)
+{
+    printf("Usage: %s [options]\n", appName);
+    puts("\nOptions:                            (defaults)\n");
+    printf("    a <UINT>   Percent [a]ttack     (%i)\n", PARAM_DEFAULT_ATTACK);
+    printf("    l <UINT>   Max data [l]ength    (%i)\n", PARAM_DEFAULT_LENGTH);
+    printf("    n <UINT>   [n]umber of flows    (%i)\n", PARAM_DEFAULT_NUM);
+    printf("    s <UINT>   Random [s]eed        (%i)\n", PARAM_DEFAULT_SEED);
+    printf("    t <UINT>   Number of [t]hreads  (%i)\n", PARAM_DEFAULT_THREAD);
+    exit(1);
+}
+
+
+/* =============================================================================
+ * parseArgs
+ * =============================================================================
+ */
+static void
+parseArgs (long argc, char* const argv[])
+{
+    long i;
+    long opt;
+
+    opterr = 0;
+    global_params[PARAM_ATTACK] = PARAM_DEFAULT_ATTACK;
+    global_params[PARAM_LENGTH] = PARAM_DEFAULT_LENGTH;
+    global_params[PARAM_NUM]    = PARAM_DEFAULT_NUM;
+    global_params[PARAM_SEED]   = PARAM_DEFAULT_SEED;
+    global_params[PARAM_THREAD] = PARAM_DEFAULT_THREAD;
+
+    while ((opt = getopt(argc, argv, "a:l:n:s:t:")) != -1) {
+        switch (opt) {
+            case 'a':
+            case 'l':
+            case 'n':
+            case 's':
+            case 't':
+                global_params[(unsigned char)opt] = atol(optarg);
+                break;
+            case '?':
+            default:
+                opterr++;
+                break;
+        }
+    }
+
+    for (i = optind; i < argc; i++) {
+        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
+        opterr++;
+    }
+
+    if (opterr) {
+        displayUsage(argv[0]);
+    }
+}
+
+static XTM_DECL_LOCKABLE(long, count);
+
+struct ProcessStream {
+    MAP_T*  fragmentedMapPtr;
+    detector_t* detectorPtr;
+    vector_t**  errorVectors;
+    decoder_t* decoderPtr;
+
+    void operator()(void* stuff, Galois::UserContext<void*>& ctx) {
+        char* bytes = (char*) stuff;
+        packet_t* packetPtr = (packet_t*)bytes;
+        long flowId = packetPtr->flowId;
+
+        intruder_error_t error;
+        error = decode_process(bytes, (PACKET_HEADER_LENGTH + packetPtr->length));
+        if (error) {
+            /*
+             * Currently, stream_generate() does not create these errors.
+             */
+            //assert(0);
+            bool_t status = PVECTOR_PUSHBACK(errorVectors[Galois::Runtime::LL::getTID()], (void*)flowId);
+            assert(status);
+        }
+    }
+
+    intruder_error_t decode_process(char* bytes, long numByte);
+    void detect_process(char* data, long decodedFlowId);
+};
+
+void ProcessStream::detect_process(char* data, long decodedFlowId) {
+    intruder_error_t error = PDETECTOR_PROCESS(detectorPtr, data);
+    if (error) {
+        long newcount = TM_SHARED_READ(count) + 1;
+        TM_SHARED_WRITE(count, newcount);
+        bool_t status = PVECTOR_PUSHBACK(errorVectors[Galois::Runtime::LL::getTID()],
+                                         (void*)decodedFlowId);
+        assert(status);
+    }
+
+    TM_FREE(data);
+}
+
+intruder_error_t
+ProcessStream::decode_process(char* bytes, long numByte)
+{
+    bool_t status;
+    /*
+     * Basic error checking
+     */
+
+    if (numByte < PACKET_HEADER_LENGTH) {
+        return ERROR_SHORT;
+    }
+
+    packet_t* packetPtr = (packet_t*)bytes;
+    long flowId      = packetPtr->flowId;
+    long fragmentId  = packetPtr->fragmentId;
+    long numFragment = packetPtr->numFragment;
+    long length      = packetPtr->length;
+
+    if (flowId < 0) {
+        return ERROR_FLOWID;
+    }
+
+    if ((fragmentId < 0) || (fragmentId >= numFragment)) {
+        return ERROR_FRAGMENTID;
+    }
+
+    if (length < 0) {
+        return ERROR_LENGTH;
+    }
+
+    /*
+     * Add to fragmented map for reassembling
+     */
+
+    if (numFragment > 1) {
+        //MAP_T* fragmentedMapPtr = decoderPtr->fragmentedMapPtr;
+        list_t* fragmentListPtr =
+            (list_t*)TMMAP_FIND(fragmentedMapPtr, (void*)flowId);
+
+        if (fragmentListPtr == NULL) {
+
+            fragmentListPtr = TMLIST_ALLOC(&packet_compareFragmentId);
+            assert(fragmentListPtr);
+            status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+            assert(status);
+            status = TMMAP_INSERT(fragmentedMapPtr,
+                                  (void*)flowId,
+                                  (void*)fragmentListPtr);
+            assert(status);
+
+        } else {
+
+            list_iter_t it;
+            TMLIST_ITER_RESET(&it, fragmentListPtr);
+            assert(TMLIST_ITER_HASNEXT(&it, fragmentListPtr));
+            packet_t* firstFragmentPtr =
+                (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+            long expectedNumFragment = firstFragmentPtr->numFragment;
+
+            if (numFragment != expectedNumFragment) {
+                status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
+                assert(status);
+                return ERROR_NUMFRAGMENT;
+            }
+
+            status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+            assert(status);
+
+            /*
+             * If we have all the fragments we can reassemble them
+             */
+
+            if (TMLIST_GETSIZE(fragmentListPtr) == numFragment) {
+                packet_t** fragments = (packet_t**) TM_MALLOC(sizeof(*fragments) * numFragment);
+                memset(fragments, 0, sizeof(*fragments) * numFragment);
+
+                long numByte = 0;
+                TMLIST_ITER_RESET(&it, fragmentListPtr);
+                while (TMLIST_ITER_HASNEXT(&it, fragmentListPtr)) {
+                    packet_t* fragmentPtr = (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+                    assert(fragmentPtr->flowId == flowId);
+                    assert(fragmentPtr->fragmentId >= 0);
+                    assert(fragmentPtr->fragmentId < numFragment);
+
+                    fragments[fragmentPtr->fragmentId] = fragmentPtr;
+                    numByte += fragmentPtr->length;
+                }
+
+                char* data = (char*)TM_MALLOC(numByte + 1);
+                assert(data);
+                data[numByte] = '\0';
+                char* dst = data;
+                for (int i = 0; i < numFragment; ++i) {
+                    packet_t* fragmentPtr = fragments[i];
+                    memcpy(dst, fragmentPtr->data, fragmentPtr->length);
+                    dst += fragmentPtr->length;
+                }
+                assert(dst == data + numByte);
+
+                TMLIST_FREE(fragmentListPtr);
+                status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
+                assert(status);
+
+                detect_process(data, flowId);
+            }
+
+        }
+
+    } else {
+
+        /*
+         * This is the only fragment, so it is ready
+         */
+
+        if (fragmentId != 0) {
+            return ERROR_FRAGMENTID;
+        }
+
+        char* data = (char*)TM_MALLOC(length + 1);
+        assert(data);
+        data[length] = '\0';
+        memcpy(data, packetPtr->data, length);
+
+#if 0
+        decoded_t* decodedPtr = (decoded_t*)TM_MALLOC(sizeof(decoded_t));
+        assert(decodedPtr);
+        decodedPtr->flowId = flowId;
+        decodedPtr->data = data;
+
+        queue_t* decodedQueuePtr = decoderPtr->decodedQueuePtr;
+        status = TMQUEUE_PUSH(decodedQueuePtr, (void*)decodedPtr);
+        assert(status);
+#endif
+        detect_process(data, flowId);
+    }
+
+    return ERROR_NONE;
+}
+
+/* =============================================================================
+ * processPackets
+ * =============================================================================
+ */
+void
+processPackets (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    stream_t*   streamPtr    = ((arg_t*)argPtr)->streamPtr;
+    decoder_t*  decoderPtr   = ((arg_t*)argPtr)->decoderPtr;
+    vector_t**  errorVectors = ((arg_t*)argPtr)->errorVectors;
+    
+    detector_t* detectorPtr = detector_alloc();
+    assert(detectorPtr);
+    detector_addPreprocessor(detectorPtr, &preprocessor_toLower);
+
+    std::deque<void*> work;
+    queue_t* queuePtr = stream_getQueue(streamPtr);
+    void *ptr;
+    while ((ptr = queue_pop(queuePtr))) {
+        work.push_back(ptr);
+    }
+    ProcessStream ps = { decoder_getMap(decoderPtr), detectorPtr, errorVectors, decoderPtr };
+    Galois::for_each(work.begin(), work.end(), ps, Galois::wl<Galois::WorkList::dChunkedFIFO<512> >());
+
+    detector_free(detectorPtr);
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * main
+ * =============================================================================
+ */
+MAIN(argc, argv)
+{
+    GOTO_REAL();
+
+    /*
+     * Initialization
+     */
+
+    parseArgs(argc, (char** const)argv);
+    long numThread = global_params[PARAM_THREAD];
+    SIM_GET_NUM_CPU(numThread);
+    TM_STARTUP(numThread);
+    P_MEMORY_STARTUP(numThread);
+    thread_startup(numThread);
+
+    long percentAttack = global_params[PARAM_ATTACK];
+    long maxDataLength = global_params[PARAM_LENGTH];
+    long numFlow       = global_params[PARAM_NUM];
+    long randomSeed    = global_params[PARAM_SEED];
+    printf("Percent attack  = %li\n", percentAttack);
+    printf("Max data length = %li\n", maxDataLength);
+    printf("Num flow        = %li\n", numFlow);
+    printf("Random seed     = %li\n", randomSeed);
+
+    dictionary_t* dictionaryPtr = dictionary_alloc();
+    assert(dictionaryPtr);
+    stream_t* streamPtr = stream_alloc(percentAttack);
+    assert(streamPtr);
+    long numAttack = stream_generate(streamPtr,
+                                     dictionaryPtr,
+                                     numFlow,
+                                     randomSeed,
+                                     maxDataLength);
+    printf("Num attack      = %li\n", numAttack);
+
+    decoder_t* decoderPtr = decoder_alloc();
+    assert(decoderPtr);
+
+    vector_t** errorVectors = (vector_t**)malloc(numThread * sizeof(vector_t*));
+    assert(errorVectors);
+    long i;
+    for (i = 0; i < numThread; i++) {
+        vector_t* errorVectorPtr = vector_alloc(numFlow);
+        assert(errorVectorPtr);
+        errorVectors[i] = errorVectorPtr;
+    }
+
+    arg_t arg;
+    arg.streamPtr    = streamPtr;
+    arg.decoderPtr   = decoderPtr;
+    arg.errorVectors = errorVectors;
+
+    /*
+     * Run transactions
+     */
+
+    TIMER_T startTime;
+    TIMER_READ(startTime);
+    GOTO_SIM();
+    thread_begin_timing();
+    XTM_LOCKABLE_INIT(count);
+    processPackets((void*)&arg);
+    thread_end_timing();
+    GOTO_REAL();
+    TIMER_T stopTime;
+    TIMER_READ(stopTime);
+    printf("Elapsed time    = %f seconds\n", TIMER_DIFF_SECONDS(startTime, stopTime));
+    printf("STAMP time = %f\n", TIMER_DIFF_SECONDS(startTime, stopTime));
+
+    /*
+     * Check solution
+     */
+
+    long numFound = 0;
+    for (i = 0; i < numThread; i++) {
+        vector_t* errorVectorPtr = errorVectors[i];
+        long e;
+        long numError = vector_getSize(errorVectorPtr);
+        numFound += numError;
+        for (e = 0; e < numError; e++) {
+            long flowId = (long)vector_at(errorVectorPtr, e);
+            bool_t status = stream_isAttack(streamPtr, flowId);
+            assert(status);
+        }
+    }
+    printf("Num found       = %li\n", numFound);
+    printf("count           = %li\n", XTM_LOCKABLE_VALUE(count));
+    //assert(numFound == numAttack);
+    assert(XTM_LOCKABLE_VALUE(count) == numAttack);
+
+    /*
+     * Clean up
+     */
+
+    for (i = 0; i < numThread; i++) {
+        vector_free(errorVectors[i]);
+    }
+    free(errorVectors);
+    decoder_free(decoderPtr);
+    stream_free(streamPtr);
+    dictionary_free(dictionaryPtr);
+
+    TM_SHUTDOWN();
+    P_MEMORY_SHUTDOWN();
+
+    GOTO_SIM();
+
+    thread_shutdown();
+
+    MAIN_RETURN(0);
+}
+
+
+/* =============================================================================
+ *
+ * End of intruder.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/packet.h stamp-grun/intruder/packet.h
--- stamp-0.9.10/intruder/packet.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/packet.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef PACKET_H
 #define PACKET_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct packet {
     long flowId;
@@ -100,6 +103,9 @@
 long
 packet_compareFragmentId (const void* aPtr, const void* bPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* PACKET_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/preprocessor.h stamp-grun/intruder/preprocessor.h
--- stamp-0.9.10/intruder/preprocessor.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/preprocessor.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef PREPROCESSOR_H
 #define PREPROCESSOR_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * All preprocessors should update in place
  */
@@ -95,6 +99,9 @@
 void
 preprocessor_toLower (char* str);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* PREPROCESSOR_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/stream.c stamp-grun/intruder/stream.c
--- stamp-0.9.10/intruder/stream.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/stream.c	2017-03-20 15:19:45.000000000 +0000
@@ -252,7 +252,7 @@
             char* str2 = (char*)malloc((length + 1) * sizeof(char));
             assert(str2);
             strcpy(str2, str);
-            error_t error = detector_process(detectorPtr, str2); /* updates in-place */
+            intruder_error_t error = detector_process(detectorPtr, str2); /* updates in-place */
             if (error == ERROR_SIGNATURE) {
                 bool_t status = MAP_INSERT(attackMapPtr,
                                            (void*)f,
@@ -296,6 +296,11 @@
     return (char*)TMQUEUE_POP(streamPtr->packetQueuePtr);
 }
 
+queue_t*
+stream_getQueue(stream_t* streamPtr)
+{
+    return streamPtr->packetQueuePtr;
+}
 
 /* =============================================================================
  * stream_isAttack
diff -x .git -x inputs -Naur stamp-0.9.10/intruder/stream.h stamp-grun/intruder/stream.h
--- stamp-0.9.10/intruder/stream.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/intruder/stream.h	2017-03-20 15:19:45.000000000 +0000
@@ -73,8 +73,13 @@
 #define STREAM_H 1
 
 #include "dictionary.h"
+#include "queue.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct stream stream_t;
 
 
@@ -116,6 +121,9 @@
 stream_getPacket (stream_t* streamPtr);
 
 
+queue_t*
+stream_getQueue (stream_t* streamPtr);
+
 /* =============================================================================
  * TMstream_getPacket
  * -- If none, returns NULL
@@ -135,6 +143,10 @@
 
 #define TMSTREAM_GETPACKET(s)           TMstream_getPacket(TM_ARG  s)
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* STREAM_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/CMakeLists.txt stamp-grun/kmeans/CMakeLists.txt
--- stamp-0.9.10/kmeans/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/CMakeLists.txt	2017-03-21 18:23:58.000000000 +0000
@@ -10,10 +10,10 @@
 	cluster.c
 	common.c
 	kmeans.c
-	normal.c 
+	normal.cpp
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c)
+	${LIB_DIR}/thread.cpp)
 
 app(kmeans ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/cluster.h stamp-grun/kmeans/cluster.h
--- stamp-0.9.10/kmeans/cluster.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/cluster.h	2017-03-20 15:19:45.000000000 +0000
@@ -67,6 +67,9 @@
 #ifndef CLUSTER_H
 #define CLUSTER_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /* =============================================================================
  * cluster_exec
@@ -87,6 +90,9 @@
     int*     cluster_assign       /* out: [numObjects] */
 );
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* CLUSTER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/common.h stamp-grun/kmeans/common.h
--- stamp-0.9.10/kmeans/common.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/common.h	2017-03-20 15:19:45.000000000 +0000
@@ -67,6 +67,9 @@
 #ifndef COMMON_H
 #define COMMON_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #ifndef FLT_MAX
 #  define FLT_MAX 3.40282347e+38
@@ -93,6 +96,10 @@
                          int     npts);
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* COMMON_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/kmeans.c stamp-grun/kmeans/kmeans.c
--- stamp-0.9.10/kmeans/kmeans.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/kmeans.c	2017-03-21 17:59:27.000000000 +0000
@@ -383,7 +383,7 @@
     }
 #endif
 
-#if 1
+#if 0
     {
       float sum = 0.0;
       for (i = 0; i < numObjects; i++) {
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.c stamp-grun/kmeans/normal.c
--- stamp-0.9.10/kmeans/normal.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/normal.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,339 +0,0 @@
-/* =============================================================================
- *
- * normal.c
- * -- Implementation of normal k-means clustering algorithm
- *
- * =============================================================================
- *
- * Author:
- *
- * Wei-keng Liao
- * ECE Department, Northwestern University
- * email: wkliao@ece.northwestern.edu
- *
- *
- * Edited by:
- *
- * Jay Pisharath
- * Northwestern University.
- *
- * Chi Cao Minh
- * Stanford University
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <float.h>
-#include <math.h>
-#include "common.h"
-#include "normal.h"
-#include "random.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-#include "util.h"
-
-double global_time = 0.0;
-
-typedef struct NewCentersLen {
-  XTM_DECL_LOCKABLE(long, value);
-} NewCentersLen;
-
-typedef struct NewCenters {
-  XTM_DECL_LOCKABLE(float, value1);
-} NewCenters;
-
-typedef struct args {
-    float** feature;
-    int     nfeatures;
-    int     npoints;
-    int     nclusters;
-    int*    membership;
-    float** clusters;
-    NewCentersLen**   new_centers_len;
-    NewCenters** new_centers;
-} args_t;
-
-XTM_DECL_LOCKABLE(float, global_delta);
-XTM_DECL_LOCKABLE(long, global_i); /* index into task queue */
-
-#define CHUNK 3
-
-
-/* =============================================================================
- * work
- * =============================================================================
- */
-static void
-work (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    args_t* args = (args_t*)argPtr;
-    float** feature         = args->feature;
-    int     nfeatures       = args->nfeatures;
-    int     npoints         = args->npoints;
-    int     nclusters       = args->nclusters;
-    int*    membership      = args->membership;
-    float** clusters        = args->clusters;
-    NewCentersLen**   new_centers_len = args->new_centers_len;
-    NewCenters** new_centers     = args->new_centers;
-    float delta = 0.0;
-    int index;
-    int i;
-    int j;
-    long start;
-    int stop;
-    int myId;
-
-    myId = thread_getId();
-
-    start = myId * CHUNK;
-
-    while (start < npoints) {
-        stop = (((start + CHUNK) < npoints) ? (start + CHUNK) : npoints);
-        for (i = start; i < stop; i++) {
-
-            index = common_findNearestPoint(feature[i],
-                                            nfeatures,
-                                            clusters,
-                                            nclusters);
-            /*
-             * If membership changes, increase delta by 1.
-             * membership[i] cannot be changed by other threads
-             */
-            if (membership[i] != index) {
-                delta += 1.0;
-            }
-
-            /* Assign the membership to object i */
-            /* membership[i] can't be changed by other thread */
-            membership[i] = index;
-
-            /* Update new cluster centers : sum of objects located within */
-            TM_BEGIN();
-            TM_SHARED_WRITE(new_centers_len[index]->value,
-                            TM_SHARED_READ(new_centers_len[index]->value) + 1);
-            for (j = 0; j < nfeatures; j++) {
-                TM_SHARED_WRITE_F(
-                    new_centers[index][j].value1,
-                    (TM_SHARED_READ_F(new_centers[index][j].value1) + feature[i][j])
-                );
-            }
-            TM_END();
-        }
-
-        /* Update task queue */
-        if (start + CHUNK < npoints) {
-            TM_BEGIN();
-            start = TM_SHARED_READ(global_i);
-            TM_SHARED_WRITE(global_i, (start + CHUNK));
-            TM_END();
-        } else {
-            break;
-        }
-    }
-
-    TM_BEGIN();
-    TM_SHARED_WRITE_F(global_delta, TM_SHARED_READ_F(global_delta) + delta);
-    TM_END();
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * normal_exec
- * =============================================================================
- */
-float**
-normal_exec (int       nthreads,
-             float**   feature,    /* in: [npoints][nfeatures] */
-             int       nfeatures,
-             int       npoints,
-             int       nclusters,
-             float     threshold,
-             int*      membership,
-             random_t* randomPtr) /* out: [npoints] */
-{
-    int i;
-    int j;
-    int loop = 0;
-    NewCentersLen** new_centers_len; /* [nclusters]: no. of points in each cluster */
-    float delta;
-    float** clusters;      /* out: [nclusters][nfeatures] */
-    NewCenters** new_centers;   /* [nclusters][nfeatures] */
-    void* alloc_memory = NULL;
-    args_t args;
-    TIMER_T start;
-    TIMER_T stop;
-
-    /* Allocate space for returning variable clusters[] */
-    clusters = (float**)malloc(nclusters * sizeof(*clusters));
-    assert(clusters);
-    clusters[0] = (float*)malloc(nclusters * nfeatures * sizeof(**clusters));
-    assert(clusters[0]);
-    for (i = 1; i < nclusters; i++) {
-        clusters[i] = clusters[i-1] + nfeatures;
-    }
-
-    /* Randomly pick cluster centers */
-    for (i = 0; i < nclusters; i++) {
-        int n = (int)(random_generate(randomPtr) % npoints);
-        for (j = 0; j < nfeatures; j++) {
-            clusters[i][j] = feature[n][j];
-        }
-    }
-
-    for (i = 0; i < npoints; i++) {
-        membership[i] = -1;
-    }
-
-    /*
-     * Need to initialize new_centers_len and new_centers[0] to all 0.
-     * Allocate clusters on different cache lines to reduce false sharing.
-     */
-    {
-        int cluster_size = sizeof(NewCentersLen) + sizeof(NewCenters) * nfeatures;
-        const int cacheLineSize = 32;
-        cluster_size += (cacheLineSize-1) - ((cluster_size-1) % cacheLineSize);
-        alloc_memory = calloc(nclusters, cluster_size);
-        new_centers_len = (NewCentersLen**) malloc(nclusters * sizeof(long*));
-        new_centers = (NewCenters**) malloc(nclusters * sizeof(float*));
-        assert(alloc_memory && new_centers && new_centers_len);
-        for (i = 0; i < nclusters; i++) {
-            new_centers_len[i] = (NewCentersLen*)((char*)alloc_memory + cluster_size * i);
-            new_centers[i] = (NewCenters*)((char*)alloc_memory + cluster_size * i + sizeof(NewCentersLen));
-        }
-    }
-
-    TIMER_READ(start);
-
-    GOTO_SIM();
-    thread_begin_timing();
-
-    do {
-        delta = 0.0;
-
-        args.feature         = feature;
-        args.nfeatures       = nfeatures;
-        args.npoints         = npoints;
-        args.nclusters       = nclusters;
-        args.membership      = membership;
-        args.clusters        = clusters;
-        args.new_centers_len = new_centers_len;
-        args.new_centers     = new_centers;
-
-        XTM_LOCKABLE_VALUE(global_i) = nthreads * CHUNK;
-        XTM_LOCKABLE_INIT(global_i);
-        XTM_LOCKABLE_VALUE(global_delta) = delta;
-        XTM_LOCKABLE_INIT(global_delta);
-
-#ifdef OTM
-#pragma omp parallel
-        {
-            work(&args);
-        }
-#else
-        thread_start(work, &args);
-#endif
-
-        delta = XTM_LOCKABLE_VALUE(global_delta);
-
-        /* Replace old cluster centers with new_centers */
-        for (i = 0; i < nclusters; i++) {
-            for (j = 0; j < nfeatures; j++) {
-                if (new_centers_len[i] > 0) {
-                    clusters[i][j] = XTM_LOCKABLE_VALUE(new_centers[i][j].value1) / XTM_LOCKABLE_VALUE(new_centers_len[i]->value);
-                }
-                XTM_LOCKABLE_VALUE(new_centers[i][j].value1) = 0.0;   /* set back to 0 */
-            }
-            XTM_LOCKABLE_VALUE(new_centers_len[i]->value) = 0;   /* set back to 0 */
-        }
-
-        delta /= npoints;
-
-    } while ((delta > threshold) && (loop++ < 500));
-
-    thread_end_timing();
-    GOTO_REAL();
-
-    TIMER_READ(stop);
-    global_time += TIMER_DIFF_SECONDS(start, stop);
-
-    free(alloc_memory);
-    free(new_centers);
-    free(new_centers_len);
-
-    return clusters;
-}
-
-
-/* =============================================================================
- *
- * End of normal.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.cpp stamp-grun/kmeans/normal.cpp
--- stamp-0.9.10/kmeans/normal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/kmeans/normal.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,351 @@
+/* =============================================================================
+ *
+ * normal.c
+ * -- Implementation of normal k-means clustering algorithm
+ *
+ * =============================================================================
+ *
+ * Author:
+ *
+ * Wei-keng Liao
+ * ECE Department, Northwestern University
+ * email: wkliao@ece.northwestern.edu
+ *
+ *
+ * Edited by:
+ *
+ * Jay Pisharath
+ * Northwestern University.
+ *
+ * Chi Cao Minh
+ * Stanford University
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include <boost/iterator/counting_iterator.hpp>
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+#include "common.h"
+#include "normal.h"
+#include "random.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+#include "util.h"
+
+double global_time = 0.0;
+
+struct NewCentersLen {
+  XTM_DECL_LOCKABLE(long, value);
+};
+
+struct NewCenters {
+  XTM_DECL_LOCKABLE(float, value);
+};
+
+typedef struct args {
+    float** feature;
+    int     nfeatures;
+    int     npoints;
+    int     nclusters;
+    int*    membership;
+    float** clusters;
+    NewCentersLen**   new_centers_len;
+    NewCenters** new_centers;
+} args_t;
+
+float global_delta;
+long global_i; /* index into task queue */
+
+#define CHUNK 3
+
+
+/* =============================================================================
+ * work
+ * =============================================================================
+ */
+struct Fn1 {
+    args_t* args;
+    Galois::GAccumulator<float>& accum;
+
+
+    void operator()(long i, Galois::UserContext<long>& ctx) {
+        TM_THREAD_ENTER();
+        int     npoints         = args->npoints;
+        int phase = i < npoints ? 0 : 1;
+        switch (phase) {
+            case 0: findIndex(i, ctx); break;
+            case 1: updateCenters(i - npoints); break;
+            default: abort();
+        }
+    }
+
+    void findIndex(long i, Galois::UserContext<long>& ctx) {
+        float** feature         = args->feature;
+        int     nfeatures       = args->nfeatures;
+        int     npoints         = args->npoints;
+        int     nclusters       = args->nclusters;
+        int*    membership      = args->membership;
+        float** clusters        = args->clusters;
+        NewCentersLen**   new_centers_len = args->new_centers_len;
+        NewCenters** new_centers     = args->new_centers;
+        float delta = 0.0;
+        int index;
+        int j;
+
+        index = common_findNearestPoint(feature[i],
+                                        nfeatures,
+                                        clusters,
+                                        nclusters);
+
+        /*
+         * If membership changes, increase delta by 1.
+         * membership[i] cannot be changed by other threads
+         */
+        if (membership[i] != index) {
+            delta += 1.0;
+        }
+
+        accum.update(delta);
+
+        /* Assign the membership to object i */
+        /* membership[i] can't be changed by other thread */
+        membership[i] = index;
+        ctx.push(i + npoints);
+    }
+
+    void updateCenters(long i) {
+        float** feature         = args->feature;
+        int     nfeatures       = args->nfeatures;
+        int     npoints         = args->npoints;
+        int     nclusters       = args->nclusters;
+        int*    membership      = args->membership;
+        float** clusters        = args->clusters;
+        NewCentersLen**   new_centers_len = args->new_centers_len;
+        NewCenters** new_centers     = args->new_centers;
+        float delta = 0.0;
+        int index;
+        int j;
+
+        index = membership[i];
+        /* Update new cluster centers : sum of objects located within */
+        TM_BEGIN();
+        TM_SHARED_WRITE(new_centers_len[index]->value,
+                        TM_SHARED_READ(new_centers_len[index]->value) + 1);
+        for (j = 0; j < nfeatures; j++) {
+            TM_SHARED_WRITE_F(
+                new_centers[index][j].value,
+                (TM_SHARED_READ_F(new_centers[index][j].value) + feature[i][j])
+            );
+        }
+        TM_END();
+    }
+};
+
+static void
+work (void* argPtr)
+{
+  args_t* args = (args_t*)argPtr;
+  Galois::GAccumulator<float> accum;
+
+  Fn1 fn1 = { args, accum };
+
+  int     npoints         = args->npoints;
+
+  Galois::for_each(
+      boost::counting_iterator<long>(0),
+      boost::counting_iterator<long>(npoints),
+      fn1, Galois::wl<Galois::WorkList::LocalQueue<>::with_local<Galois::WorkList::GFIFO<> >::type >());
+  global_delta += accum.reduce();
+}
+
+
+/* =============================================================================
+ * normal_exec
+ * =============================================================================
+ */
+float**
+normal_exec (int       nthreads,
+             float**   feature,    /* in: [npoints][nfeatures] */
+             int       nfeatures,
+             int       npoints,
+             int       nclusters,
+             float     threshold,
+             int*      membership,
+             random_t* randomPtr) /* out: [npoints] */
+{
+    int i;
+    int j;
+    int loop = 0;
+    NewCentersLen** new_centers_len; /* [nclusters]: no. of points in each cluster */
+    float delta;
+    float** clusters;      /* out: [nclusters][nfeatures] */
+    NewCenters** new_centers;   /* [nclusters][nfeatures] */
+    void* alloc_memory = NULL;
+    args_t args;
+    TIMER_T start;
+    TIMER_T stop;
+
+    /* Allocate space for returning variable clusters[] */
+    clusters = (float**)malloc(nclusters * sizeof(*clusters));
+    assert(clusters);
+    clusters[0] = (float*)malloc(nclusters * nfeatures * sizeof(**clusters));
+    assert(clusters[0]);
+    for (i = 1; i < nclusters; i++) {
+        clusters[i] = clusters[i-1] + nfeatures;
+    }
+
+    /* Randomly pick cluster centers */
+    for (i = 0; i < nclusters; i++) {
+        int n = (int)(random_generate(randomPtr) % npoints);
+        for (j = 0; j < nfeatures; j++) {
+            clusters[i][j] = feature[n][j];
+        }
+    }
+
+    for (i = 0; i < npoints; i++) {
+        membership[i] = -1;
+    }
+
+    /*
+     * Need to initialize new_centers_len and new_centers[0] to all 0.
+     * Allocate clusters on different cache lines to reduce false sharing.
+     */
+    {
+        int cluster_size = sizeof(NewCentersLen) + sizeof(NewCenters) * nfeatures;
+        const int cacheLineSize = 32;
+        cluster_size += (cacheLineSize-1) - ((cluster_size-1) % cacheLineSize);
+        alloc_memory = calloc(nclusters, cluster_size);
+        new_centers_len = (NewCentersLen**) malloc(nclusters * sizeof(long*));
+        new_centers = (NewCenters**) malloc(nclusters * sizeof(float*));
+        assert(alloc_memory && new_centers && new_centers_len);
+        for (i = 0; i < nclusters; i++) {
+            new_centers_len[i] = (NewCentersLen*)((char*)alloc_memory + cluster_size * i);
+            new_centers[i] = (NewCenters*)((char*)alloc_memory + cluster_size * i + sizeof(NewCentersLen));
+        }
+    }
+
+
+    GOTO_SIM();
+    thread_begin_timing();
+    TIMER_READ(start);
+
+    do {
+        delta = 0.0;
+
+        args.feature         = feature;
+        args.nfeatures       = nfeatures;
+        args.npoints         = npoints;
+        args.nclusters       = nclusters;
+        args.membership      = membership;
+        args.clusters        = clusters;
+        args.new_centers_len = new_centers_len;
+        args.new_centers     = new_centers;
+
+        global_i = nthreads * CHUNK;
+        global_delta = delta;
+
+        work(&args);
+
+        delta = global_delta;
+
+        /* Replace old cluster centers with new_centers */
+        for (i = 0; i < nclusters; i++) {
+            for (j = 0; j < nfeatures; j++) {
+                if (new_centers_len[i] > 0) {
+                    clusters[i][j] = XTM_LOCKABLE_VALUE(new_centers[i][j].value) / XTM_LOCKABLE_VALUE(new_centers_len[i]->value);
+                }
+                XTM_LOCKABLE_VALUE(new_centers[i][j].value) = 0.0;   /* set back to 0 */
+            }
+            XTM_LOCKABLE_VALUE(new_centers_len[i]->value) = 0;   /* set back to 0 */
+        }
+
+        delta /= npoints;
+
+    } while ((delta > threshold) && (loop++ < 500));
+
+    TIMER_READ(stop);
+    thread_end_timing();
+    GOTO_REAL();
+
+    global_time += TIMER_DIFF_SECONDS(start, stop);
+
+    free(alloc_memory);
+    free(new_centers);
+    free(new_centers_len);
+
+    return clusters;
+}
+
+
+/* =============================================================================
+ *
+ * End of normal.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/normal.h stamp-grun/kmeans/normal.h
--- stamp-0.9.10/kmeans/normal.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/normal.h	2017-03-20 15:19:45.000000000 +0000
@@ -71,6 +71,9 @@
 
 #include "random.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 extern double global_parallelTime;
 
@@ -89,6 +92,9 @@
              int*      membership,
              random_t* randomPtr); /* out: [npoints] */
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* NORMAL_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/kmeans/util.h stamp-grun/kmeans/util.h
--- stamp-0.9.10/kmeans/util.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/kmeans/util.h	2017-03-20 15:19:45.000000000 +0000
@@ -66,9 +66,15 @@
 #ifndef UTIL_H
 #define UTIL_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #define SQR(x) ((x)*(x))
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* UTIL_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/CMakeLists.txt stamp-grun/labyrinth/CMakeLists.txt
--- stamp-0.9.10/labyrinth/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/CMakeLists.txt	2017-03-20 15:19:45.000000000 +0000
@@ -8,20 +8,19 @@
 
 set(sources
 	coordinate.c 
-	grid.c 
+	grid.c
 	labyrinth.c 
 	maze.c 
-	router.c 
+	router.cpp 
 	${LIB_DIR}/list.c 
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/pair.c 
 	${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c
+	${LIB_DIR}/thread.cpp
 	${LIB_DIR}/vector.c)
 
 app(labyrinth ${sources})
-target_link_libraries(labyrinth m)
 
 # ==============================================================================
 #
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/coordinate.h stamp-grun/labyrinth/coordinate.h
--- stamp-0.9.10/labyrinth/coordinate.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/coordinate.h	2017-03-20 15:19:45.000000000 +0000
@@ -76,6 +76,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct coordinate {
     long x;
     long y;
@@ -123,6 +127,9 @@
 bool_t
 coordinate_areAdjacent (coordinate_t* aPtr, coordinate_t* bPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COORDINATE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/grid.h stamp-grun/labyrinth/grid.h
--- stamp-0.9.10/labyrinth/grid.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/grid.h	2017-03-20 15:19:45.000000000 +0000
@@ -76,6 +76,10 @@
 #include "types.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct grid_point {
     XTM_DECL_LOCKABLE(long, value);
 } grid_point;
@@ -221,6 +225,9 @@
 
 #define TMGRID_ADDPATH(g, p)            TMgrid_addPath(TM_ARG  g, p)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* GRID_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/labyrinth.c stamp-grun/labyrinth/labyrinth.c
--- stamp-0.9.10/labyrinth/labyrinth.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/labyrinth.c	2017-03-20 15:19:45.000000000 +0000
@@ -216,21 +216,16 @@
      */
     router_solve_arg_t routerArg = {routerPtr, mazePtr, pathVectorListPtr};
     TIMER_T startTime;
-    TIMER_READ(startTime);
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        router_solve((void *)&routerArg);
-    }
-#else
-    thread_start(router_solve, (void*)&routerArg);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
+    TIMER_READ(startTime);
+
+    router_solve((void *)&routerArg);
+    
     TIMER_T stopTime;
     TIMER_READ(stopTime);
+    thread_end_timing();
+    GOTO_REAL();
 
     long numPathRouted = 0;
     list_iter_t it;
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/maze.h stamp-grun/labyrinth/maze.h
--- stamp-0.9.10/labyrinth/maze.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/maze.h	2017-03-20 15:19:45.000000000 +0000
@@ -81,6 +81,10 @@
 #include "types.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct maze {
     grid_t* gridPtr;
     queue_t* workQueuePtr;   /* contains source/destination pairs to route */
@@ -122,6 +126,9 @@
 bool_t
 maze_checkPaths (maze_t* mazePtr, list_t* pathListPtr, bool_t doPrintPaths);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MAZE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.c stamp-grun/labyrinth/router.c
--- stamp-0.9.10/labyrinth/router.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/router.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,446 +0,0 @@
-/* =============================================================================
- *
- * router.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include "coordinate.h"
-#include "grid.h"
-#include "queue.h"
-#include "router.h"
-#include "tm.h"
-#include "vector.h"
-
-
-typedef enum momentum {
-    MOMENTUM_ZERO = 0,
-    MOMENTUM_POSX = 1,
-    MOMENTUM_POSY = 2,
-    MOMENTUM_POSZ = 3,
-    MOMENTUM_NEGX = 4,
-    MOMENTUM_NEGY = 5,
-    MOMENTUM_NEGZ = 6
-} momentum_t;
-
-typedef struct point {
-    long x;
-    long y;
-    long z;
-    long value;
-    momentum_t momentum;
-} point_t;
-
-point_t MOVE_POSX = { 1,  0,  0,  0, MOMENTUM_POSX};
-point_t MOVE_POSY = { 0,  1,  0,  0, MOMENTUM_POSY};
-point_t MOVE_POSZ = { 0,  0,  1,  0, MOMENTUM_POSZ};
-point_t MOVE_NEGX = {-1,  0,  0,  0, MOMENTUM_NEGX};
-point_t MOVE_NEGY = { 0, -1,  0,  0, MOMENTUM_NEGY};
-point_t MOVE_NEGZ = { 0,  0, -1,  0, MOMENTUM_NEGZ};
-
-
-/* =============================================================================
- * router_alloc
- * =============================================================================
- */
-router_t*
-router_alloc (long xCost, long yCost, long zCost, long bendCost)
-{
-    router_t* routerPtr;
-
-    routerPtr = (router_t*)malloc(sizeof(router_t));
-    if (routerPtr) {
-        routerPtr->xCost = xCost;
-        routerPtr->yCost = yCost;
-        routerPtr->zCost = zCost;
-        routerPtr->bendCost = bendCost;
-    }
-
-    return routerPtr;
-}
-
-
-/* =============================================================================
- * router_free
- * =============================================================================
- */
-void
-router_free (router_t* routerPtr)
-{
-    free(routerPtr);
-}
-
-
-/* =============================================================================
- * PexpandToNeighbor
- * =============================================================================
- */
-static void
-PexpandToNeighbor (grid_t* myGridPtr,
-                   long x, long y, long z, long value, queue_t* queuePtr)
-{
-    if (grid_isPointValid(myGridPtr, x, y, z)) {
-        long* neighborGridPointPtr = grid_getPointRef(myGridPtr, x, y, z);
-        long neighborValue = *neighborGridPointPtr;
-        if (neighborValue == GRID_POINT_EMPTY) {
-            (*neighborGridPointPtr) = value;
-            PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
-        } else if (neighborValue != GRID_POINT_FULL) {
-            /* We have expanded here before... is this new path better? */
-            if (value < neighborValue) {
-                (*neighborGridPointPtr) = value;
-                PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
-            }
-        }
-    }
-}
-
-
-/* =============================================================================
- * PdoExpansion
- * =============================================================================
- */
-static bool_t
-PdoExpansion (router_t* routerPtr, grid_t* myGridPtr, queue_t* queuePtr,
-              coordinate_t* srcPtr, coordinate_t* dstPtr)
-{
-    long xCost = routerPtr->xCost;
-    long yCost = routerPtr->yCost;
-    long zCost = routerPtr->zCost;
-
-    /*
-     * Potential Optimization: Make 'src' the one closest to edge.
-     * This will likely decrease the area of the emitted wave.
-     */
-
-    PQUEUE_CLEAR(queuePtr);
-    long* srcGridPointPtr =
-        grid_getPointRef(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z);
-    PQUEUE_PUSH(queuePtr, (void*)srcGridPointPtr);
-    grid_setPoint(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z, 0);
-    grid_setPoint(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z, GRID_POINT_EMPTY);
-    long* dstGridPointPtr =
-        grid_getPointRef(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z);
-    bool_t isPathFound = FALSE;
-
-    while (!PQUEUE_ISEMPTY(queuePtr)) {
-
-        long* gridPointPtr = (long*)PQUEUE_POP(queuePtr);
-        if (gridPointPtr == dstGridPointPtr) {
-            isPathFound = TRUE;
-            break;
-        }
-
-        long x;
-        long y;
-        long z;
-        grid_getPointIndices(myGridPtr, gridPointPtr, &x, &y, &z);
-        long value = (*gridPointPtr);
-
-        /*
-         * Check 6 neighbors
-         *
-         * Potential Optimization: Only need to check 5 of these
-         */
-        PexpandToNeighbor(myGridPtr, x+1, y,   z,   (value + xCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x-1, y,   z,   (value + xCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y+1, z,   (value + yCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y-1, z,   (value + yCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y,   z+1, (value + zCost), queuePtr);
-        PexpandToNeighbor(myGridPtr, x,   y,   z-1, (value + zCost), queuePtr);
-
-    } /* iterate over work queue */
-
-#if DEBUG
-    printf("Expansion (%li, %li, %li) -> (%li, %li, %li):\n",
-           srcPtr->x, srcPtr->y, srcPtr->z,
-           dstPtr->x, dstPtr->y, dstPtr->z);
-    grid_print(myGridPtr);
-#endif /*  DEBUG */
-
-    return isPathFound;
-}
-
-
-/* =============================================================================
- * traceToNeighbor
- * =============================================================================
- */
-static void
-traceToNeighbor (grid_t* myGridPtr,
-                 point_t* currPtr,
-                 point_t* movePtr,
-                 bool_t useMomentum,
-                 long bendCost,
-                 point_t* nextPtr)
-{
-    long x = currPtr->x + movePtr->x;
-    long y = currPtr->y + movePtr->y;
-    long z = currPtr->z + movePtr->z;
-
-    if (grid_isPointValid(myGridPtr, x, y, z) &&
-        !grid_isPointEmpty(myGridPtr, x, y, z) &&
-        !grid_isPointFull(myGridPtr, x, y, z))
-    {
-        long value = grid_getPoint(myGridPtr, x, y, z);
-        long b = 0;
-        if (useMomentum && (currPtr->momentum != movePtr->momentum)) {
-            b = bendCost;
-        }
-        if ((value + b) <= nextPtr->value) { /* '=' favors neighbors over current */
-            nextPtr->x = x;
-            nextPtr->y = y;
-            nextPtr->z = z;
-            nextPtr->value = value;
-            nextPtr->momentum = movePtr->momentum;
-        }
-    }
-}
-
-
-/* =============================================================================
- * PdoTraceback
- * =============================================================================
- */
-static vector_t*
-PdoTraceback (grid_t* gridPtr, grid_t* myGridPtr,
-              coordinate_t* dstPtr, long bendCost)
-{
-    vector_t* pointVectorPtr = PVECTOR_ALLOC(1);
-    assert(pointVectorPtr);
-
-    point_t next;
-    next.x = dstPtr->x;
-    next.y = dstPtr->y;
-    next.z = dstPtr->z;
-    next.value = grid_getPoint(myGridPtr, next.x, next.y, next.z);
-    next.momentum = MOMENTUM_ZERO;
-
-    while (1) {
-
-        long* gridPointPtr = grid_getPointRef(gridPtr, next.x, next.y, next.z);
-        PVECTOR_PUSHBACK(pointVectorPtr, (void*)gridPointPtr);
-        grid_setPoint(myGridPtr, next.x, next.y, next.z, GRID_POINT_FULL);
-
-        /* Check if we are done */
-        if (next.value == 0) {
-            break;
-        }
-        point_t curr = next;
-
-        /*
-         * Check 6 neighbors
-         *
-         * Potential Optimization: Only need to check 5 of these
-         */
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, TRUE, bendCost, &next);
-        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, TRUE, bendCost, &next);
-
-#if DEBUG
-        printf("(%li, %li, %li)\n", next.x, next.y, next.z);
-#endif /* DEBUG */
-        /*
-         * Because of bend costs, none of the neighbors may appear to be closer.
-         * In this case, pick a neighbor while ignoring momentum.
-         */
-        if ((curr.x == next.x) &&
-            (curr.y == next.y) &&
-            (curr.z == next.z))
-        {
-            next.value = curr.value;
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, FALSE, bendCost, &next);
-            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, FALSE, bendCost, &next);
-
-            if ((curr.x == next.x) &&
-                (curr.y == next.y) &&
-                (curr.z == next.z))
-            {
-                PVECTOR_FREE(pointVectorPtr);
-#if DEBUG
-                puts("[dead]");
-#endif
-                return NULL; /* cannot find path */
-            }
-        }
-    }
-
-#if DEBUG
-    puts("");
-#endif /* DEBUG */
-
-    return pointVectorPtr;
-}
-
-
-/* =============================================================================
- * router_solve
- * =============================================================================
- */
-void
-router_solve (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    router_solve_arg_t* routerArgPtr = (router_solve_arg_t*)argPtr;
-    router_t* routerPtr = routerArgPtr->routerPtr;
-    maze_t* mazePtr = routerArgPtr->mazePtr;
-    vector_t* myPathVectorPtr = PVECTOR_ALLOC(1);
-    assert(myPathVectorPtr);
-
-    queue_t* workQueuePtr = mazePtr->workQueuePtr;
-    grid_t* gridPtr = mazePtr->gridPtr;
-    grid_t* myGridPtr =
-        PGRID_ALLOC(gridPtr->width, gridPtr->height, gridPtr->depth);
-    assert(myGridPtr);
-    long bendCost = routerPtr->bendCost;
-    queue_t* myExpansionQueuePtr = PQUEUE_ALLOC(-1);
-
-    /*
-     * Iterate over work list to route each path. This involves an
-     * 'expansion' and 'traceback' phase for each source/destination pair.
-     */
-    while (1) {
-
-        pair_t* coordinatePairPtr;
-        TM_BEGIN();
-        if (TMQUEUE_ISEMPTY(workQueuePtr)) {
-            coordinatePairPtr = NULL;
-        } else {
-            coordinatePairPtr = (pair_t*)TMQUEUE_POP(workQueuePtr);
-        }
-        TM_END();
-        if (coordinatePairPtr == NULL) {
-            break;
-        }
-
-        coordinate_t* srcPtr = coordinatePairPtr->firstPtr;
-        coordinate_t* dstPtr = coordinatePairPtr->secondPtr;
-
-        bool_t success = FALSE;
-        vector_t* pointVectorPtr = NULL;
-
-        TM_BEGIN();
-        grid_copy(myGridPtr, gridPtr); /* ok if not most up-to-date */
-        if (PdoExpansion(routerPtr, myGridPtr, myExpansionQueuePtr,
-                         srcPtr, dstPtr)) {
-            pointVectorPtr = PdoTraceback(gridPtr, myGridPtr, dstPtr, bendCost);
-            /*
-             * TODO: fix memory leak
-             *
-             * pointVectorPtr will be a memory leak if we abort this transaction
-             */
-            if (pointVectorPtr) {
-                TMGRID_ADDPATH(gridPtr, pointVectorPtr);
-                TM_LOCAL_WRITE(success, TRUE);
-            }
-        }
-        TM_END();
-
-        if (success) {
-            bool_t status = PVECTOR_PUSHBACK(myPathVectorPtr,
-                                             (void*)pointVectorPtr);
-            assert(status);
-        }
-
-    }
-
-    /*
-     * Add my paths to global list
-     */
-    list_t* pathVectorListPtr = routerArgPtr->pathVectorListPtr;
-    TM_BEGIN();
-    TMLIST_INSERT(pathVectorListPtr, (void*)myPathVectorPtr);
-    TM_END();
-
-    PGRID_FREE(myGridPtr);
-    PQUEUE_FREE(myExpansionQueuePtr);
-
-#if DEBUG
-    puts("\nFinal Grid:");
-    grid_print(gridPtr);
-#endif /* DEBUG */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of router.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.cpp stamp-grun/labyrinth/router.cpp
--- stamp-0.9.10/labyrinth/router.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/labyrinth/router.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,473 @@
+/* =============================================================================
+ *
+ * router.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+#include "Galois/Statistic.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include "coordinate.h"
+#include "grid.h"
+#include "queue.h"
+#include "router.h"
+#include "tm.h"
+#include "vector.h"
+
+
+typedef enum momentum {
+    MOMENTUM_ZERO = 0,
+    MOMENTUM_POSX = 1,
+    MOMENTUM_POSY = 2,
+    MOMENTUM_POSZ = 3,
+    MOMENTUM_NEGX = 4,
+    MOMENTUM_NEGY = 5,
+    MOMENTUM_NEGZ = 6
+} momentum_t;
+
+typedef struct point {
+    long x;
+    long y;
+    long z;
+    long value;
+    momentum_t momentum;
+} point_t;
+
+point_t MOVE_POSX = { 1,  0,  0,  0, MOMENTUM_POSX};
+point_t MOVE_POSY = { 0,  1,  0,  0, MOMENTUM_POSY};
+point_t MOVE_POSZ = { 0,  0,  1,  0, MOMENTUM_POSZ};
+point_t MOVE_NEGX = {-1,  0,  0,  0, MOMENTUM_NEGX};
+point_t MOVE_NEGY = { 0, -1,  0,  0, MOMENTUM_NEGY};
+point_t MOVE_NEGZ = { 0,  0, -1,  0, MOMENTUM_NEGZ};
+
+
+/* =============================================================================
+ * router_alloc
+ * =============================================================================
+ */
+router_t*
+router_alloc (long xCost, long yCost, long zCost, long bendCost)
+{
+    router_t* routerPtr;
+
+    routerPtr = (router_t*)malloc(sizeof(router_t));
+    if (routerPtr) {
+        routerPtr->xCost = xCost;
+        routerPtr->yCost = yCost;
+        routerPtr->zCost = zCost;
+        routerPtr->bendCost = bendCost;
+    }
+
+    return routerPtr;
+}
+
+
+/* =============================================================================
+ * router_free
+ * =============================================================================
+ */
+void
+router_free (router_t* routerPtr)
+{
+    free(routerPtr);
+}
+
+
+/* =============================================================================
+ * PexpandToNeighbor
+ * =============================================================================
+ */
+static void
+PexpandToNeighbor (grid_t* myGridPtr,
+                   long x, long y, long z, long value, queue_t* queuePtr)
+{
+    if (grid_isPointValid(myGridPtr, x, y, z)) {
+        long* neighborGridPointPtr = grid_getPointRef(myGridPtr, x, y, z);
+        long neighborValue = *neighborGridPointPtr;
+        if (neighborValue == GRID_POINT_EMPTY) {
+            (*neighborGridPointPtr) = value;
+            PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
+        } else if (neighborValue != GRID_POINT_FULL) {
+            /* We have expanded here before... is this new path better? */
+            if (value < neighborValue) {
+                (*neighborGridPointPtr) = value;
+                PQUEUE_PUSH(queuePtr, (void*)neighborGridPointPtr);
+            }
+        }
+    }
+}
+
+
+/* =============================================================================
+ * PdoExpansion
+ * =============================================================================
+ */
+static bool_t
+PdoExpansion (router_t* routerPtr, grid_t* myGridPtr, queue_t* queuePtr,
+              coordinate_t* srcPtr, coordinate_t* dstPtr)
+{
+    long xCost = routerPtr->xCost;
+    long yCost = routerPtr->yCost;
+    long zCost = routerPtr->zCost;
+
+    /*
+     * Potential Optimization: Make 'src' the one closest to edge.
+     * This will likely decrease the area of the emitted wave.
+     */
+
+    PQUEUE_CLEAR(queuePtr);
+    long* srcGridPointPtr =
+        grid_getPointRef(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z);
+    PQUEUE_PUSH(queuePtr, (void*)srcGridPointPtr);
+    grid_setPoint(myGridPtr, srcPtr->x, srcPtr->y, srcPtr->z, 0);
+    grid_setPoint(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z, GRID_POINT_EMPTY);
+    long* dstGridPointPtr =
+        grid_getPointRef(myGridPtr, dstPtr->x, dstPtr->y, dstPtr->z);
+    bool_t isPathFound = FALSE;
+
+    while (!PQUEUE_ISEMPTY(queuePtr)) {
+
+        long* gridPointPtr = (long*)PQUEUE_POP(queuePtr);
+        if (gridPointPtr == dstGridPointPtr) {
+            isPathFound = TRUE;
+            break;
+        }
+
+        long x;
+        long y;
+        long z;
+        grid_getPointIndices(myGridPtr, gridPointPtr, &x, &y, &z);
+        long value = (*gridPointPtr);
+
+        /*
+         * Check 6 neighbors
+         *
+         * Potential Optimization: Only need to check 5 of these
+         */
+        PexpandToNeighbor(myGridPtr, x+1, y,   z,   (value + xCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x-1, y,   z,   (value + xCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y+1, z,   (value + yCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y-1, z,   (value + yCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y,   z+1, (value + zCost), queuePtr);
+        PexpandToNeighbor(myGridPtr, x,   y,   z-1, (value + zCost), queuePtr);
+
+    } /* iterate over work queue */
+
+#if DEBUG
+    printf("Expansion (%li, %li, %li) -> (%li, %li, %li):\n",
+           srcPtr->x, srcPtr->y, srcPtr->z,
+           dstPtr->x, dstPtr->y, dstPtr->z);
+    grid_print(myGridPtr);
+#endif /*  DEBUG */
+
+    return isPathFound;
+}
+
+
+/* =============================================================================
+ * traceToNeighbor
+ * =============================================================================
+ */
+static void
+traceToNeighbor (grid_t* myGridPtr,
+                 point_t* currPtr,
+                 point_t* movePtr,
+                 bool_t useMomentum,
+                 long bendCost,
+                 point_t* nextPtr)
+{
+    long x = currPtr->x + movePtr->x;
+    long y = currPtr->y + movePtr->y;
+    long z = currPtr->z + movePtr->z;
+
+    if (grid_isPointValid(myGridPtr, x, y, z) &&
+        !grid_isPointEmpty(myGridPtr, x, y, z) &&
+        !grid_isPointFull(myGridPtr, x, y, z))
+    {
+        long value = grid_getPoint(myGridPtr, x, y, z);
+        long b = 0;
+        if (useMomentum && (currPtr->momentum != movePtr->momentum)) {
+            b = bendCost;
+        }
+        if ((value + b) <= nextPtr->value) { /* '=' favors neighbors over current */
+            nextPtr->x = x;
+            nextPtr->y = y;
+            nextPtr->z = z;
+            nextPtr->value = value;
+            nextPtr->momentum = movePtr->momentum;
+        }
+    }
+}
+
+
+/* =============================================================================
+ * PdoTraceback
+ * =============================================================================
+ */
+static vector_t*
+PdoTraceback (grid_t* gridPtr, grid_t* myGridPtr,
+              coordinate_t* dstPtr, long bendCost)
+{
+    vector_t* pointVectorPtr = PVECTOR_ALLOC(1);
+    assert(pointVectorPtr);
+
+    point_t next;
+    next.x = dstPtr->x;
+    next.y = dstPtr->y;
+    next.z = dstPtr->z;
+    next.value = grid_getPoint(myGridPtr, next.x, next.y, next.z);
+    next.momentum = MOMENTUM_ZERO;
+
+    while (1) {
+
+        long* gridPointPtr = grid_getPointRef(gridPtr, next.x, next.y, next.z);
+        PVECTOR_PUSHBACK(pointVectorPtr, (void*)gridPointPtr);
+        grid_setPoint(myGridPtr, next.x, next.y, next.z, GRID_POINT_FULL);
+
+        /* Check if we are done */
+        if (next.value == 0) {
+            break;
+        }
+        point_t curr = next;
+
+        /*
+         * Check 6 neighbors
+         *
+         * Potential Optimization: Only need to check 5 of these
+         */
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, TRUE, bendCost, &next);
+        traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, TRUE, bendCost, &next);
+
+#if DEBUG
+        printf("(%li, %li, %li)\n", next.x, next.y, next.z);
+#endif /* DEBUG */
+        /*
+         * Because of bend costs, none of the neighbors may appear to be closer.
+         * In this case, pick a neighbor while ignoring momentum.
+         */
+        if ((curr.x == next.x) &&
+            (curr.y == next.y) &&
+            (curr.z == next.z))
+        {
+            next.value = curr.value;
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSX, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSY, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_POSZ, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGX, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGY, FALSE, bendCost, &next);
+            traceToNeighbor(myGridPtr, &curr, &MOVE_NEGZ, FALSE, bendCost, &next);
+
+            if ((curr.x == next.x) &&
+                (curr.y == next.y) &&
+                (curr.z == next.z))
+            {
+                PVECTOR_FREE(pointVectorPtr);
+#if DEBUG
+                puts("[dead]");
+#endif
+                return NULL; /* cannot find path */
+            }
+        }
+    }
+
+#if DEBUG
+    puts("");
+#endif /* DEBUG */
+
+    return pointVectorPtr;
+}
+
+struct Fn1 {
+    router_solve_arg_t* routerArgPtr;
+    Galois::Runtime::PerThreadStorage<vector_t*>& foundPointVectors;
+    Galois::Runtime::PerThreadStorage<grid_t*>& localGrids;
+    Galois::Runtime::PerThreadStorage<queue_t*>& queues;
+
+    void operator()(void* voidPtr, Galois::UserContext<void*>& ctx) {
+        pair_t* coordinatePairPtr = (pair_t*) voidPtr;
+
+        router_t* routerPtr = routerArgPtr->routerPtr;
+        maze_t* mazePtr = routerArgPtr->mazePtr;
+		vector_t*& myPathVectorPtr = *foundPointVectors.getLocal();
+        if (!myPathVectorPtr)
+            myPathVectorPtr = PVECTOR_ALLOC(1);
+        grid_t* gridPtr = mazePtr->gridPtr;
+        grid_t*& myGrid = *localGrids.getLocal();
+        // TODO potential source of contention.
+        if (!myGrid)
+            myGrid = PGRID_ALLOC(gridPtr->width, gridPtr->height, gridPtr->depth);
+        grid_t* myGridPtr = myGrid;
+
+        assert(myGridPtr);
+        long bendCost = routerPtr->bendCost;
+        queue_t*& myExpansionQueue = *queues.getLocal();
+        if (!myExpansionQueue)
+            myExpansionQueue = PQUEUE_ALLOC(-1);
+
+        /*
+         * Iterate over work list to route each path. This involves an
+         * 'expansion' and 'traceback' phase for each source/destination pair.
+         */
+        coordinate_t* srcPtr = (coordinate_t*)coordinatePairPtr->firstPtr;
+        coordinate_t* dstPtr = (coordinate_t*)coordinatePairPtr->secondPtr;
+
+        bool_t success = FALSE;
+        vector_t* pointVectorPtr = NULL;
+
+        TM_BEGIN();
+
+          grid_copy(myGridPtr, gridPtr); /* ok if not most up-to-date */
+          if (PdoExpansion(routerPtr, myGridPtr, myExpansionQueue,
+                           srcPtr, dstPtr)) {
+              pointVectorPtr = PdoTraceback(gridPtr, myGridPtr, dstPtr, bendCost);
+              // grid locks;
+              if (pointVectorPtr) {
+                  TMGRID_ADDPATH(gridPtr, pointVectorPtr);
+                  TM_LOCAL_WRITE(success, TRUE);
+              }
+          }
+       
+        TM_END();
+
+        if (success == TRUE) {
+            bool_t status = PVECTOR_PUSHBACK(myPathVectorPtr,
+                                             (void*)pointVectorPtr);
+            assert(status);
+        }
+    }
+};
+/* =============================================================================
+ * router_solve
+ * =============================================================================
+ */
+void
+router_solve (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    router_solve_arg_t* routerArgPtr = (router_solve_arg_t*)argPtr;
+    router_t* routerPtr = routerArgPtr->routerPtr;
+    maze_t* mazePtr = routerArgPtr->mazePtr;
+
+
+    grid_t* gridPtr = mazePtr->gridPtr;
+    Galois::Runtime::PerThreadStorage<vector_t*> foundPointVectors;
+    Galois::Runtime::PerThreadStorage<grid_t*> localGrids;
+    Galois::Runtime::PerThreadStorage<queue_t*> queues;
+
+    queue_t* workQueuePtr = mazePtr->workQueuePtr;
+	std::deque<void*> work;
+    void* ptr;
+    while ((ptr = queue_pop(mazePtr->workQueuePtr))) {
+		work.push_back(ptr);
+    }
+    Fn1 fn1 = { routerArgPtr, foundPointVectors, localGrids, queues };
+    Galois::for_each(work.begin(), work.end(), fn1, Galois::wl<Galois::WorkList::FIFO<> >());
+
+    /*
+     * Add my paths to global list
+     */
+    list_t* pathVectorListPtr = routerArgPtr->pathVectorListPtr;
+    TM_BEGIN();
+    for (unsigned ii = 0; ii < foundPointVectors.size(); ++ii) {
+        if (*foundPointVectors.getRemote(ii))
+            list_insert(pathVectorListPtr, (void*)*foundPointVectors.getRemote(ii));
+    }
+    TM_END();
+
+    for (unsigned ii = 0; ii < localGrids.size(); ++ii) {
+        if (*localGrids.getRemote(ii))
+            PGRID_FREE(*localGrids.getRemote(ii));
+    }
+    for (unsigned ii = 0; ii < queues.size(); ++ii) {
+        if (*queues.getRemote(ii))
+            PQUEUE_FREE(*queues.getRemote(ii));
+    }
+    //PGRID_FREE(myGridPtr);
+    //PQUEUE_FREE(myExpansionQueuePtr);
+
+#if DEBUG
+    puts("\nFinal Grid:");
+    grid_print(gridPtr);
+#endif /* DEBUG */
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ *
+ * End of router.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/labyrinth/router.h stamp-grun/labyrinth/router.h
--- stamp-0.9.10/labyrinth/router.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/labyrinth/router.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,10 @@
 #include "tm.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct router {
     long xCost;
     long yCost;
@@ -115,6 +119,9 @@
 void
 router_solve (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* ROUTER_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/mt19937ar.c stamp-grun/lib/mt19937ar.c
--- stamp-0.9.10/lib/mt19937ar.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/mt19937ar.c	2017-03-21 19:06:13.000000000 +0000
@@ -124,7 +124,7 @@
     unsigned long mti;
 
     mt[0]= s & 0xffffffffUL;
-    for (mti=1; mti<N; mti++) {
+    for (mti=1; mti<RANDOM_N; mti++) {
         mt[mti] =
           (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
@@ -147,25 +147,25 @@
     long i, j, k;
     init_genrand(mt, mtiPtr, 19650218UL);
     i=1; j=0;
-    k = (N>key_length ? N : key_length);
+    k = (RANDOM_N>key_length ? RANDOM_N : key_length);
     for (; k; k--) {
         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
           + init_key[j] + j; /* non linear */
         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
         i++; j++;
-        if (i>=N) { mt[0] = mt[N-1]; i=1; }
+        if (i>=RANDOM_N) { mt[0] = mt[RANDOM_N-1]; i=1; }
         if (j>=key_length) j=0;
     }
-    for (k=N-1; k; k--) {
+    for (k=RANDOM_N-1; k; k--) {
         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
           - i; /* non linear */
         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
         i++;
-        if (i>=N) { mt[0] = mt[N-1]; i=1; }
+        if (i>=RANDOM_N) { mt[0] = mt[RANDOM_N-1]; i=1; }
     }
 
     mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
-    (*mtiPtr) = N + 1;
+    (*mtiPtr) = RANDOM_N + 1;
 }
 
 /* generates a random number on [0,0xffffffff]-interval */
@@ -177,22 +177,22 @@
 
     /* mag01[x] = x * MATRIX_A  for x=0,1 */
 
-    if (mti >= N) { /* generate N words at one time */
+    if (mti >= RANDOM_N) { /* generate N words at one time */
         long kk;
 
-        if (mti == N+1)   /* if init_genrand() has not been called, */
+        if (mti == RANDOM_N+1)   /* if init_genrand() has not been called, */
             init_genrand(mt, mtiPtr, 5489UL); /* a default initial seed is used */
 
-        for (kk=0;kk<N-M;kk++) {
+        for (kk=0;kk<RANDOM_N-M;kk++) {
             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
             mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
         }
-        for (;kk<N-1;kk++) {
+        for (;kk<RANDOM_N-1;kk++) {
             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
-            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
+            mt[kk] = mt[kk+(M-RANDOM_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
         }
-        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
-        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
+        y = (mt[RANDOM_N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
+        mt[RANDOM_N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
 
         mti = 0;
     }
diff -x .git -x inputs -Naur stamp-0.9.10/lib/mt19937ar.h stamp-grun/lib/mt19937ar.h
--- stamp-0.9.10/lib/mt19937ar.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/mt19937ar.h	2017-03-21 19:06:25.000000000 +0000
@@ -132,15 +132,15 @@
 
 
 /* Period parameters */
-#define N 624
+#define RANDOM_N 624
 #define M 397
 #define MATRIX_A 0x9908b0dfUL   /* constant vector a */
 #define UPPER_MASK 0x80000000UL /* most significant w-r bits */
 #define LOWER_MASK 0x7fffffffUL /* least significant r bits */
 
 #if 0
-static unsigned long mt[N]; /* the array for the state vector  */
-static long mti=N+1; /* mti==N+1 means mt[N] is not initialized */
+static unsigned long mt[RANDOM_N]; /* the array for the state vector  */
+static long mti=N+1; /* mti==N+1 means mt[RANDOM_N] is not initialized */
 #endif
 
 /* initializes mt[N] with a seed */
diff -x .git -x inputs -Naur stamp-0.9.10/lib/random.c stamp-grun/lib/random.c
--- stamp-0.9.10/lib/random.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/random.c	2017-03-21 19:06:39.000000000 +0000
@@ -85,7 +85,7 @@
 {
     random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
     if (randomPtr != NULL) {
-        randomPtr->mti = N;
+        randomPtr->mti = RANDOM_N;
         init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
     }
 
@@ -103,7 +103,7 @@
 {
     random_t* randomPtr = (random_t*)P_MALLOC(sizeof(random_t));
     if (randomPtr != NULL) {
-        randomPtr->mti = N;
+        randomPtr->mti = RANDOM_N;
         init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
     }
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/random.h stamp-grun/lib/random.h
--- stamp-0.9.10/lib/random.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/random.h	2017-03-21 19:06:46.000000000 +0000
@@ -85,7 +85,7 @@
 
 typedef struct random {
     unsigned long (*rand)(unsigned long*, unsigned long*);
-    unsigned long mt[N];
+    unsigned long mt[RANDOM_N];
     unsigned long mti;
 } random_t;
 
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.c stamp-grun/lib/thread.c
--- stamp-0.9.10/lib/thread.c	2017-03-21 17:35:07.000000000 +0000
+++ stamp-grun/lib/thread.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,568 +0,0 @@
-/* =============================================================================
- *
- * thread.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdlib.h>
-#ifdef USE_PAPI
-#include <papi.h>
-#include <papiStdEventDefs.h>
-#endif
-#include "thread.h"
-#include "types.h"
-#include "tm.h"
-
-static THREAD_LOCAL_T    global_threadId;
-static long              global_numThread       = 1;
-static THREAD_BARRIER_T* global_barrierPtr      = NULL;
-static long*             global_threadIds       = NULL;
-static THREAD_ATTR_T     global_threadAttr;
-static THREAD_T*         global_threads         = NULL;
-static void            (*global_funcPtr)(void*) = NULL;
-static void*             global_argPtr          = NULL;
-static volatile bool_t   global_doShutdown      = FALSE;
-
-#ifdef USE_PAPI
-static int isInit;
-static int isSampling;
-static __thread int papiEventSet = PAPI_NULL;
-
-static int papiEvents[3] = {PAPI_L3_TCA, PAPI_L3_TCM, PAPI_TOT_CYC};
-static const char* papiNames[3] = {"L3_ACCESSES", "L3_MISSES", "CyclesCounter"};
-
-//static int papiEvents[2] = {PAPI_TOT_INS, PAPI_TOT_CYC};
-//static const char* papiNames[2] = {"Instructions", "Cycles"};
-static const int maxThreads = 128;
-//static int papiEvents[2] = {PAPI_L1_DCM, PAPI_TOT_CYC};
-//static const char* papiNames[2] = {"L1DCMCounter", "CyclesCounter"};
-static long_long papiResults[(sizeof(papiEvents)/sizeof(*papiEvents)) * 128];
-
-static void handle_error(const char* str) {
-  fprintf(stderr, str);
-  abort();
-}
-
-static void begin(long threadId) {
-  if (threadId == 0) {
-    if (isSampling)
-      handle_error("Sampling already begun");
-    isSampling = 1;
-  } else if (!isSampling) {
-    return;
-  }
-
-  int rv;
-
-  // Init library
-  if (!isInit) {
-    rv = PAPI_library_init(PAPI_VER_CURRENT);
-    if (rv != PAPI_VER_CURRENT && rv < 0) {
-      handle_error("PAPI library version mismatch!");
-    }
-    if (rv < 0) handle_error(PAPI_strerror(rv));
-    if ((rv = PAPI_thread_init(pthread_self)) != PAPI_OK)
-      handle_error(PAPI_strerror(rv));
-    isInit = 1;
-  }
-  // Register thread
-  if ((rv = PAPI_register_thread()) != PAPI_OK) 
-    handle_error(PAPI_strerror(rv));
-  // Create the Event Set
-  if ((rv = PAPI_create_eventset(&papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  if ((rv = PAPI_add_events(papiEventSet, papiEvents, sizeof(papiEvents)/sizeof(*papiEvents))) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Start counting events in the event set
-  if ((rv = PAPI_start(papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-}
-
-static void end(long threadId) {
-  if (threadId == 0) {
-    if (!isSampling)
-      handle_error("Sampling not yet begun");
-    isSampling = 0;
-  } else if (!isSampling) {
-    return;
-  }
-
-  int rv;
-
-  long_long results[sizeof(papiNames)/sizeof(*papiNames)];
-
-  // Get the values
-  if ((rv = PAPI_stop(papiEventSet, results)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Remove all events in the eventset
-  if ((rv = PAPI_cleanup_eventset(papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Free all memory and data structures, EventSet must be empty.
-  if ((rv = PAPI_destroy_eventset(&papiEventSet)) != PAPI_OK)
-    handle_error(PAPI_strerror(rv));
-  // Unregister thread
-  if ((rv = PAPI_unregister_thread()) != PAPI_OK) 
-    handle_error(PAPI_strerror(rv));
-
-  if (threadId >= maxThreads)
-    handle_error("too many threads");
-
-  for (unsigned i = 0; i < sizeof(papiNames)/sizeof(*papiNames); ++i)
-    papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * threadId + i] += results[i];
-
-  if (threadId == 0) {
-    printf("\n");
-    printf("STATTYPE,LOOP,CATEGORY,n,sum");
-    for (int t = 0; t < maxThreads; ++t) {
-      printf(",T%d", t);
-    }
-    printf("\n");
-    for (unsigned i = 0; i < sizeof(papiNames)/sizeof(*papiNames); ++i) {
-      long_long sum = 0;
-      for (int t = 0; t < maxThreads; ++t) {
-        sum += papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * t + i];
-      }
-      printf("STAT,(NULL),%s,%d,%ld", papiNames[i], maxThreads, sum);
-      for (int t = 0; t < maxThreads; ++t) {
-        printf(",%ld", papiResults[sizeof(papiEvents)/sizeof(*papiEvents) * t + i]);
-      }
-      printf("\n");
-    }
-  }
-}
-
-void thread_begin_timing() {
-  begin(0);
-}
-
-void thread_end_timing() {
-  end(0);
-}
-static void thread_begin(long threadId) {
-  if (threadId == 0)
-    return;
-  begin(threadId);
-}
-static void thread_end(long threadId) {
-  if (threadId == 0)
-    return;
-  end(threadId);
-}
-#else
-void thread_end_timing() { }
-void thread_begin_timing() { }
-static void thread_begin(long x) { }
-static void thread_end(long x) { }
-#endif
-/* =============================================================================
- * threadWait
- * -- Synchronizes all threads to start/stop parallel section
- * =============================================================================
- */
-static void
-threadWait (void* argPtr)
-{
-    long threadId = *(long*)argPtr;
-
-    THREAD_LOCAL_SET(global_threadId, (long)threadId);
-
-    while (1) {
-        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
-        if (global_doShutdown) {
-            break;
-        }
-        thread_begin(threadId);
-        global_funcPtr(global_argPtr);
-        thread_end(threadId);
-        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
-        if (threadId == 0) {
-            break;
-        }
-    }
-}
-
-
-/* =============================================================================
- * thread_startup
- * -- Create pool of secondary threads
- * -- numThread is total number of threads (primary + secondaries)
- * =============================================================================
- */
-void
-thread_startup (long numThread)
-{
-#if !defined(STM) && !defined(HTM)
-    if (numThread > 1) {
-      printf("This application does not support multiple threads\n");
-      abort();
-    }
-#endif
-    long i;
-
-    global_numThread = numThread;
-    global_doShutdown = FALSE;
-
-    /* Set up barrier */
-    assert(global_barrierPtr == NULL);
-    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
-    assert(global_barrierPtr);
-    THREAD_BARRIER_INIT(global_barrierPtr, numThread);
-
-    /* Set up ids */
-    THREAD_LOCAL_INIT(global_threadId);
-    assert(global_threadIds == NULL);
-    global_threadIds = (long*)malloc(numThread * sizeof(long));
-    assert(global_threadIds);
-    for (i = 0; i < numThread; i++) {
-        global_threadIds[i] = i;
-    }
-
-    /* Set up thread list */
-    assert(global_threads == NULL);
-    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
-    assert(global_threads);
-
-    /* Set up pool */
-    THREAD_ATTR_INIT(global_threadAttr);
-    for (i = 1; i < numThread; i++) {
-        THREAD_CREATE(global_threads[i],
-                      global_threadAttr,
-                      &threadWait,
-                      &global_threadIds[i]);
-    }
-
-    /*
-     * Wait for primary thread to call thread_start
-     */
-}
-
-
-/* =============================================================================
- * thread_start
- * -- Make primary and secondary threads execute work
- * -- Should only be called by primary thread
- * -- funcPtr takes one arguments: argPtr
- * =============================================================================
- */
-void
-thread_start (void (*funcPtr)(void*), void* argPtr)
-{
-    global_funcPtr = funcPtr;
-    global_argPtr = argPtr;
-
-    long threadId = 0; /* primary */
-    threadWait((void*)&threadId);
-}
-
-
-/* =============================================================================
- * thread_shutdown
- * -- Primary thread kills pool of secondary threads
- * =============================================================================
- */
-void
-thread_shutdown ()
-{
-    /* Make secondary threads exit wait() */
-    global_doShutdown = TRUE;
-    THREAD_BARRIER(global_barrierPtr, 0);
-
-    long numThread = global_numThread;
-
-    long i;
-    for (i = 1; i < numThread; i++) {
-        THREAD_JOIN(global_threads[i]);
-    }
-
-    THREAD_BARRIER_FREE(global_barrierPtr);
-    global_barrierPtr = NULL;
-
-    free(global_threadIds);
-    global_threadIds = NULL;
-
-    free(global_threads);
-    global_threads = NULL;
-
-    global_numThread = 1;
-}
-
-
-/* =============================================================================
- * thread_barrier_alloc
- * =============================================================================
- */
-thread_barrier_t*
-thread_barrier_alloc (long numThread)
-{
-    thread_barrier_t* barrierPtr;
-
-    assert(numThread > 0);
-    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
-    barrierPtr = (thread_barrier_t*)malloc(numThread * sizeof(thread_barrier_t));
-    if (barrierPtr != NULL) {
-        barrierPtr->numThread = numThread;
-    }
-
-    return barrierPtr;
-}
-
-
-/* =============================================================================
- * thread_barrier_free
- * =============================================================================
- */
-void
-thread_barrier_free (thread_barrier_t* barrierPtr)
-{
-    free(barrierPtr);
-}
-
-
-/* =============================================================================
- * thread_barrier_init
- * =============================================================================
- */
-void
-thread_barrier_init (thread_barrier_t* barrierPtr)
-{
-    long i;
-    long numThread = barrierPtr->numThread;
-
-    for (i = 0; i < numThread; i++) {
-        barrierPtr[i].count = 0;
-        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
-        THREAD_COND_INIT(barrierPtr[i].proceedCond);
-        THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
-    }
-}
-
-
-/* =============================================================================
- * thread_barrier
- * -- Simple logarithmic barrier
- * =============================================================================
- */
-void
-thread_barrier (thread_barrier_t* barrierPtr, long threadId)
-{
-    long i = 2;
-    long base = 0;
-    long index;
-    long numThread = barrierPtr->numThread;
-
-    if (numThread < 2) {
-        return;
-    }
-
-    do {
-        index = base + threadId / i;
-        if ((threadId % i) == 0) {
-            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-            barrierPtr[index].count++;
-            while (barrierPtr[index].count < 2) {
-                THREAD_COND_WAIT(barrierPtr[index].proceedCond,
-                                 barrierPtr[index].countLock);
-            }
-            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-        } else {
-            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-            barrierPtr[index].count++;
-            if (barrierPtr[index].count == 2) {
-                THREAD_COND_SIGNAL(barrierPtr[index].proceedCond);
-            }
-            while (THREAD_COND_WAIT(barrierPtr[index].proceedAllCond,
-                                    barrierPtr[index].countLock) != 0)
-            {
-                /* wait */
-            }
-            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-            break;
-        }
-        base = base + numThread / i;
-        i *= 2;
-    } while (i <= numThread);
-
-    for (i /= 2; i > 1; i /= 2) {
-        base = base - numThread / i;
-        index = base + threadId / i;
-        THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
-        barrierPtr[index].count = 0;
-        THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
-        THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
-    }
-}
-
-
-/* =============================================================================
- * thread_getId
- * -- Call after thread_start() to get thread ID inside parallel region
- * =============================================================================
- */
-long
-thread_getId()
-{
-    return (long)THREAD_LOCAL_GET(global_threadId);
-}
-
-
-/* =============================================================================
- * thread_getNumThread
- * -- Call after thread_start() to get number of threads inside parallel region
- * =============================================================================
- */
-long
-thread_getNumThread()
-{
-    return global_numThread;
-}
-
-
-/* =============================================================================
- * thread_barrier_wait
- * -- Call after thread_start() to synchronize threads inside parallel region
- * =============================================================================
- */
-void
-thread_barrier_wait()
-{
-//#ifndef SIMULATOR
-    long threadId = thread_getId();
-//#endif /* !SIMULATOR */
-    THREAD_BARRIER(global_barrierPtr, threadId);
-}
-
-
-/* =============================================================================
- * TEST_THREAD
- * =============================================================================
- */
-#ifdef TEST_THREAD
-
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-#define NUM_THREADS    (4)
-#define NUM_ITERATIONS (3)
-
-
-
-void
-printId (void* argPtr)
-{
-    long threadId = thread_getId();
-    long numThread = thread_getNumThread();
-    long i;
-
-    for ( i = 0; i < NUM_ITERATIONS; i++ ) {
-        thread_barrier_wait();
-        if (threadId == 0) {
-            sleep(1);
-        } else if (threadId == numThread-1) {
-            usleep(100);
-        }
-        printf("i = %li, tid = %li\n", i, threadId);
-        if (threadId == 0) {
-            puts("");
-        }
-        fflush(stdout);
-    }
-}
-
-
-int
-main ()
-{
-    puts("Starting...");
-
-    /* Run in parallel */
-    thread_startup(NUM_THREADS);
-    /* Start timing here */
-    thread_start(printId, NULL);
-    thread_start(printId, NULL);
-    thread_start(printId, NULL);
-    /* Stop timing here */
-    thread_shutdown();
-
-    puts("Done.");
-
-    return 0;
-}
-
-
-#endif /* TEST_THREAD */
-
-
-/* =============================================================================
- *
- * End of thread.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.cpp stamp-grun/lib/thread.cpp
--- stamp-0.9.10/lib/thread.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/lib/thread.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,32 @@
+#include "Galois/Galois.h"
+#include "Galois/Statistic.h"
+
+#include "thread.h"
+#include "tm.h"
+
+static Galois::StatTimer* timer;
+static Galois::StatManager* manager;
+
+long thread_getId() {
+  return Galois::Runtime::LL::getTID();
+}
+
+void thread_begin_timing() {
+  timer->start();
+}
+
+void thread_end_timing() {
+  timer->stop();
+}
+
+void thread_startup(long numThread) {
+  Galois::setActiveThreads(numThread); 
+  manager = new Galois::StatManager;
+  timer = new Galois::StatTimer;
+}
+
+void thread_shutdown() {
+  // Print loop statistics as a side-effect of ~StatManager
+  delete timer;
+  delete manager;
+}
diff -x .git -x inputs -Naur stamp-0.9.10/lib/thread.h stamp-grun/lib/thread.h
--- stamp-0.9.10/lib/thread.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/thread.h	2017-03-20 15:19:45.000000000 +0000
@@ -1,243 +1,20 @@
-/* =============================================================================
- *
- * thread.h
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
 #ifndef THREAD_H
 #define THREAD_H 1
 
-
-#include <pthread.h>
-#include <stdlib.h>
-#include "types.h"
-#ifdef OTM
-#include "omp.h"
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-
-#define THREAD_T                            pthread_t
-#define THREAD_ATTR_T                       pthread_attr_t
-
-#define THREAD_ATTR_INIT(attr)              pthread_attr_init(&attr)
-#define THREAD_JOIN(tid)                    pthread_join(tid, (void**)NULL)
-#define THREAD_CREATE(tid, attr, fn, arg)   pthread_create(&(tid), \
-                                                           &(attr), \
-                                                           (void* (*)(void*))(fn), \
-                                                           (void*)(arg))
-
-#define THREAD_LOCAL_T                      pthread_key_t
-#define THREAD_LOCAL_INIT(key)              pthread_key_create(&key, NULL)
-#define THREAD_LOCAL_SET(key, val)          pthread_setspecific(key, (void*)(val))
-#define THREAD_LOCAL_GET(key)               pthread_getspecific(key)
-
-#define THREAD_MUTEX_T                      pthread_mutex_t
-#define THREAD_MUTEX_INIT(lock)             pthread_mutex_init(&(lock), NULL)
-#define THREAD_MUTEX_LOCK(lock)             pthread_mutex_lock(&(lock))
-#define THREAD_MUTEX_UNLOCK(lock)           pthread_mutex_unlock(&(lock))
-
-#define THREAD_COND_T                       pthread_cond_t
-#define THREAD_COND_INIT(cond)              pthread_cond_init(&(cond), NULL)
-#define THREAD_COND_SIGNAL(cond)            pthread_cond_signal(&(cond))
-#define THREAD_COND_BROADCAST(cond)         pthread_cond_broadcast(&(cond))
-#define THREAD_COND_WAIT(cond, lock)        pthread_cond_wait(&(cond), &(lock))
-
-#ifdef SIMULATOR
-#  define THREAD_BARRIER_T                  pthread_barrier_t
-#  define THREAD_BARRIER_ALLOC(N)           ((THREAD_BARRIER_T*)malloc(sizeof(THREAD_BARRIER_T)))
-#  define THREAD_BARRIER_INIT(bar, N)       pthread_barrier_init(bar, 0, N)
-#  define THREAD_BARRIER(bar, tid)          pthread_barrier_wait(bar)
-#  define THREAD_BARRIER_FREE(bar)          free(bar)
-#else /* !SIMULATOR */
-#  define THREAD_BARRIER_T                  thread_barrier_t
-#  define THREAD_BARRIER_ALLOC(N)           thread_barrier_alloc(N)
-#  define THREAD_BARRIER_INIT(bar, N)       thread_barrier_init(bar)
-#  define THREAD_BARRIER(bar, tid)          thread_barrier(bar, tid)
-#  define THREAD_BARRIER_FREE(bar)          thread_barrier_free(bar)
-#endif /* !SIMULATOR */
-
-typedef struct thread_barrier {
-    THREAD_MUTEX_T countLock;
-    THREAD_COND_T proceedCond;
-    THREAD_COND_T proceedAllCond;
-    long count;
-    long numThread;
-} thread_barrier_t;
-
-
+long thread_getId();
+void thread_startup(long numThread);
+void thread_shutdown();
 void thread_begin_timing();
 void thread_end_timing();
 
-/* =============================================================================
- * thread_startup
- * -- Create pool of secondary threads
- * -- numThread is total number of threads (primary + secondary)
- * =============================================================================
- */
-void
-thread_startup (long numThread);
-
-
-/* =============================================================================
- * thread_start
- * -- Make primary and secondary threads execute work
- * -- Should only be called by primary thread
- * -- funcPtr takes one arguments: argPtr
- * =============================================================================
- */
-void
-thread_start (void (*funcPtr)(void*), void* argPtr);
-
-
-/* =============================================================================
- * thread_shutdown
- * -- Primary thread kills pool of secondary threads
- * =============================================================================
- */
-void
-thread_shutdown ();
-
-
-/* =============================================================================
- * thread_barrier_alloc
- * =============================================================================
- */
-thread_barrier_t*
-thread_barrier_alloc (long numThreads);
-
-
-/* =============================================================================
- * thread_barrier_free
- * =============================================================================
- */
-void
-thread_barrier_free (thread_barrier_t* barrierPtr);
-
-
-/* =============================================================================
- * thread_barrier_init
- * =============================================================================
- */
-void
-thread_barrier_init (thread_barrier_t* barrierPtr);
-
-
-/* =============================================================================
- * thread_barrier
- * -- Simple logarithmic barrier
- * =============================================================================
- */
-void
-thread_barrier (thread_barrier_t* barrierPtr, long threadId);
-
-
-/* =============================================================================
- * thread_getId
- * -- Call after thread_start() to get thread ID inside parallel region
- * =============================================================================
- */
-long
-thread_getId();
-
-
-/* =============================================================================
- * thread_getNumThread
- * -- Call after thread_start() to get number of threads inside parallel region
- * =============================================================================
- */
-long
-thread_getNumThread();
-
-
-/* =============================================================================
- * thread_barrier_wait
- * -- Call after thread_start() to synchronize threads inside parallel region
- * =============================================================================
- */
-void
-thread_barrier_wait();
-
-
 #ifdef __cplusplus
 }
 #endif
 
 
-#endif /* THREAD_H */
-
 
-/* =============================================================================
- *
- * End of thread.h
- *
- * =============================================================================
- */
+#endif
diff -x .git -x inputs -Naur stamp-0.9.10/lib/tm.h stamp-grun/lib/tm.h
--- stamp-0.9.10/lib/tm.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/lib/tm.h	2017-03-20 15:19:45.000000000 +0000
@@ -257,125 +257,30 @@
  * =============================================================================
  */
 
-
-/* =============================================================================
- * HTM - Hardware Transactional Memory
- * =============================================================================
- */
-
-#ifdef HTM
-
-#  include <assert.h>
-#  include "memory.h"
-#  include "thread.h"
-#  include "types.h"
-#  include <speculation.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 if (getenv("STM_STATS")) { \
-    TmReport_t r; \
-    tm_get_all_stats(&r); \
-    printf("transactions: %lu rollbacks: %lu jmv: %lu maxroll: %lu other: %lu\n", \
-        r.totalTransactions, r.totalRollbacks, \
-        r.totalSerializedJMV, r.totalSerializedMAXRB, r.totalSerializedOTHER); \
-   }
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
-
-#  define TM_BEGIN()                    _Pragma ("tm_atomic") {
-#  define TM_BEGIN_RO()                 _Pragma ("tm_atomic") {
-#  define TM_END()                      }
-#  define TM_RESTART()                  abort()
-#  define TM_EARLY_RELEASE(var)         
-
-/* =============================================================================
- * STM - Software Transactional Memory
- * =============================================================================
- */
-
-#elif defined(STM)
-
-#  include <string.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
-
-#  include <mod_stats.h>
-
-#  define TM_STARTUP(numThread)     if (sizeof(long) != sizeof(void *)) { \
-                                      fprintf(stderr, "Error: unsupported long and pointer sizes\n"); \
-                                      exit(1); \
-                                    } \
-                                    stm_init(); \
-                                    mod_mem_init(0); \
-                                    if (getenv("STM_STATS") != NULL) { \
-                                      mod_stats_init(); \
-                                    }
-#  define TM_SHUTDOWN()             if (getenv("STM_STATS") != NULL) { \
-                                      unsigned long u; \
-                                      if (stm_get_global_stats("global_nb_commits", &u) != 0) \
-                                        printf("#commits    : %lu\n", u); \
-                                      if (stm_get_global_stats("global_nb_aborts", &u) != 0) \
-                                        printf("#aborts     : %lu\n", u); \
-                                      if (stm_get_global_stats("global_max_retries", &u) != 0) \
-                                        printf("Max retries : %lu\n", u); \
-                                    } \
-                                    stm_exit()
-
-#  define TM_THREAD_ENTER()         stm_init_thread()
-#  define TM_THREAD_EXIT()          stm_exit_thread()
-
-#  define TM_START(ro)                do { \
-                                          stm_tx_attr_t _a = {{.read_only = ro}}; \
-                                          sigjmp_buf *_e = stm_start(_a); \
-                                          if (_e != NULL) sigsetjmp(*_e, 0); \
-                                      } while (0)
-#  define TM_BEGIN()                  TM_START(0)
-#  define TM_BEGIN_RO()               TM_START(1)
-#  define TM_END()                    stm_commit()
-#  define TM_RESTART()                stm_abort(0)
-
-#  define TM_EARLY_RELEASE(var)       /* nothing */
-
 /* =============================================================================
  * Sequential execution
  * =============================================================================
  */
 
-#else /* SEQUENTIAL */
-
-#  include <assert.h>
-
-#  define TM_ARG                        /* nothing */
-#  define TM_ARG_ALONE                  /* nothing */
-#  define TM_ARGDECL                    /* nothing */
-#  define TM_ARGDECL_ALONE              /* nothing */
-#  define TM_CALLABLE                   /* nothing */
+#include <assert.h>
 
-#  define TM_STARTUP(numThread)         /* nothing */
-#  define TM_SHUTDOWN()                 /* nothing */
+#define TM_ARG                        /* nothing */
+#define TM_ARG_ALONE                  /* nothing */
+#define TM_ARGDECL                    /* nothing */
+#define TM_ARGDECL_ALONE              /* nothing */
+#define TM_CALLABLE                   /* nothing */
 
-#  define TM_THREAD_ENTER()             /* nothing */
-#  define TM_THREAD_EXIT()              /* nothing */
 
-#  define TM_BEGIN()                    /* nothing */
-#  define TM_BEGIN_RO()                 /* nothing */
-#  define TM_END()                      /* nothing */
-#  define TM_RESTART()                  assert(0)
 
-#  define TM_EARLY_RELEASE(var)         /* nothing */
-
-#endif /* SEQUENTIAL */
+#define TM_BEGIN()                    /* nothing */
+#define TM_BEGIN_RO()                 /* nothing */
+#define TM_END()                      /* nothing */
 
+#define TM_EARLY_RELEASE(var)         /* nothing */
 
 /* =============================================================================
  * Transactional Memory System interface for shared memory accesses
@@ -404,6 +309,7 @@
 #  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
 #  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
 #  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
+#  define TM_RESTART()                  stm_abort(0)
+
+#  define TM_STARTUP(numThread)         stm_init()
+#  define TM_SHUTDOWN()                 stm_exit()
+
+#  define TM_THREAD_ENTER()             stm_init_thread()
+#  define TM_THREAD_EXIT()              stm_exit_thread()
 
 #else /* !STM */
 
@@ -418,6 +324,7 @@
 #  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
 #  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
 #  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
+#  define TM_RESTART()                  abort()
+
+#  define TM_STARTUP(numThread)         /* nothing */
+#  define TM_SHUTDOWN()                 /* nothing */
+
+#  define TM_THREAD_ENTER()             /* nothing */
+#  define TM_THREAD_EXIT()              /* nothing */
 
 #endif /* !STM */
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/CMakeLists.txt stamp-grun/ssca2/CMakeLists.txt
--- stamp-0.9.10/ssca2/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/CMakeLists.txt	2017-03-21 18:32:25.000000000 +0000
@@ -12,18 +12,18 @@
 
 set(sources
 	alg_radix_smp.c 
-	computeGraph.c 
+	computeGraph.cpp 
 	createPartition.c 
-        #cutClusters.c 
-        #findSubGraphs.c 
+	#cutClusters.c 
+	#findSubGraphs.c 
 	genScalData.c 
-        getStartLists.c 
+	#getStartLists.c 
 	getUserParameters.c 
 	globals.c 
 	ssca2.c 
 	${LIB_DIR}/mt19937ar.c 
-	${LIB_DIR}/random.c 
-	${LIB_DIR}/thread.c)
+	${LIB_DIR}/random.c
+	${LIB_DIR}/thread.cpp)
 
 app(ssca2 ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/Makefile.orig stamp-grun/ssca2/Makefile.orig
--- stamp-0.9.10/ssca2/Makefile.orig	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-EXECS = RUN_graphAnalysis
-
-SIMPLE_DIR = ../simple-4.4H
-
-OPT        = -O$(O_LEVEL)
-OPT        = -g
-
-include $(SIMPLE_DIR)/Makefile.smp.mk
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/alg_radix_smp.c stamp-grun/ssca2/alg_radix_smp.c
--- stamp-0.9.10/ssca2/alg_radix_smp.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/alg_radix_smp.c	2017-03-20 15:19:45.000000000 +0000
@@ -81,6 +81,7 @@
 static unsigned long* global_lTemp2  = NULL;
 
 
+#if 0
 /* =============================================================================
  * all_countsort_node
  *
@@ -174,7 +175,7 @@
         P_FREE(myHisto);
     }
 }
-
+#endif
 
 /* =============================================================================
  * all_countsort_node_aux_seq
@@ -236,7 +237,7 @@
     free(myHisto);
 }
 
-
+#if 0
 /* =============================================================================
  * all_countsort_node_aux
  *
@@ -406,7 +407,7 @@
         P_FREE(lTemp);
     }
 }
-
+#endif
 
 /* =============================================================================
  * all_radixsort_node_aux_s3_seq
@@ -437,7 +438,7 @@
     free(lTemp2);
 }
 
-
+#if 0
 /* =============================================================================
  * all_radixsort_node_aux_s3
  *
@@ -481,7 +482,7 @@
         P_FREE(lTemp2);
     }
 }
-
+#endif
 
 /* =============================================================================
  *
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.c stamp-grun/ssca2/computeGraph.c
--- stamp-0.9.10/ssca2/computeGraph.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/computeGraph.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,635 +0,0 @@
-/* =============================================================================
- *
- * computeGraph.c
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "computeGraph.h"
-#include "createPartition.h"
-#include "defs.h"
-#include "globals.h"
-#include "thread.h"
-#include "utility.h"
-#include "tm.h"
-
-typedef struct LockableULong {
-    XTM_DECL_LOCKABLE(ULONGINT_T, value1);
-} LockableULong;
-
-typedef struct LockableULongPtr {
-    XTM_DECL_LOCKABLE(LockableULong*, value2);
-} LockableULongPtr;
-
-static ULONGINT_T*  global_p                 = NULL;
-static XTM_DECL_LOCKABLE(ULONGINT_T,   global_maxNumVertices);//    = 0;
-static ULONGINT_T   global_outVertexListSize = 0;
-static LockableULong*  global_impliedEdgeList   = NULL;
-static LockableULongPtr* global_auxArr            = NULL;
-
-/* =============================================================================
- * prefix_sums
- * =============================================================================
- */
-static void
-prefix_sums (ULONGINT_T* result, LONGINT_T* input, ULONGINT_T arraySize)
-{
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T* p = NULL;
-    if (myId == 0) {
-        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
-        assert(p);
-        global_p = p;
-    }
-
-    thread_barrier_wait();
-
-    p = global_p;
-
-    long start;
-    long end;
-
-    long r = arraySize / numThread;
-    start = myId * r + 1;
-    end = (myId + 1) * r;
-    if (myId == (numThread - 1)) {
-        end = arraySize;
-    }
-
-    ULONGINT_T j;
-    for (j = start; j < end; j++) {
-        result[j] = input[j-1] + result[j-1];
-    }
-
-    p[NOSHARE(myId)] = result[end-1];
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        for (j = 1; j < numThread; j++) {
-            p[NOSHARE(j)] += p[NOSHARE(j-1)];
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId > 0) {
-        ULONGINT_T add_value = p[NOSHARE(myId-1)];
-        for (j = start-1; j < end; j++) {
-            result[j] += add_value;
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(p);
-    }
-}
-
-static void
-prefix_sums2 (ULONGINT_T* result, LockableLong* input, ULONGINT_T arraySize)
-{
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T* p = NULL;
-    if (myId == 0) {
-        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
-        assert(p);
-        global_p = p;
-    }
-
-    thread_barrier_wait();
-
-    p = global_p;
-
-    long start;
-    long end;
-
-    long r = arraySize / numThread;
-    start = myId * r + 1;
-    end = (myId + 1) * r;
-    if (myId == (numThread - 1)) {
-        end = arraySize;
-    }
-
-    ULONGINT_T j;
-    for (j = start; j < end; j++) {
-        result[j] = XTM_LOCKABLE_VALUE(input[j-1].value) + result[j-1];
-    }
-
-    p[NOSHARE(myId)] = result[end-1];
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        for (j = 1; j < numThread; j++) {
-            p[NOSHARE(j)] += p[NOSHARE(j-1)];
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId > 0) {
-        ULONGINT_T add_value = p[NOSHARE(myId-1)];
-        for (j = start-1; j < end; j++) {
-            result[j] += add_value;
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(p);
-    }
-}
-
-
-/* =============================================================================
- * computeGraph
- * =============================================================================
- */
-void
-computeGraph (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    graph*    GPtr       = ((computeGraph_arg_t*)argPtr)->GPtr;
-    graphSDG* SDGdataPtr = ((computeGraph_arg_t*)argPtr)->SDGdataPtr;
-
-    long myId = thread_getId();
-    long numThread = thread_getNumThread();
-
-    ULONGINT_T j;
-    ULONGINT_T maxNumVertices = 0;
-    ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
-
-    /*
-     * First determine the number of vertices by scanning the tuple
-     * startVertex list
-     */
-
-    long i;
-    long i_start;
-    long i_stop;
-    createPartition(0, numEdgesPlaced, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        if (SDGdataPtr->startVertex[i] > maxNumVertices) {
-            maxNumVertices = SDGdataPtr->startVertex[i];
-        }
-    }
-
-    TM_BEGIN();
-    long tmp_maxNumVertices = (long)TM_SHARED_READ(global_maxNumVertices);
-    long new_maxNumVertices = MAX(tmp_maxNumVertices, maxNumVertices) + 1;
-    TM_SHARED_WRITE(global_maxNumVertices, new_maxNumVertices);
-    TM_END();
-
-    thread_barrier_wait();
-
-    maxNumVertices = XTM_LOCKABLE_VALUE(global_maxNumVertices);
-
-    if (myId == 0) {
-
-        GPtr->numVertices = maxNumVertices;
-        GPtr->numEdges    = numEdgesPlaced;
-        GPtr->intWeight   = SDGdataPtr->intWeight;
-        GPtr->strWeight   = SDGdataPtr->strWeight;
-
-        for (i = 0; i < numEdgesPlaced; i++) {
-            if (GPtr->intWeight[numEdgesPlaced-i-1] < 0) {
-                GPtr->numStrEdges = -(GPtr->intWeight[numEdgesPlaced-i-1]) + 1;
-                GPtr->numIntEdges = numEdgesPlaced - GPtr->numStrEdges;
-                break;
-            }
-        }
-
-        GPtr->outDegree =
-            (LONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(LONGINT_T));
-        assert(GPtr->outDegree);
-
-        GPtr->outVertexIndex =
-            (ULONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(ULONGINT_T));
-        assert(GPtr->outVertexIndex);
-    }
-
-    thread_barrier_wait();
-
-    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        GPtr->outDegree[i] = 0;
-        GPtr->outVertexIndex[i] = 0;
-    }
-
-    ULONGINT_T outVertexListSize = 0;
-
-    thread_barrier_wait();
-
-    ULONGINT_T i0 = -1UL;
-
-    for (i = i_start; i < i_stop; i++) {
-
-        ULONGINT_T k = i;
-        if ((outVertexListSize == 0) && (k != 0)) {
-            while (i0 == -1UL) {
-                for (j = 0; j < numEdgesPlaced; j++) {
-                    if (k == SDGdataPtr->startVertex[j]) {
-                        i0 = j;
-                        break;
-                    }
-
-                }
-                k--;
-            }
-        }
-
-        if ((outVertexListSize == 0) && (k == 0)) {
-            i0 = 0;
-        }
-
-        for (j = i0; j < numEdgesPlaced; j++) {
-            if (i == GPtr->numVertices-1) {
-                break;
-            }
-            if ((i != SDGdataPtr->startVertex[j])) {
-                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
-                    if (j-i0 >= 1) {
-                        outVertexListSize++;
-                        GPtr->outDegree[i]++;
-                        ULONGINT_T t;
-                        for (t = i0+1; t < j; t++) {
-                            if (SDGdataPtr->endVertex[t] !=
-                                SDGdataPtr->endVertex[t-1])
-                            {
-                                outVertexListSize++;
-                                GPtr->outDegree[i] = GPtr->outDegree[i]+1;
-                            }
-                        }
-                    }
-                }
-                i0 = j;
-                break;
-            }
-        }
-
-        if (i == GPtr->numVertices-1) {
-            if (numEdgesPlaced-i0 >= 0) {
-                outVertexListSize++;
-                GPtr->outDegree[i]++;
-                ULONGINT_T t;
-                for (t = i0+1; t < numEdgesPlaced; t++) {
-                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
-                        outVertexListSize++;
-                        GPtr->outDegree[i]++;
-                    }
-                }
-            }
-        }
-
-    } /* for i */
-
-    thread_barrier_wait();
-
-    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
-
-    // XXX For some reason, TinySTM does not generate the correct code
-    // for the summation below, just implement with atomic increment
-    __sync_fetch_and_add(&global_outVertexListSize, outVertexListSize);
-
-    thread_barrier_wait();
-
-    // XXX race
-    //TM_BEGIN();
-    //TM_SHARED_WRITE(
-    //    global_outVertexListSize,
-    //    ((long)TM_SHARED_READ(global_outVertexListSize) + outVertexListSize)
-    //);
-    //TM_END();
-
-    thread_barrier_wait();
-
-    outVertexListSize = global_outVertexListSize;
-
-    if (myId == 0) {
-        GPtr->numDirectedEdges = outVertexListSize;
-        GPtr->outVertexList =
-            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
-        assert(GPtr->outVertexList);
-        GPtr->paralEdgeIndex =
-            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
-        assert(GPtr->paralEdgeIndex);
-        GPtr->outVertexList[0] = SDGdataPtr->endVertex[0];
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Evaluate outVertexList
-     */
-
-    i0 = -1UL;
-
-    for (i = i_start; i < i_stop; i++) {
-
-        ULONGINT_T k = i;
-        while ((i0 == -1UL) && (k != 0)) {
-            for (j = 0; j < numEdgesPlaced; j++) {
-                if (k == SDGdataPtr->startVertex[j]) {
-                    i0 = j;
-                    break;
-                }
-            }
-            k--;
-        }
-
-        if ((i0 == -1) && (k == 0)) {
-            i0 = 0;
-        }
-
-        for (j = i0; j < numEdgesPlaced; j++) {
-            if (i == GPtr->numVertices-1) {
-                break;
-            }
-            if (i != SDGdataPtr->startVertex[j]) {
-                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
-                    if (j-i0 >= 1) {
-                        long ii = GPtr->outVertexIndex[i];
-                        ULONGINT_T r = 0;
-                        GPtr->paralEdgeIndex[ii] = i0;
-                        GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
-                        r++;
-                        ULONGINT_T t;
-                        for (t = i0+1; t < j; t++) {
-                            if (SDGdataPtr->endVertex[t] !=
-                                SDGdataPtr->endVertex[t-1])
-                            {
-                                GPtr->paralEdgeIndex[ii+r] = t;
-                                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
-                                r++;
-                            }
-                        }
-
-                    }
-                }
-                i0 = j;
-                break;
-            }
-        } /* for j */
-
-        if (i == GPtr->numVertices-1) {
-            ULONGINT_T r = 0;
-            if (numEdgesPlaced-i0 >= 0) {
-                long ii = GPtr->outVertexIndex[i];
-                GPtr->paralEdgeIndex[ii+r] = i0;
-                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
-                r++;
-                ULONGINT_T t;
-                for (t = i0+1; t < numEdgesPlaced; t++) {
-                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
-                        GPtr->paralEdgeIndex[ii+r] = t;
-                        GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
-                        r++;
-                    }
-                }
-            }
-        }
-
-    } /* for i */
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(SDGdataPtr->startVertex);
-        P_FREE(SDGdataPtr->endVertex);
-        GPtr->inDegree =
-            (LockableLong*)P_MALLOC(GPtr->numVertices * sizeof(LockableLong));
-        assert(GPtr->inDegree);
-        GPtr->inVertexIndex =
-            (ULONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T));
-        assert(GPtr->inVertexIndex);
-    }
-
-    thread_barrier_wait();
-
-    for (i = i_start; i < i_stop; i++) {
-        XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value) = 0;
-        XTM_LOCKABLE_INIT(GPtr->inDegree[i].value);
-        GPtr->inVertexIndex[i] = 0;
-    }
-
-    /* A temp. array to store the inplied edges */
-    LockableULong* impliedEdgeList;
-    if (myId == 0) {
-        impliedEdgeList = (LockableULong*)P_MALLOC(GPtr->numVertices
-                                                * MAX_CLUSTER_SIZE
-                                                * sizeof(LockableULong));
-        global_impliedEdgeList = impliedEdgeList;
-    }
-
-    thread_barrier_wait();
-
-    impliedEdgeList = global_impliedEdgeList;
-
-    createPartition(0,
-                    (GPtr->numVertices * MAX_CLUSTER_SIZE),
-                    myId,
-                    numThread,
-                    &i_start,
-                    &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        XTM_LOCKABLE_VALUE(impliedEdgeList[i].value1) = 0;
-        XTM_LOCKABLE_INIT(impliedEdgeList[i].value1);
-    }
-
-    /*
-     * An auxiliary array to store implied edges, in case we overshoot
-     * MAX_CLUSTER_SIZE
-     */
-
-    LockableULongPtr* auxArr;
-    if (myId == 0) {
-        auxArr = (LockableULongPtr*)P_MALLOC(GPtr->numVertices * sizeof(*auxArr));
-        assert(auxArr);
-        global_auxArr = auxArr;
-        for (i = 0; i < GPtr->numVertices; ++i) {
-            XTM_LOCKABLE_INIT(auxArr[i].value2);
-        }
-    }
-
-    thread_barrier_wait();
-
-    auxArr = global_auxArr;
-
-    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
-
-    for (i = i_start; i < i_stop; i++) {
-        /* Inspect adjacency list of vertex i */
-        for (j = GPtr->outVertexIndex[i];
-             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
-             j++)
-        {
-            ULONGINT_T v = GPtr->outVertexList[j];
-            ULONGINT_T k;
-            for (k = GPtr->outVertexIndex[v];
-                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
-                 k++)
-            {
-                if (GPtr->outVertexList[k] == i) {
-                    break;
-                }
-            }
-            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
-                TM_BEGIN();
-                /* Add i to the impliedEdgeList of v */
-                long inDegree = (long)TM_SHARED_READ(GPtr->inDegree[v].value);
-                TM_SHARED_WRITE(GPtr->inDegree[v].value, (inDegree + 1));
-                if (inDegree < MAX_CLUSTER_SIZE) {
-                    TM_SHARED_WRITE(impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree].value1,
-                                    i);
-                } else {
-                    /* Use auxiliary array to store the implied edge */
-                    /* Create an array if it's not present already */
-                    LockableULong* a = NULL;
-                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
-                        a = (LockableULong*)TM_MALLOC(MAX_CLUSTER_SIZE
-                                                   * sizeof(*a));
-                        assert(a);
-                        TM_SHARED_WRITE_P(auxArr[v].value2, a);
-                    } else {
-                        a = XTM_LOCKABLE_VALUE(auxArr[v].value2);
-                    }
-                    TM_SHARED_WRITE(a[inDegree % MAX_CLUSTER_SIZE].value1, i);
-                }
-                TM_END();
-            }
-        }
-    } /* for i */
-
-    thread_barrier_wait();
-
-    prefix_sums2(GPtr->inVertexIndex, GPtr->inDegree, GPtr->numVertices);
-
-    if (myId == 0) {
-        GPtr->numUndirectedEdges = GPtr->inVertexIndex[GPtr->numVertices-1]
-                                   + XTM_LOCKABLE_VALUE(GPtr->inDegree[GPtr->numVertices-1].value);
-        GPtr->inVertexList =
-            (ULONGINT_T *)P_MALLOC(GPtr->numUndirectedEdges * sizeof(ULONGINT_T));
-    }
-
-    thread_barrier_wait();
-
-    /*
-     * Create the inVertex List
-     */
-
-    for (i = i_start; i < i_stop; i++) {
-        for (j = GPtr->inVertexIndex[i];
-             j < (GPtr->inVertexIndex[i] + XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value));
-             j++)
-        {
-            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
-                GPtr->inVertexList[j] =
-                    XTM_LOCKABLE_VALUE(impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]].value1);
-            } else {
-                GPtr->inVertexList[j] =
-                    XTM_LOCKABLE_VALUE(XTM_LOCKABLE_VALUE(auxArr[i].value2)[(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE].value1);
-            }
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(impliedEdgeList);
-    }
-
-    for (i = i_start; i < i_stop; i++) {
-        if (XTM_LOCKABLE_VALUE(GPtr->inDegree[i].value) > MAX_CLUSTER_SIZE) {
-            TM_FREE(XTM_LOCKABLE_VALUE(auxArr[i].value2));
-        }
-    }
-
-    thread_barrier_wait();
-
-    if (myId == 0) {
-        P_FREE(auxArr);
-    }
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of computeGraph.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.cpp stamp-grun/ssca2/computeGraph.cpp
--- stamp-0.9.10/ssca2/computeGraph.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/ssca2/computeGraph.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,1061 @@
+/* =============================================================================
+ *
+ * computeGraph.c
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/WorkList/WorkList.h"
+extern "C" {
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "computeGraph.h"
+#include "createPartition.h"
+#include "defs.h"
+#include "globals.h"
+#include "thread.h"
+#include "utility.h"
+#include "tm.h"
+}
+#define ORIGINAL 0
+
+static ULONGINT_T*  global_p                 = NULL;
+static ULONGINT_T   global_maxNumVertices    = 0;
+static ULONGINT_T   global_outVertexListSize = 0;
+static ULONGINT_T*  global_impliedEdgeList   = NULL;
+static ULONGINT_T** global_auxArr            = NULL;
+
+
+struct Fn10 {
+    ULONGINT_T* result;
+    LONGINT_T* input;
+    ULONGINT_T arraySize;
+    ULONGINT_T* p;
+
+    Fn10(ULONGINT_T* _result, LONGINT_T* _input, ULONGINT_T _arraySize, ULONGINT_T* _p):
+      result(_result), input(_input), arraySize(_arraySize), p(_p) { }
+
+
+    void operator()(unsigned myId, unsigned numThread) {
+        long start;
+        long end;
+
+        long r = arraySize / numThread;
+        start = myId * r + 1;
+        end = (myId + 1) * r;
+        if (myId == (numThread - 1)) {
+            end = arraySize;
+        }
+
+        ULONGINT_T j;
+        for (j = start; j < end; j++) {
+            result[j] = input[j-1] + result[j-1];
+        }
+
+        p[NOSHARE(myId)] = result[end-1];
+    }
+};
+
+struct Fn11 {
+    ULONGINT_T* result;
+    LONGINT_T* input;
+    ULONGINT_T arraySize;
+    ULONGINT_T* p;
+
+    Fn11(ULONGINT_T* _result, LONGINT_T* _input, ULONGINT_T _arraySize, ULONGINT_T* _p):
+      result(_result), input(_input), arraySize(_arraySize), p(_p) { }
+
+
+    void operator()(unsigned myId, unsigned numThread) {
+        long start;
+        long end;
+
+        long r = arraySize / numThread;
+        start = myId * r + 1;
+        end = (myId + 1) * r;
+        if (myId == (numThread - 1)) {
+            end = arraySize;
+        }
+
+        if (myId > 0) {
+            ULONGINT_T add_value = p[NOSHARE(myId-1)];
+            for (ULONGINT_T j = start-1; j < end; j++) {
+                result[j] += add_value;
+            }
+        }
+    }
+};
+
+/* =============================================================================
+ * prefix_sums
+ * =============================================================================
+ */
+static void
+prefix_sums (ULONGINT_T* result, LONGINT_T* input, ULONGINT_T arraySize)
+{
+#if ORIGINAL
+    long myId = 0; //thread_getId();
+    long numThread = 1; //thread_getNumThread();
+#else
+    long myId = 0;
+    long numThread = Galois::getActiveThreads();
+#endif
+
+    ULONGINT_T* p = NULL;
+    if (myId == 0) {
+        p = (ULONGINT_T*)P_MALLOC(NOSHARE(numThread) * sizeof(ULONGINT_T));
+        assert(p);
+        global_p = p;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    p = global_p;
+
+    long start;
+    long end;
+
+    long r = arraySize / numThread;
+    start = myId * r + 1;
+    end = (myId + 1) * r;
+    if (myId == (numThread - 1)) {
+        end = arraySize;
+    }
+
+    ULONGINT_T j;
+    for (j = start; j < end; j++) {
+        result[j] = input[j-1] + result[j-1];
+    }
+
+    p[NOSHARE(myId)] = result[end-1];
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn10(result, input, arraySize, p));
+#endif
+
+    if (myId == 0) {
+        for (ULONGINT_T j = 1; j < numThread; j++) {
+            p[NOSHARE(j)] += p[NOSHARE(j-1)];
+        }
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    if (myId > 0) {
+        ULONGINT_T add_value = p[NOSHARE(myId-1)];
+        for (j = start-1; j < end; j++) {
+            result[j] += add_value;
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn11(result, input, arraySize, p));
+#endif
+
+    if (myId == 0) {
+        P_FREE(p);
+    }
+}
+
+
+struct Fn1 {
+    graphSDG* SDGdataPtr;
+    Galois::GReduceMax<long>& accum;
+
+    Fn1(
+      graphSDG* _SDGdataPtr,
+      Galois::GReduceMax<long>& _accum):
+    SDGdataPtr(_SDGdataPtr),
+    accum(_accum) { }
+
+    void operator()(long i) {
+        accum.update(SDGdataPtr->startVertex[i]);
+    }
+};
+
+
+struct Fn2 {
+    graph* GPtr;
+
+    Fn2(
+        graph* _GPtr): GPtr(_GPtr) { }
+
+    void operator()(long i) {
+          GPtr->outDegree[i] = 0;
+          GPtr->outVertexIndex[i] = 0;
+    }
+};
+
+struct Fn3 {
+    Galois::GAccumulator<long>& accumOutVertexListSize;
+    graph* GPtr;
+    graphSDG* SDGdataPtr;
+
+    Fn3(
+    Galois::GAccumulator<long>& _accumOutVertexListSize,
+    graph* _GPtr,
+    graphSDG* _SDGdataPtr
+    ):
+    accumOutVertexListSize(_accumOutVertexListSize),
+    GPtr(_GPtr),
+    SDGdataPtr(_SDGdataPtr) { }
+
+    void operator()(unsigned myId, unsigned numThread) {
+        ULONGINT_T outVertexListSize = 0;
+        ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+        long i_start, i_stop;
+        createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+        ULONGINT_T i0 = -1UL;
+
+        for (long i = i_start; i < i_stop; i++) {
+            ULONGINT_T k = i;
+            if ((outVertexListSize == 0) && (k != 0)) {
+                while (i0 == -1UL) {
+                    for (ULONGINT_T j = 0; j < numEdgesPlaced; j++) {
+                        if (k == SDGdataPtr->startVertex[j]) {
+                            i0 = j;
+                            break;
+                        }
+
+                    }
+                    k--;
+                }
+            }
+
+            if ((outVertexListSize == 0) && (k == 0)) {
+                i0 = 0;
+            }
+
+            for (ULONGINT_T j = i0; j < numEdgesPlaced; j++) {
+                if (i == GPtr->numVertices-1) {
+                    break;
+                }
+                if ((i != SDGdataPtr->startVertex[j])) {
+                    if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                        if (j-i0 >= 1) {
+                            outVertexListSize++;
+                            GPtr->outDegree[i]++;
+                            ULONGINT_T t;
+                            for (t = i0+1; t < j; t++) {
+                                if (SDGdataPtr->endVertex[t] !=
+                                    SDGdataPtr->endVertex[t-1])
+                                {
+                                    outVertexListSize++;
+                                    GPtr->outDegree[i] = GPtr->outDegree[i]+1;
+                                }
+                            }
+                        }
+                    }
+                    i0 = j;
+                    break;
+                }
+            }
+
+            if (i == GPtr->numVertices-1) {
+                if (numEdgesPlaced-i0 >= 0) {
+                    outVertexListSize++;
+                    GPtr->outDegree[i]++;
+                    ULONGINT_T t;
+                    for (t = i0+1; t < numEdgesPlaced; t++) {
+                        if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                            outVertexListSize++;
+                            GPtr->outDegree[i]++;
+                        }
+                    }
+                }
+            }
+        } /* for i */
+
+        accumOutVertexListSize.update(outVertexListSize);
+    }
+};
+
+struct Fn4 {
+    graph* GPtr;
+    graphSDG* SDGdataPtr;
+
+    Fn4(
+    graph* _GPtr,
+    graphSDG* _SDGdataPtr
+    ):
+    GPtr(_GPtr),
+    SDGdataPtr(_SDGdataPtr) { }
+
+    void operator()(unsigned myId, unsigned numThread) {
+        ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+        long i_start, i_stop;
+        createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+        ULONGINT_T i0 = -1UL;
+        for (long i = i_start; i < i_stop; i++) {
+
+            ULONGINT_T k = i;
+            while ((i0 == -1UL) && (k != 0)) {
+                for (ULONGINT_T j = 0; j < numEdgesPlaced; j++) {
+                    if (k == SDGdataPtr->startVertex[j]) {
+                        i0 = j;
+                        break;
+                    }
+                }
+                k--;
+            }
+
+            if ((i0 == -1) && (k == 0)) {
+                i0 = 0;
+            }
+
+            for (ULONGINT_T j = i0; j < numEdgesPlaced; j++) {
+                if (i == GPtr->numVertices-1) {
+                    break;
+                }
+                if (i != SDGdataPtr->startVertex[j]) {
+                    if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                        if (j-i0 >= 1) {
+                            long ii = GPtr->outVertexIndex[i];
+                            ULONGINT_T r = 0;
+                            GPtr->paralEdgeIndex[ii] = i0;
+                            GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
+                            r++;
+                            ULONGINT_T t;
+                            for (t = i0+1; t < j; t++) {
+                                if (SDGdataPtr->endVertex[t] !=
+                                    SDGdataPtr->endVertex[t-1])
+                                {
+                                    GPtr->paralEdgeIndex[ii+r] = t;
+                                    GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                                    r++;
+                                }
+                            }
+
+                        }
+                    }
+                    i0 = j;
+                    break;
+                }
+            } /* for j */
+
+            if (i == GPtr->numVertices-1) {
+                ULONGINT_T r = 0;
+                if (numEdgesPlaced-i0 >= 0) {
+                    long ii = GPtr->outVertexIndex[i];
+                    GPtr->paralEdgeIndex[ii+r] = i0;
+                    GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
+                    r++;
+                    ULONGINT_T t;
+                    for (t = i0+1; t < numEdgesPlaced; t++) {
+                        if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                            GPtr->paralEdgeIndex[ii+r] = t;
+                            GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                            r++;
+                        }
+                    }
+                }
+            }
+        } /* for i */
+    }
+};
+
+struct Fn5 {
+    graph* GPtr;
+
+    Fn5(
+        graph* _GPtr): GPtr(_GPtr) { }
+
+    void operator()(long i) {
+          GPtr->inDegree[i] = 0;
+          GPtr->inVertexIndex[i] = 0;
+    }
+};
+
+struct Fn6 {
+    ULONGINT_T* impliedEdgeList;
+
+    Fn6(
+    ULONGINT_T* _impliedEdgeList
+    ):
+    impliedEdgeList(_impliedEdgeList) { }
+
+    void operator()(long i) {
+        impliedEdgeList[i] = 0;
+    }
+};
+
+struct Fn7 {
+    graph* GPtr;
+    ULONGINT_T** auxArr;
+    ULONGINT_T* impliedEdgeList;
+    Galois::Runtime::Lockable* locks;
+    Galois::Runtime::MM::FixedSizeAllocator heap;
+
+    Fn7(
+    graph* _GPtr,
+    ULONGINT_T** _auxArr,
+    ULONGINT_T* _impliedEdgeList,
+    Galois::Runtime::Lockable* _locks
+       ): 
+    GPtr(_GPtr),
+    auxArr(_auxArr),
+    impliedEdgeList(_impliedEdgeList),
+    locks(_locks),
+    heap(MAX_CLUSTER_SIZE * sizeof(ULONGINT_T))
+    { }
+
+    void operator()(long i, Galois::UserContext<long>& ctx) {
+        for (ULONGINT_T j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+#ifndef HTM
+            Galois::Runtime::acquire(&locks[v], Galois::MethodFlag::ALL);
+#endif
+        }
+
+        /* Inspect adjacency list of vertex i */
+        for (ULONGINT_T j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+            ULONGINT_T k;
+            for (k = GPtr->outVertexIndex[v];
+                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
+                 k++)
+            {
+                if (GPtr->outVertexList[k] == i) {
+                    break;
+                }
+            }
+            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
+                /* Add i to the impliedEdgeList of v */
+                long inDegree = GPtr->inDegree[v];
+                GPtr->inDegree[v] = inDegree + 1;
+                if (inDegree < MAX_CLUSTER_SIZE) {
+                    impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree] = i;
+                } else {
+                    /* Use auxiliary array to store the implied edge */
+                    /* Create an array if it's not present already */
+                    ULONGINT_T* a = NULL;
+                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
+                        
+                        a = (ULONGINT_T*) heap.allocate(MAX_CLUSTER_SIZE
+                                                   * sizeof(ULONGINT_T));
+                        assert(a);
+                        auxArr[v] = a;
+                    } else {
+                        a = auxArr[v];
+                    }
+                    a[inDegree % MAX_CLUSTER_SIZE] = i;
+                }
+            }
+        }
+    }
+};
+
+struct Fn8 {
+    graph* GPtr;
+    ULONGINT_T* impliedEdgeList;
+    ULONGINT_T** auxArr;
+
+    Fn8(
+    graph* _GPtr,
+    ULONGINT_T* _impliedEdgeList,
+    ULONGINT_T** _auxArr
+       ):
+    GPtr(_GPtr),
+    impliedEdgeList(_impliedEdgeList),
+    auxArr(_auxArr) { }
+
+    void operator()(long i) {
+        for (ULONGINT_T j = GPtr->inVertexIndex[i];
+             j < (GPtr->inVertexIndex[i] + GPtr->inDegree[i]);
+             j++)
+        {
+            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
+                GPtr->inVertexList[j] =
+                    impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]];
+            } else {
+                GPtr->inVertexList[j] =
+                    auxArr[i][(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE];
+            }
+        }
+    }
+};
+
+struct Fn9 {
+    graph* GPtr;
+    ULONGINT_T* impliedEdgeList;
+    ULONGINT_T** auxArr;
+    Galois::Runtime::MM::FixedSizeAllocator heap;
+
+    Fn9(
+    graph* _GPtr,
+    ULONGINT_T** _auxArr
+       ):
+    GPtr(_GPtr),
+    auxArr(_auxArr),
+    heap(MAX_CLUSTER_SIZE * sizeof(ULONGINT_T))
+  { }
+
+    void operator()(long i) {
+        if (GPtr->inDegree[i] > MAX_CLUSTER_SIZE) {
+            heap.deallocate(auxArr[i]);
+        }
+    }
+};
+
+struct Fn13 {
+    Galois::Runtime::Lockable* locks;
+
+    Fn13(Galois::Runtime::Lockable* _locks): locks(_locks) { }
+
+    void operator()(long i) {
+        new (&locks[i]) Galois::Runtime::Lockable();
+    }
+};
+
+/* =============================================================================
+ * computeGraph
+ * =============================================================================
+ */
+void
+computeGraph (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    graph*    GPtr       = ((computeGraph_arg_t*)argPtr)->GPtr;
+    graphSDG* SDGdataPtr = ((computeGraph_arg_t*)argPtr)->SDGdataPtr;
+
+#if ORIGINAL
+    long myId = 0; //thread_getId();
+    long numThread = 1; //thread_getNumThread();
+#else
+    long myId = 0;
+#endif
+
+    ULONGINT_T j;
+    ULONGINT_T maxNumVertices = 0;
+    ULONGINT_T numEdgesPlaced = SDGdataPtr->numEdgesPlaced;
+
+    /*
+     * First determine the number of vertices by scanning the tuple
+     * startVertex list
+     */
+
+    long i;
+    long i_start;
+    long i_stop;
+#if ORIGINAL
+    createPartition(0, numEdgesPlaced, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        if (SDGdataPtr->startVertex[i] > maxNumVertices) {
+            maxNumVertices = SDGdataPtr->startVertex[i];
+        }
+    }
+
+    TM_BEGIN();
+    long tmp_maxNumVertices = (long)TM_SHARED_READ(global_maxNumVertices);
+    long new_maxNumVertices = (tmp_maxNumVertices > maxNumVertices ? tmp_maxNumVertices : maxNumVertices) + 1; //MAX(tmp_maxNumVertices, maxNumVertices) + 1;
+    TM_SHARED_WRITE(global_maxNumVertices, new_maxNumVertices);
+    TM_END();
+
+    thread_barrier_wait();
+
+    maxNumVertices = global_maxNumVertices;
+#else
+    Galois::GReduceMax<long> accumMaxNumVertices;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(numEdgesPlaced),
+        Fn1(SDGdataPtr, accumMaxNumVertices));
+    maxNumVertices = accumMaxNumVertices.reduce() + 1;
+#endif
+    if (myId == 0) {
+
+        GPtr->numVertices = maxNumVertices;
+        GPtr->numEdges    = numEdgesPlaced;
+        GPtr->intWeight   = SDGdataPtr->intWeight;
+        GPtr->strWeight   = SDGdataPtr->strWeight;
+
+        for (long i = 0; i < numEdgesPlaced; i++) {
+            if (GPtr->intWeight[numEdgesPlaced-i-1] < 0) {
+                GPtr->numStrEdges = -(GPtr->intWeight[numEdgesPlaced-i-1]) + 1;
+                GPtr->numIntEdges = numEdgesPlaced - GPtr->numStrEdges;
+                break;
+            }
+        }
+
+        GPtr->outDegree =
+            (LONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(LONGINT_T));
+        assert(GPtr->outDegree);
+
+        GPtr->outVertexIndex =
+            (ULONGINT_T*)P_MALLOC((GPtr->numVertices) * sizeof(ULONGINT_T));
+        assert(GPtr->outVertexIndex);
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        GPtr->outDegree[i] = 0;
+        GPtr->outVertexIndex[i] = 0;
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn2(GPtr));
+#endif
+
+#if ORIGINAL
+    ULONGINT_T outVertexListSize = 0;
+
+    thread_barrier_wait();
+
+    ULONGINT_T i0 = -1UL;
+
+    for (i = i_start; i < i_stop; i++) {
+
+        ULONGINT_T k = i;
+        if ((outVertexListSize == 0) && (k != 0)) {
+            while (i0 == -1UL) {
+                for (j = 0; j < numEdgesPlaced; j++) {
+                    if (k == SDGdataPtr->startVertex[j]) {
+                        i0 = j;
+                        break;
+                    }
+
+                }
+                k--;
+            }
+        }
+
+        if ((outVertexListSize == 0) && (k == 0)) {
+            i0 = 0;
+        }
+
+        for (j = i0; j < numEdgesPlaced; j++) {
+            if (i == GPtr->numVertices-1) {
+                break;
+            }
+            if ((i != SDGdataPtr->startVertex[j])) {
+                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                    if (j-i0 >= 1) {
+                        outVertexListSize++;
+                        GPtr->outDegree[i]++;
+                        ULONGINT_T t;
+                        for (t = i0+1; t < j; t++) {
+                            if (SDGdataPtr->endVertex[t] !=
+                                SDGdataPtr->endVertex[t-1])
+                            {
+                                outVertexListSize++;
+                                GPtr->outDegree[i] = GPtr->outDegree[i]+1;
+                            }
+                        }
+                    }
+                }
+                i0 = j;
+                break;
+            }
+        }
+
+        if (i == GPtr->numVertices-1) {
+            if (numEdgesPlaced-i0 >= 0) {
+                outVertexListSize++;
+                GPtr->outDegree[i]++;
+                ULONGINT_T t;
+                for (t = i0+1; t < numEdgesPlaced; t++) {
+                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                        outVertexListSize++;
+                        GPtr->outDegree[i]++;
+                    }
+                }
+            }
+        }
+
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    Galois::GAccumulator<long> accumOutVertexListSize;
+    Galois::on_each(Fn3(accumOutVertexListSize, GPtr, SDGdataPtr));
+
+    ULONGINT_T outVertexListSize = accumOutVertexListSize.reduce();
+#endif
+
+#if ORIGINAL
+    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
+
+    //thread_barrier_wait();
+
+    TM_BEGIN();
+    TM_SHARED_WRITE(
+        global_outVertexListSize,
+        ((long)TM_SHARED_READ(global_outVertexListSize) + outVertexListSize)
+    );
+    TM_END();
+
+    thread_barrier_wait();
+
+    outVertexListSize = global_outVertexListSize;
+#else
+    prefix_sums(GPtr->outVertexIndex, GPtr->outDegree, GPtr->numVertices);
+#endif
+    if (myId == 0) {
+        GPtr->numDirectedEdges = outVertexListSize;
+        GPtr->outVertexList =
+            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
+        assert(GPtr->outVertexList);
+        GPtr->paralEdgeIndex =
+            (ULONGINT_T*)P_MALLOC(outVertexListSize * sizeof(ULONGINT_T));
+        assert(GPtr->paralEdgeIndex);
+        GPtr->outVertexList[0] = SDGdataPtr->endVertex[0];
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    /*
+     * Evaluate outVertexList
+     */
+
+    i0 = -1UL;
+
+    for (i = i_start; i < i_stop; i++) {
+
+        ULONGINT_T k = i;
+        while ((i0 == -1UL) && (k != 0)) {
+            for (j = 0; j < numEdgesPlaced; j++) {
+                if (k == SDGdataPtr->startVertex[j]) {
+                    i0 = j;
+                    break;
+                }
+            }
+            k--;
+        }
+
+        if ((i0 == -1) && (k == 0)) {
+            i0 = 0;
+        }
+
+        for (j = i0; j < numEdgesPlaced; j++) {
+            if (i == GPtr->numVertices-1) {
+                break;
+            }
+            if (i != SDGdataPtr->startVertex[j]) {
+                if ((j > 0) && (i == SDGdataPtr->startVertex[j-1])) {
+                    if (j-i0 >= 1) {
+                        long ii = GPtr->outVertexIndex[i];
+                        ULONGINT_T r = 0;
+                        GPtr->paralEdgeIndex[ii] = i0;
+                        GPtr->outVertexList[ii] = SDGdataPtr->endVertex[i0];
+                        r++;
+                        ULONGINT_T t;
+                        for (t = i0+1; t < j; t++) {
+                            if (SDGdataPtr->endVertex[t] !=
+                                SDGdataPtr->endVertex[t-1])
+                            {
+                                GPtr->paralEdgeIndex[ii+r] = t;
+                                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                                r++;
+                            }
+                        }
+
+                    }
+                }
+                i0 = j;
+                break;
+            }
+        } /* for j */
+
+        if (i == GPtr->numVertices-1) {
+            ULONGINT_T r = 0;
+            if (numEdgesPlaced-i0 >= 0) {
+                long ii = GPtr->outVertexIndex[i];
+                GPtr->paralEdgeIndex[ii+r] = i0;
+                GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[i0];
+                r++;
+                ULONGINT_T t;
+                for (t = i0+1; t < numEdgesPlaced; t++) {
+                    if (SDGdataPtr->endVertex[t] != SDGdataPtr->endVertex[t-1]) {
+                        GPtr->paralEdgeIndex[ii+r] = t;
+                        GPtr->outVertexList[ii+r] = SDGdataPtr->endVertex[t];
+                        r++;
+                    }
+                }
+            }
+        }
+
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    Galois::on_each(Fn4(GPtr, SDGdataPtr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(SDGdataPtr->startVertex);
+        P_FREE(SDGdataPtr->endVertex);
+        GPtr->inDegree =
+            (LONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(LONGINT_T));
+        assert(GPtr->inDegree);
+        GPtr->inVertexIndex =
+            (ULONGINT_T*)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T));
+        assert(GPtr->inVertexIndex);
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    for (i = i_start; i < i_stop; i++) {
+        GPtr->inDegree[i] = 0;
+        GPtr->inVertexIndex[i] = 0;
+    }
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn5(GPtr));
+#endif
+
+    /* A temp. array to store the inplied edges */
+    ULONGINT_T* impliedEdgeList;
+    if (myId == 0) {
+        impliedEdgeList = (ULONGINT_T*)P_MALLOC(GPtr->numVertices
+                                                * MAX_CLUSTER_SIZE
+                                                * sizeof(ULONGINT_T));
+        global_impliedEdgeList = impliedEdgeList;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    impliedEdgeList = global_impliedEdgeList;
+
+    createPartition(0,
+                    (GPtr->numVertices * MAX_CLUSTER_SIZE),
+                    myId,
+                    numThread,
+                    &i_start,
+                    &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        impliedEdgeList[i] = 0;
+    }
+#else
+    impliedEdgeList = global_impliedEdgeList;
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices * MAX_CLUSTER_SIZE),
+        Fn6(impliedEdgeList));
+#endif
+    /*
+     * An auxiliary array to store implied edges, in case we overshoot
+     * MAX_CLUSTER_SIZE
+     */
+
+    ULONGINT_T** auxArr;
+    if (myId == 0) {
+        auxArr = (ULONGINT_T**)P_MALLOC(GPtr->numVertices * sizeof(ULONGINT_T*));
+        assert(auxArr);
+        global_auxArr = auxArr;
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    auxArr = global_auxArr;
+
+    createPartition(0, GPtr->numVertices, myId, numThread, &i_start, &i_stop);
+
+    for (i = i_start; i < i_stop; i++) {
+        /* Inspect adjacency list of vertex i */
+        for (j = GPtr->outVertexIndex[i];
+             j < (GPtr->outVertexIndex[i] + GPtr->outDegree[i]);
+             j++)
+        {
+            ULONGINT_T v = GPtr->outVertexList[j];
+            ULONGINT_T k;
+            for (k = GPtr->outVertexIndex[v];
+                 k < (GPtr->outVertexIndex[v] + GPtr->outDegree[v]);
+                 k++)
+            {
+                if (GPtr->outVertexList[k] == i) {
+                    break;
+                }
+            }
+            if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
+                TM_BEGIN();
+                /* Add i to the impliedEdgeList of v */
+                long inDegree = (long)TM_SHARED_READ(GPtr->inDegree[v]);
+                TM_SHARED_WRITE(GPtr->inDegree[v], (inDegree + 1));
+                if (inDegree < MAX_CLUSTER_SIZE) {
+                    TM_SHARED_WRITE(impliedEdgeList[v*MAX_CLUSTER_SIZE+inDegree],
+                                    i);
+                } else {
+                    /* Use auxiliary array to store the implied edge */
+                    /* Create an array if it's not present already */
+                    ULONGINT_T* a = NULL;
+                    if ((inDegree % MAX_CLUSTER_SIZE) == 0) {
+                        a = (ULONGINT_T*)TM_MALLOC(MAX_CLUSTER_SIZE
+                                                   * sizeof(ULONGINT_T));
+                        assert(a);
+                        TM_SHARED_WRITE_P(auxArr[v], a);
+                    } else {
+                        a = auxArr[v];
+                    }
+                    TM_SHARED_WRITE(a[inDegree % MAX_CLUSTER_SIZE], i);
+                }
+                TM_END();
+            }
+        }
+    } /* for i */
+
+    thread_barrier_wait();
+#else
+    auxArr = global_auxArr;
+    Galois::Runtime::Lockable* locks = NULL;
+#ifndef HTM
+    locks = (Galois::Runtime::Lockable*) P_MALLOC(sizeof(*locks) * GPtr->numVertices);
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+      Fn13(locks));
+#endif
+    Galois::for_each(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn7(GPtr, auxArr, impliedEdgeList, locks), Galois::wl<Galois::WorkList::StableIterator<boost::counting_iterator<long>>>());
+
+    if (locks)
+        P_FREE(locks);
+#endif
+
+    prefix_sums(GPtr->inVertexIndex, GPtr->inDegree, GPtr->numVertices);
+
+    if (myId == 0) {
+        GPtr->numUndirectedEdges = GPtr->inVertexIndex[GPtr->numVertices-1]
+                                   + GPtr->inDegree[GPtr->numVertices-1];
+        GPtr->inVertexList =
+            (ULONGINT_T *)P_MALLOC(GPtr->numUndirectedEdges * sizeof(ULONGINT_T));
+    }
+
+#if ORIGINAL
+    thread_barrier_wait();
+
+    /*
+     * Create the inVertex List
+     */
+
+    for (i = i_start; i < i_stop; i++) {
+        for (j = GPtr->inVertexIndex[i];
+             j < (GPtr->inVertexIndex[i] + GPtr->inDegree[i]);
+             j++)
+        {
+            if ((j - GPtr->inVertexIndex[i]) < MAX_CLUSTER_SIZE) {
+                GPtr->inVertexList[j] =
+                    impliedEdgeList[i*MAX_CLUSTER_SIZE+j-GPtr->inVertexIndex[i]];
+            } else {
+                GPtr->inVertexList[j] =
+                    auxArr[i][(j-GPtr->inVertexIndex[i]) % MAX_CLUSTER_SIZE];
+            }
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn8(GPtr, impliedEdgeList, auxArr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(impliedEdgeList);
+    }
+
+#if ORIGINAL
+    for (i = i_start; i < i_stop; i++) {
+        if (GPtr->inDegree[i] > MAX_CLUSTER_SIZE) {
+            P_FREE(auxArr[i]);
+        }
+    }
+
+    thread_barrier_wait();
+#else
+    Galois::do_all(boost::counting_iterator<long>(0), boost::counting_iterator<long>(GPtr->numVertices),
+        Fn9(GPtr, auxArr));
+#endif
+
+    if (myId == 0) {
+        P_FREE(auxArr);
+    }
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ *
+ * End of computeGraph.c
+ *
+ * =============================================================================
+ */
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/computeGraph.h stamp-grun/ssca2/computeGraph.h
--- stamp-0.9.10/ssca2/computeGraph.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/computeGraph.h	2017-03-20 15:19:45.000000000 +0000
@@ -70,6 +70,9 @@
 
 #include "defs.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct computeGragh_arg {
     graph* GPtr;
@@ -84,6 +87,9 @@
 void
 computeGraph (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COMPUTEGRAPH_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/defs.h stamp-grun/ssca2/defs.h
--- stamp-0.9.10/ssca2/defs.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/defs.h	2017-03-20 15:19:45.000000000 +0000
@@ -67,8 +67,6 @@
 #ifndef DEFS_H
 #define DEFS_H 1
 
-#include "tm.h"
-
 typedef unsigned long int  ULONGINT_T;
 typedef long int           LONGINT_T;
 typedef short int          SHORTINT_T;
@@ -94,10 +92,6 @@
 
 } graphSDG;
 
-typedef struct LockableLong {
-    XTM_DECL_LOCKABLE(LONGINT_T, value);
-} LockableLong;
-
 typedef struct /*the graph data structure*/
 {
     ULONGINT_T numVertices;
@@ -114,7 +108,7 @@
     ULONGINT_T* outVertexList;
     ULONGINT_T* paralEdgeIndex;
 
-    LockableLong*  inDegree;
+    LONGINT_T*  inDegree;
     ULONGINT_T* inVertexIndex;
     ULONGINT_T* inVertexList;
 
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/getStartLists.c stamp-grun/ssca2/getStartLists.c
--- stamp-0.9.10/ssca2/getStartLists.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/getStartLists.c	2017-03-20 15:19:45.000000000 +0000
@@ -77,7 +77,7 @@
 #include "tm.h"
 #include "utility.h"
 
-static XTM_DECL_LOCKABLE(LONGINT_T, global_maxWeight); //          = 0;
+static LONGINT_T global_maxWeight          = 0;
 static long*     global_i_edgeStartCounter = NULL;
 static long*     global_i_edgeEndCounter   = NULL;
 static edge*     global_maxIntWtList       = NULL;
@@ -128,7 +128,7 @@
 
     thread_barrier_wait();
 
-    maxWeight = XTM_LOCKABLE_VALUE(global_maxWeight);
+    maxWeight = global_maxWeight;
 
     /*
      * Create partial lists
diff -x .git -x inputs -Naur stamp-0.9.10/ssca2/ssca2.c stamp-grun/ssca2/ssca2.c
--- stamp-0.9.10/ssca2/ssca2.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/ssca2/ssca2.c	2017-03-20 15:19:45.000000000 +0000
@@ -171,14 +171,7 @@
 
 #ifdef USE_PARALLEL_DATA_GENERATION
     GOTO_SIM();
-#ifdef OTM
-#pragma omp parallel
-    {
-        genScalData((void*)SDGdata);
-    }
-#else
-    thread_start(genScalData, (void*)SDGdata);
-#endif
+    genScalData((void*)SDGdata);
     GOTO_REAL();
 #else /* !USE_PARALLEL_DATA_GENERATION */
     genScalData_seq(SDGdata);
@@ -212,22 +205,15 @@
     computeGraphArgs.GPtr       = G;
     computeGraphArgs.SDGdataPtr = SDGdata;
 
-    TIMER_READ(start);
 
     GOTO_SIM();
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        computeGraph((void*)&computeGraphArgs);
-    }
-#else
-    thread_start(computeGraph, (void*)&computeGraphArgs);
-#endif
+    TIMER_READ(start);
+    computeGraph((void*)&computeGraphArgs);
+    TIMER_READ(stop);
     thread_end_timing();
     GOTO_REAL();
 
-    TIMER_READ(stop);
 
     time = TIMER_DIFF_SECONDS(start, stop);
     totalTime += time;
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/CMakeLists.txt stamp-grun/vacation/CMakeLists.txt
--- stamp-0.9.10/vacation/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/CMakeLists.txt	2017-03-21 18:34:21.000000000 +0000
@@ -7,17 +7,17 @@
 add_definitions(-DLIST_NO_DUPLICATES -DMAP_USE_RBTREE)
 
 set(sources
-	client.c 
+	client.cpp 
 	customer.c 
 	manager.c 
-	reservation.c 
+	reservation.c
 	vacation.c 
 	${LIB_DIR}/list.c 
 	${LIB_DIR}/pair.c 
 	${LIB_DIR}/mt19937ar.c 
 	${LIB_DIR}/random.c 
 	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c)
+	${LIB_DIR}/thread.cpp)
 
 app(vacation ${sources})
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/action.h stamp-grun/vacation/action.h
--- stamp-0.9.10/vacation/action.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/action.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef ACTION_H
 #define ACTION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef enum action {
     ACTION_MAKE_RESERVATION = 0,
@@ -80,6 +83,10 @@
     NUM_ACTION
 } action_t;
 
+#ifdef __cplusplus
+}
+#endif
+
 
 #endif /* ACTION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.c stamp-grun/vacation/client.c
--- stamp-0.9.10/vacation/client.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/client.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,327 +0,0 @@
-/* =============================================================================
- *
- * client.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include "action.h"
-#include "client.h"
-#include "manager.h"
-#include "reservation.h"
-#include "thread.h"
-#include "types.h"
-
-
-/* =============================================================================
- * client_alloc
- * -- Returns NULL on failure
- * =============================================================================
- */
-client_t*
-client_alloc (long id,
-              manager_t* managerPtr,
-              long numOperation,
-              long numQueryPerTransaction,
-              long queryRange,
-              long percentUser)
-{
-    client_t* clientPtr;
-
-    clientPtr = (client_t*)malloc(sizeof(client_t));
-    if (clientPtr == NULL) {
-        return NULL;
-    }
-
-    clientPtr->randomPtr = random_alloc();
-    if (clientPtr->randomPtr == NULL) {
-        return NULL;
-    }
-
-    clientPtr->id = id;
-    clientPtr->managerPtr = managerPtr;
-    random_seed(clientPtr->randomPtr, id);
-    clientPtr->numOperation = numOperation;
-    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
-    clientPtr->queryRange = queryRange;
-    clientPtr->percentUser = percentUser;
-
-    return clientPtr;
-}
-
-
-/* =============================================================================
- * client_free
- * =============================================================================
- */
-void
-client_free (client_t* clientPtr)
-{
-    free(clientPtr);
-}
-
-
-/* =============================================================================
- * selectAction
- * =============================================================================
- */
-static action_t
-selectAction (long r, long percentUser)
-{
-    action_t action;
-
-    if (r < percentUser) {
-        action = ACTION_MAKE_RESERVATION;
-    } else if (r & 1) {
-        action = ACTION_DELETE_CUSTOMER;
-    } else {
-        action = ACTION_UPDATE_TABLES;
-    }
-
-    return action;
-}
-
-
-/* =============================================================================
- * client_run
- * -- Execute list operations on the database
- * =============================================================================
- */
-void
-client_run (void* argPtr)
-{
-    TM_THREAD_ENTER();
-
-    long myId = thread_getId();
-    client_t* clientPtr = ((client_t**)argPtr)[myId];
-
-    manager_t* managerPtr = clientPtr->managerPtr;
-    random_t*  randomPtr  = clientPtr->randomPtr;
-
-    long numOperation           = clientPtr->numOperation;
-    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
-    long queryRange             = clientPtr->queryRange;
-    long percentUser            = clientPtr->percentUser;
-
-    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
-
-    long i;
-
-    for (i = 0; i < numOperation; i++) {
-
-        long r = random_generate(randomPtr) % 100;
-        action_t action = selectAction(r, percentUser);
-
-        switch (action) {
-
-            case ACTION_MAKE_RESERVATION: {
-                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
-                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
-                long n;
-                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
-                long customerId = random_generate(randomPtr) % queryRange + 1;
-                for (n = 0; n < numQuery; n++) {
-                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
-                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
-                }
-                bool_t isFound = FALSE;
-                TM_BEGIN();
-                for (n = 0; n < numQuery; n++) {
-                    long t = types[n];
-                    long id = ids[n];
-                    long price = -1;
-                    switch (t) {
-                        case RESERVATION_CAR:
-                            if (MANAGER_QUERY_CAR(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
-                            }
-                            break;
-                        case RESERVATION_FLIGHT:
-                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
-                            }
-                            break;
-                        case RESERVATION_ROOM:
-                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
-                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
-                            }
-                            break;
-                        default:
-                            assert(0);
-                    }
-                    if (price > maxPrices[t]) {
-                        maxPrices[t] = price;
-                        maxIds[t] = id;
-                        isFound = TRUE;
-                    }
-                } /* for n */
-                if (isFound) {
-                    MANAGER_ADD_CUSTOMER(managerPtr, customerId);
-                }
-                if (maxIds[RESERVATION_CAR] > 0) {
-                    MANAGER_RESERVE_CAR(managerPtr,
-                                        customerId, maxIds[RESERVATION_CAR]);
-                }
-                if (maxIds[RESERVATION_FLIGHT] > 0) {
-                    MANAGER_RESERVE_FLIGHT(managerPtr,
-                                           customerId, maxIds[RESERVATION_FLIGHT]);
-                }
-                if (maxIds[RESERVATION_ROOM] > 0) {
-                    MANAGER_RESERVE_ROOM(managerPtr,
-                                         customerId, maxIds[RESERVATION_ROOM]);
-                }
-                TM_END();
-                break;
-            }
-
-            case ACTION_DELETE_CUSTOMER: {
-                long customerId = random_generate(randomPtr) % queryRange + 1;
-                TM_BEGIN();
-                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
-                if (bill >= 0) {
-                    MANAGER_DELETE_CUSTOMER(managerPtr, customerId);
-                }
-                TM_END();
-                break;
-            }
-
-            case ACTION_UPDATE_TABLES: {
-                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
-                long n;
-                for (n = 0; n < numUpdate; n++) {
-                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
-                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
-                    ops[n] = random_generate(randomPtr) % 2;
-                    if (ops[n]) {
-                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
-                    }
-                }
-                TM_BEGIN();
-                for (n = 0; n < numUpdate; n++) {
-                    long t = types[n];
-                    long id = ids[n];
-                    long doAdd = ops[n];
-                    if (doAdd) {
-                        long newPrice = prices[n];
-                        switch (t) {
-                            case RESERVATION_CAR:
-                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
-                                break;
-                            case RESERVATION_FLIGHT:
-                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
-                                break;
-                            case RESERVATION_ROOM:
-                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
-                                break;
-                            default:
-                                assert(0);
-                        }
-                    } else { /* do delete */
-                        switch (t) {
-                            case RESERVATION_CAR:
-                                MANAGER_DELETE_CAR(managerPtr, id, 100);
-                                break;
-                            case RESERVATION_FLIGHT:
-                                MANAGER_DELETE_FLIGHT(managerPtr, id);
-                                break;
-                            case RESERVATION_ROOM:
-                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
-                                break;
-                            default:
-                                assert(0);
-                        }
-                    }
-                }
-                TM_END();
-                break;
-            }
-
-            default:
-                assert(0);
-
-        } /* switch (action) */
-
-    } /* for i */
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- *
- * End of client.c
- *
- * =============================================================================
- */
-
-
-
-
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.cpp stamp-grun/vacation/client.cpp
--- stamp-0.9.10/vacation/client.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/vacation/client.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,379 @@
+/* =============================================================================
+ *
+ * client.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include "action.h"
+#include "client.h"
+#include "manager.h"
+#include "reservation.h"
+#include "thread.h"
+#include "types.h"
+
+
+/* =============================================================================
+ * client_alloc
+ * -- Returns NULL on failure
+ * =============================================================================
+ */
+client_t*
+client_alloc (long id,
+              manager_t* managerPtr,
+              long numOperation,
+              long numQueryPerTransaction,
+              long queryRange,
+              long percentUser)
+{
+    client_t* clientPtr;
+
+    clientPtr = (client_t*)malloc(sizeof(client_t));
+    if (clientPtr == NULL) {
+        return NULL;
+    }
+
+    clientPtr->randomPtr = NULL;
+
+    clientPtr->id = id;
+    clientPtr->managerPtr = managerPtr;
+    clientPtr->numOperation = numOperation;
+    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
+    clientPtr->queryRange = queryRange;
+    clientPtr->percentUser = percentUser;
+    clientPtr->types = NULL;
+    clientPtr->ids = NULL;
+    clientPtr->ops = NULL;
+    clientPtr->prices = NULL;
+    return clientPtr;
+}
+
+
+/* =============================================================================
+ * client_free
+ * =============================================================================
+ */
+void
+client_free (client_t* clientPtr)
+{
+    if (clientPtr->types)
+        P_FREE(clientPtr->types);
+    if (clientPtr->ids)	
+        P_FREE(clientPtr->ids);
+    if (clientPtr->ops)
+        P_FREE(clientPtr->ops);
+    if (clientPtr->prices)
+        P_FREE(clientPtr->prices);
+    if (clientPtr->randomPtr)
+        PRANDOM_FREE(clientPtr->randomPtr);
+    free(clientPtr);
+}
+
+
+/* =============================================================================
+ * selectAction
+ * =============================================================================
+ */
+static action_t
+selectAction (long r, long percentUser)
+{
+    action_t action;
+
+    if (r < percentUser) {
+        action = ACTION_MAKE_RESERVATION;
+    } else if (r & 1) {
+        action = ACTION_DELETE_CUSTOMER;
+    } else {
+        action = ACTION_UPDATE_TABLES;
+    }
+
+    return action;
+}
+
+static void dummy(client_t* clientPtr, long numQueryPerTransaction) {
+    clientPtr->types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
+    clientPtr->ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
+    clientPtr->ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
+    clientPtr->prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
+}
+
+struct Fn1 {
+    Galois::InsertBag<long>& seeds;
+    client_t** clientPtrs;
+
+    void operator()(unsigned tid, unsigned total) {
+        client_t* clientPtr = clientPtrs[tid];
+        clientPtr->randomPtr  = PRANDOM_ALLOC();
+        random_seed(clientPtr->randomPtr, tid);
+
+        long numOperation           = clientPtr->numOperation;
+        long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
+        for (long i = 0; i < numOperation; i++)
+            seeds.push(random_generate(clientPtr->randomPtr));
+
+        // XXX(ddn): workaround XLC crash
+        dummy(clientPtr, numQueryPerTransaction);
+    }
+};
+
+
+struct Fn3 {
+    typedef int tt_needs_per_iter_alloc;
+    typedef int tt_does_not_need_push;
+
+    client_t** clientPtrs;
+
+    void operator()(long seed, Galois::UserContext<long>& ctx) {
+        client_t* clientPtr = clientPtrs[Galois::Runtime::LL::getTID()];
+        random_t*  randomPtr  = clientPtr->randomPtr;
+
+        manager_t* managerPtr = clientPtr->managerPtr;
+        long numOperation           = clientPtr->numOperation;
+        long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
+        long queryRange             = clientPtr->queryRange;
+        long percentUser            = clientPtr->percentUser;
+        
+        // Can't set seed because it causes capacity overflows (?)
+        //random_seed(randomPtr, seed);
+        long r = random_generate(randomPtr) % 100;
+        action_t action = selectAction(r, percentUser);
+
+        long* types  = clientPtr->types;
+        long* ids    = clientPtr->ids;
+        long* ops    = clientPtr->ops;
+        long* prices = clientPtr->prices;
+
+        switch (action) {
+
+            case ACTION_MAKE_RESERVATION: {
+                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
+                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
+                long n;
+                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
+                long customerId = random_generate(randomPtr) % queryRange + 1;
+                for (n = 0; n < numQuery; n++) {
+                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
+                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
+                }
+                bool_t isFound = FALSE;
+                TM_BEGIN();
+                for (n = 0; n < numQuery; n++) {
+                    long t = types[n];
+                    long id = ids[n];
+                    long price = -1;
+                    switch (t) {
+                        case RESERVATION_CAR:
+                            if (MANAGER_QUERY_CAR(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
+                            }
+                            break;
+                        case RESERVATION_FLIGHT:
+                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
+                            }
+                            break;
+                        case RESERVATION_ROOM:
+                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
+                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
+                            }
+                            break;
+                        default:
+                            assert(0);
+                    }
+                    if (price > maxPrices[t]) {
+                        maxPrices[t] = price;
+                        maxIds[t] = id;
+                        isFound = TRUE;
+                    }
+                } /* for n */
+                if (isFound) {
+                    MANAGER_ADD_CUSTOMER(managerPtr, customerId);
+                }
+                if (maxIds[RESERVATION_CAR] > 0) {
+                    MANAGER_RESERVE_CAR(managerPtr,
+                                        customerId, maxIds[RESERVATION_CAR]);
+                }
+                if (maxIds[RESERVATION_FLIGHT] > 0) {
+                    MANAGER_RESERVE_FLIGHT(managerPtr,
+                                           customerId, maxIds[RESERVATION_FLIGHT]);
+                }
+                if (maxIds[RESERVATION_ROOM] > 0) {
+                    MANAGER_RESERVE_ROOM(managerPtr,
+                                         customerId, maxIds[RESERVATION_ROOM]);
+                }
+                TM_END();
+                break;
+            }
+
+            case ACTION_DELETE_CUSTOMER: {
+                long customerId = random_generate(randomPtr) % queryRange + 1;
+                TM_BEGIN();
+                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
+                if (bill >= 0) {
+                    MANAGER_DELETE_CUSTOMER(managerPtr, customerId);
+                }
+                TM_END();
+                break;
+            }
+
+            case ACTION_UPDATE_TABLES: {
+                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
+                long n;
+                for (n = 0; n < numUpdate; n++) {
+                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
+                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
+                    ops[n] = random_generate(randomPtr) % 2;
+                    if (ops[n]) {
+                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
+                    }
+                }
+                TM_BEGIN();
+                for (n = 0; n < numUpdate; n++) {
+                    long t = types[n];
+                    long id = ids[n];
+                    long doAdd = ops[n];
+                    if (doAdd) {
+                        long newPrice = prices[n];
+                        switch (t) {
+                            case RESERVATION_CAR:
+                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
+                                break;
+                            case RESERVATION_FLIGHT:
+                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
+                                break;
+                            case RESERVATION_ROOM:
+                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
+                                break;
+                            default:
+                                assert(0);
+                        }
+                    } else { /* do delete */
+                        switch (t) {
+                            case RESERVATION_CAR:
+                                MANAGER_DELETE_CAR(managerPtr, id, 100);
+                                break;
+                            case RESERVATION_FLIGHT:
+                                MANAGER_DELETE_FLIGHT(managerPtr, id);
+                                break;
+                            case RESERVATION_ROOM:
+                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
+                                break;
+                            default:
+                                assert(0);
+                        }
+                    }
+                }
+                TM_END();
+                break;
+            }
+
+            default:
+                assert(0);
+        } /* switch (action) */
+    }
+};
+
+
+
+/* =============================================================================
+ * client_run
+ * -- Execute list operations on the database
+ * =============================================================================
+ */
+void
+client_run (void* argPtr)
+{
+    TM_THREAD_ENTER();
+
+    //long myId = thread_getId();
+    client_t** clientPtrs = (client_t**)argPtr;
+    client_t* clientPtr = clientPtrs[0];
+
+    long numOperation           = clientPtr->numOperation;
+
+    Galois::InsertBag<long> seeds;
+    Fn1 fn1 = { seeds, clientPtrs };
+    Galois::on_each(fn1);
+
+    Fn3 fn3 = { clientPtrs };
+    typedef Galois::WorkList::dChunkedFIFO<1024> WL;
+    Galois::for_each_local(seeds, fn3, Galois::wl<WL>());
+
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ *
+ * End of client.c
+ *
+ * =============================================================================
+ */
+
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/client.h stamp-grun/vacation/client.h
--- stamp-0.9.10/vacation/client.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/client.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,10 @@
 #include "random.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct client {
     long id;
     manager_t* managerPtr;
@@ -86,6 +90,10 @@
     long numQueryPerTransaction;
     long queryRange;
     long percentUser;
+	long* types;
+	long* ids;
+	long* ops;
+	long* prices;
 } client_t;
 
 
@@ -119,6 +127,9 @@
 void
 client_run (void* argPtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* CLIENT_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/customer.h stamp-grun/vacation/customer.h
--- stamp-0.9.10/vacation/customer.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/customer.h	2017-03-20 15:19:45.000000000 +0000
@@ -79,6 +79,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct customer {
     long id;
     XTM_DECL_LOCKABLE(list_t*, reservationInfoListPtr);
@@ -173,6 +177,10 @@
     customer_free(TM_ARG  cust)
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* CUSTOMER_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/manager.c stamp-grun/vacation/manager.c
--- stamp-0.9.10/vacation/manager.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/manager.c	2017-03-20 15:19:45.000000000 +0000
@@ -389,7 +389,8 @@
     customer_t* customerPtr;
     bool_t status;
 
-    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
+    //if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
+    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
         return FALSE;
     }
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/manager.h stamp-grun/vacation/manager.h
--- stamp-0.9.10/vacation/manager.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/manager.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef struct manager {
     MAP_T* carTablePtr;
     MAP_T* roomTablePtr;
@@ -406,6 +410,10 @@
     manager_cancelFlight(TM_ARG  mgr, cust, id)
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* MANAGER_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/operation.h stamp-grun/vacation/operation.h
--- stamp-0.9.10/vacation/operation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/operation.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,10 @@
 #ifndef OPERATION_H
 #define OPERATION_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef enum operation {
     OPERATION_MAKE_RESERVATION = 0L,
     OPERATION_DELETE_CUSTOMER  = 1L,
@@ -79,6 +83,10 @@
     NUM_OPERATION
 } operation_t;
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* OPERATION_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/reservation.h stamp-grun/vacation/reservation.h
--- stamp-0.9.10/vacation/reservation.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/reservation.h	2017-03-20 15:19:45.000000000 +0000
@@ -77,6 +77,10 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 typedef enum reservation_type {
     RESERVATION_CAR,
     RESERVATION_FLIGHT,
@@ -234,6 +238,9 @@
 #define RESERVATION_FREE(r) \
     reservation_free(TM_ARG  r)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* RESERVATION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/vacation/vacation.c stamp-grun/vacation/vacation.c
--- stamp-0.9.10/vacation/vacation.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/vacation/vacation.c	2017-03-20 15:19:45.000000000 +0000
@@ -431,20 +431,15 @@
     /* Run transactions */
     printf("Running clients... ");
     fflush(stdout);
-    TIMER_READ(start);
     GOTO_SIM();
+
     thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        client_run(clients);
-    }
-#else
-    thread_start(client_run, (void*)clients);
-#endif
+    TIMER_READ(start);
+    client_run(clients);
+    TIMER_READ(stop);
     thread_end_timing();
+
     GOTO_REAL();
-    TIMER_READ(stop);
     puts("done.");
     printf("Time = %0.6lf\n",
            TIMER_DIFF_SECONDS(start, stop));
diff -x .git -x inputs -Naur stamp-0.9.10/yada/CMakeLists.txt stamp-grun/yada/CMakeLists.txt
--- stamp-0.9.10/yada/CMakeLists.txt	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/CMakeLists.txt	2017-03-20 15:19:45.000000000 +0000
@@ -11,7 +11,7 @@
 	element.c 
 	mesh.c 
 	region.c 
-	yada.c 
+	yada.cpp 
 	${LIB_DIR}/avltree.c 
 	${LIB_DIR}/heap.c 
 	${LIB_DIR}/list.c 
@@ -20,7 +20,7 @@
 	${LIB_DIR}/queue.c 
 	${LIB_DIR}/random.c 
 	${LIB_DIR}/rbtree.c 
-	${LIB_DIR}/thread.c 
+	${LIB_DIR}/thread.cpp
 	${LIB_DIR}/vector.c)
 
 app(yada ${sources})
diff -x .git -x inputs -Naur stamp-0.9.10/yada/coordinate.h stamp-grun/yada/coordinate.h
--- stamp-0.9.10/yada/coordinate.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/coordinate.h	2017-03-20 15:19:45.000000000 +0000
@@ -72,6 +72,9 @@
 #ifndef COORDINATE_H
 #define COORDINATE_H 1
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct coordinate {
     double x;
@@ -111,6 +114,9 @@
 void
 coordinate_print (coordinate_t* coordinatePtr);
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* COORDINATE_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/element.h stamp-grun/yada/element.h
--- stamp-0.9.10/yada/element.h	2017-03-21 17:30:14.000000000 +0000
+++ stamp-grun/yada/element.h	2017-03-21 18:11:06.000000000 +0000
@@ -79,6 +79,9 @@
 #include "tm.h"
 #include "types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef pair_t         edge_t;
 typedef struct element element_t;
@@ -414,7 +417,9 @@
 #define TMELEMENT_ADDNEIGHBOR(e, n)     TMelement_addNeighbor(TM_ARG  e, n)
 #define TMELEMENT_GETNEIGHBORLIST(e)    TMelement_getNeighborListPtr(TM_ARG  e)
 
-
+#ifdef __cplusplus
+}
+#endif
 #endif /* ELEMENT_H */
 
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/mesh.c stamp-grun/yada/mesh.c
--- stamp-0.9.10/yada/mesh.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/mesh.c	2017-03-21 18:11:51.000000000 +0000
@@ -108,8 +108,8 @@
         meshPtr->initBadQueuePtr = queue_alloc(-1);
         assert(meshPtr->initBadQueuePtr);
         meshPtr->size = 0;
-        meshPtr->boundarySetPtr = SET_ALLOC(NULL, &element_listCompareEdge);
-        assert(meshPtr->boundarySetPtr);
+        //meshPtr->boundarySetPtr = SET_ALLOC(NULL, &element_listCompareEdge);
+        //assert(meshPtr->boundarySetPtr);
     }
 
     return meshPtr;
@@ -124,7 +124,7 @@
 mesh_free (mesh_t* meshPtr)
 {
     queue_free(meshPtr->initBadQueuePtr);
-    SET_FREE(meshPtr->boundarySetPtr);
+    //SET_FREE(meshPtr->boundarySetPtr);
     free(meshPtr);
 }
 
@@ -150,6 +150,8 @@
      */
     long i;
     long numEdge = element_getNumEdge(elementPtr);
+    int onBoundary = 0;
+    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
     for (i = 0; i < numEdge; i++) {
         pair_t* edgePtr = element_getEdge(elementPtr, i);
         if (!MAP_CONTAINS(edgeMapPtr, (void*)edgePtr)) {
@@ -169,12 +171,18 @@
             assert(sharerPtr); /* cannot be shared by >2 elements */
             element_addNeighbor(elementPtr, sharerPtr);
             element_addNeighbor(sharerPtr, elementPtr);
+            if (encroachedPtr && element_getNumEdge(sharerPtr) == 1 && element_getEdge(sharerPtr, 0) == encroachedPtr) {
+                assert(!onBoundary);
+                onBoundary = 1;
+            }
+#if 0
             isSuccess = MAP_REMOVE(edgeMapPtr, edgePtr);
             assert(isSuccess);
             isSuccess = MAP_INSERT(edgeMapPtr,
                                    edgePtr,
                                    NULL); /* marker to check >2 sharers */
             assert(isSuccess);
+#endif
         }
     }
 
@@ -182,11 +190,8 @@
      * Check if really encroached
      */
 
-    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
-    if (encroachedPtr) {
-        if (!SET_CONTAINS(meshPtr->boundarySetPtr, encroachedPtr)) {
-            element_clearEncroached(elementPtr);
-        }
+    if (encroachedPtr && !onBoundary) {
+        element_clearEncroached(elementPtr);
     }
 }
 
@@ -213,6 +218,9 @@
      */
     long i;
     long numEdge = element_getNumEdge(elementPtr);
+    int onBoundary = 0;
+    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
+
     for (i = 0; i < numEdge; i++) {
         edge_t* edgePtr = element_getEdge(elementPtr, i);
         if (!MAP_CONTAINS(edgeMapPtr, (void*)edgePtr)) {
@@ -230,24 +238,23 @@
             assert(sharerPtr); /* cannot be shared by >2 elements */
             TMELEMENT_ADDNEIGHBOR(elementPtr, sharerPtr);
             TMELEMENT_ADDNEIGHBOR(sharerPtr, elementPtr);
+            if (encroachedPtr && element_getNumEdge(sharerPtr) == 1 && element_getEdge(sharerPtr, 0) == encroachedPtr) {
+                assert(!onBoundary);
+                onBoundary = 1;
+            }
+#if 0
             isSuccess = PMAP_REMOVE(edgeMapPtr, edgePtr);
+            isSuccess = PMAP_INSERT(edgeMapPtr, edgePtr, NULL); /* marker to check >2 sharers */
             assert(isSuccess);
-            isSuccess = PMAP_INSERT(edgeMapPtr,
-                                    edgePtr,
-                                    NULL); /* marker to check >2 sharers */
-            assert(isSuccess);
+#endif
         }
     }
 
     /*
      * Check if really encroached
      */
-
-    edge_t* encroachedPtr = element_getEncroachedPtr(elementPtr);
-    if (encroachedPtr) {
-        if (!TMSET_CONTAINS(meshPtr->boundarySetPtr, encroachedPtr)) {
-            element_clearEncroached(elementPtr);
-        }
+    if (encroachedPtr && !onBoundary) {
+        element_clearEncroached(elementPtr);
     }
 }
 
@@ -327,9 +334,11 @@
     assert(elementPtr);
 
     if (numCoordinate == 2) {
+#if 0
         edge_t* boundaryPtr = element_getEdge(elementPtr, 0);
         bool_t status = SET_INSERT(meshPtr->boundarySetPtr, boundaryPtr);
         assert(status);
+#endif
     }
 
     mesh_insert(meshPtr, elementPtr, edgeMapPtr);
diff -x .git -x inputs -Naur stamp-0.9.10/yada/mesh.h stamp-grun/yada/mesh.h
--- stamp-0.9.10/yada/mesh.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/mesh.h	2017-03-21 18:12:00.000000000 +0000
@@ -79,6 +79,10 @@
 #include "tm.h"
 #include "vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 
 typedef struct mesh  mesh_t;
 
@@ -183,6 +187,9 @@
 #define TMMESH_INSERTBOUNDARY(m, b)     TMmesh_insertBoundary(TM_ARG  m, b)
 #define TMMESH_REMOVEBOUNDARY(m, b)     TMmesh_removeBoundary(TM_ARG  m, b)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* MESH_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/region.c stamp-grun/yada/region.c
--- stamp-0.9.10/yada/region.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/region.c	2017-03-20 15:19:45.000000000 +0000
@@ -199,6 +199,7 @@
         assert(bElementPtr);
         TMMESH_INSERT(meshPtr, bElementPtr, edgeMapPtr);
 
+#if 0
         bool_t status;
         status = TMMESH_REMOVEBOUNDARY(meshPtr, element_getEdge(elementPtr, 0));
         assert(status);
@@ -206,7 +207,7 @@
         assert(status);
         status = TMMESH_INSERTBOUNDARY(meshPtr, element_getEdge(bElementPtr, 0));
         assert(status);
-
+#endif
         numDelta += 2;
     }
 
@@ -234,7 +235,7 @@
 
     numDelta += PLIST_GETSIZE(borderListPtr);
 
-    assert(numDelta > 0);
+    //assert(numDelta >= 0);
 
     return numDelta;
 }
@@ -276,7 +277,7 @@
 
         PLIST_INSERT(beforeListPtr, (void*)currentElementPtr); /* no duplicates */
         list_t* neighborListPtr = element_getNeighborListPtr(currentElementPtr);
-        assert(TMLIST_GETSIZE(neighborListPtr) > 0);
+        //assert(TMLIST_GETSIZE(neighborListPtr) > 0);
 
         list_iter_t it;
         TMLIST_ITER_RESET(&it, neighborListPtr);
@@ -389,6 +390,11 @@
     PVECTOR_CLEAR(regionPtr->badVectorPtr);
 }
 
+vector_t*
+Pregion_getBadVector (region_t* regionPtr)
+{
+    return regionPtr->badVectorPtr;
+}
 
 /* =============================================================================
  * TMregion_transferBad
diff -x .git -x inputs -Naur stamp-0.9.10/yada/region.h stamp-grun/yada/region.h
--- stamp-0.9.10/yada/region.h	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/region.h	2017-03-20 15:19:45.000000000 +0000
@@ -78,6 +78,9 @@
 #include "mesh.h"
 #include "tm.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 typedef struct region  region_t;
 
@@ -121,6 +124,8 @@
 void
 Pregion_clearBad (region_t* regionPtr);
 
+vector_t*
+Pregion_getBadVector (region_t* regionPtr);
 
 /* =============================================================================
  * TMregion_transferBad
@@ -136,6 +141,9 @@
 #define TMREGION_REFINE(r, e, m)        TMregion_refine(TM_ARG  r, e, m)
 #define TMREGION_TRANSFERBAD(r, q)      TMregion_transferBad(TM_ARG  r, q)
 
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* REGION_H */
 
diff -x .git -x inputs -Naur stamp-0.9.10/yada/yada.c stamp-grun/yada/yada.c
--- stamp-0.9.10/yada/yada.c	2017-03-20 14:49:53.000000000 +0000
+++ stamp-grun/yada/yada.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,365 +0,0 @@
-/* =============================================================================
- *
- * yada.c
- *
- * =============================================================================
- *
- * Copyright (C) Stanford University, 2006.  All Rights Reserved.
- * Author: Chi Cao Minh
- *
- * =============================================================================
- *
- * For the license of bayes/sort.h and bayes/sort.c, please see the header
- * of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of kmeans, please see kmeans/LICENSE.kmeans
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of ssca2, please see ssca2/COPYRIGHT
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
- * header of the files.
- * 
- * ------------------------------------------------------------------------
- * 
- * For the license of lib/rbtree.h and lib/rbtree.c, please see
- * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
- * 
- * ------------------------------------------------------------------------
- * 
- * Unless otherwise noted, the following license applies to STAMP files:
- * 
- * Copyright (c) 2007, Stanford University
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- * 
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- * 
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in
- *       the documentation and/or other materials provided with the
- *       distribution.
- * 
- *     * Neither the name of Stanford University nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- *
- * =============================================================================
- */
-
-
-#include <assert.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "region.h"
-#include "list.h"
-#include "mesh.h"
-#include "heap.h"
-#include "thread.h"
-#include "timer.h"
-#include "tm.h"
-
-
-#define PARAM_DEFAULT_INPUTPREFIX ("")
-#define PARAM_DEFAULT_NUMTHREAD   (1L)
-#define PARAM_DEFAULT_ANGLE       (20.0)
-
-
-char*    global_inputPrefix     = PARAM_DEFAULT_INPUTPREFIX;
-long     global_numThread       = PARAM_DEFAULT_NUMTHREAD;
-double   global_angleConstraint = PARAM_DEFAULT_ANGLE;
-mesh_t*  global_meshPtr;
-heap_t*  global_workHeapPtr;
-XTM_DECL_LOCKABLE(long,     global_totalNumAdded); // = 0;
-XTM_DECL_LOCKABLE(long,     global_numProcess);//    = 0;
-
-
-/* =============================================================================
- * displayUsage
- * =============================================================================
- */
-static void
-displayUsage (const char* appName)
-{
-    printf("Usage: %s [options]\n", appName);
-    puts("\nOptions:                              (defaults)\n");
-    printf("    a <FLT>   Min [a]ngle constraint  (%lf)\n", PARAM_DEFAULT_ANGLE);
-    printf("    i <STR>   [i]nput name prefix     (%s)\n",  PARAM_DEFAULT_INPUTPREFIX);
-    printf("    t <UINT>  Number of [t]hreads     (%li)\n", PARAM_DEFAULT_NUMTHREAD);
-    exit(1);
-}
-
-
-/* =============================================================================
- * parseArgs
- * =============================================================================
- */
-static void
-parseArgs (long argc, char* const argv[])
-{
-    long i;
-    long opt;
-
-    opterr = 0;
-
-    while ((opt = getopt(argc, argv, "a:i:t:")) != -1) {
-        switch (opt) {
-            case 'a':
-                global_angleConstraint = atof(optarg);
-                break;
-            case 'i':
-                global_inputPrefix = optarg;
-                break;
-            case 't':
-                global_numThread = atol(optarg);
-                break;
-            case '?':
-            default:
-                opterr++;
-                break;
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
-        opterr++;
-    }
-
-    if (opterr) {
-        displayUsage(argv[0]);
-    }
-}
-
-
-/* =============================================================================
- * initializeWork
- * =============================================================================
- */
-static long
-initializeWork (heap_t* workHeapPtr, mesh_t* meshPtr)
-{
-    random_t* randomPtr = random_alloc();
-    random_seed(randomPtr, 0);
-    mesh_shuffleBad(meshPtr, randomPtr);
-    random_free(randomPtr);
-
-    long numBad = 0;
-
-    while (1) {
-        element_t* elementPtr = mesh_getBad(meshPtr);
-        if (!elementPtr) {
-            break;
-        }
-        numBad++;
-        bool_t status = heap_insert(workHeapPtr, (void*)elementPtr);
-        assert(status);
-        element_setIsReferenced(elementPtr, TRUE);
-    }
-
-    return numBad;
-}
-
-
-/* =============================================================================
- * process
- * =============================================================================
- */
-void
-process ()
-{
-    TM_THREAD_ENTER();
-
-    heap_t* workHeapPtr = global_workHeapPtr;
-    mesh_t* meshPtr = global_meshPtr;
-    region_t* regionPtr;
-    long totalNumAdded = 0;
-    long numProcess = 0;
-
-    regionPtr = PREGION_ALLOC();
-    assert(regionPtr);
-
-    while (1) {
-
-        element_t* elementPtr;
-
-        TM_BEGIN();
-        elementPtr = TMHEAP_REMOVE(workHeapPtr);
-        TM_END();
-        if (elementPtr == NULL) {
-            break;
-        }
-
-        bool_t isGarbage;
-        TM_BEGIN();
-        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
-        TM_END();
-        if (isGarbage) {
-            /*
-             * Handle delayed deallocation
-             */
-            PELEMENT_FREE(elementPtr);
-            continue;
-        }
-
-        long numAdded;
-
-        TM_BEGIN();
-        PREGION_CLEARBAD(regionPtr);
-        numAdded = TMREGION_REFINE(regionPtr, elementPtr, meshPtr);
-        TM_END();
-
-        TM_BEGIN();
-        TMELEMENT_SETISREFERENCED(elementPtr, FALSE);
-        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
-        TM_END();
-        if (isGarbage) {
-            /*
-             * Handle delayed deallocation
-             */
-            PELEMENT_FREE(elementPtr);
-        }
-
-        totalNumAdded += numAdded;
-
-        TM_BEGIN();
-        TMREGION_TRANSFERBAD(regionPtr, workHeapPtr);
-        TM_END();
-
-        numProcess++;
-
-    }
-
-    TM_BEGIN();
-    TM_SHARED_WRITE(global_totalNumAdded,
-                    TM_SHARED_READ(global_totalNumAdded) + totalNumAdded);
-    TM_SHARED_WRITE(global_numProcess,
-                    TM_SHARED_READ(global_numProcess) + numProcess);
-    TM_END();
-
-    PREGION_FREE(regionPtr);
-
-    TM_THREAD_EXIT();
-}
-
-
-/* =============================================================================
- * main
- * =============================================================================
- */
-MAIN(argc, argv)
-{
-    GOTO_REAL();
-
-    /*
-     * Initialization
-     */
-
-    parseArgs(argc, (char** const)argv);
-    SIM_GET_NUM_CPU(global_numThread);
-    TM_STARTUP(global_numThread);
-    P_MEMORY_STARTUP(global_numThread);
-    thread_startup(global_numThread);
-    global_meshPtr = mesh_alloc();
-    assert(global_meshPtr);
-    printf("Angle constraint = %lf\n", global_angleConstraint);
-    printf("Reading input... ");
-    long initNumElement = mesh_read(global_meshPtr, global_inputPrefix);
-    puts("done.");
-    global_workHeapPtr = heap_alloc(1, &element_heapCompare);
-    assert(global_workHeapPtr);
-    long initNumBadElement = initializeWork(global_workHeapPtr, global_meshPtr);
-
-    printf("Initial number of mesh elements = %li\n", initNumElement);
-    printf("Initial number of bad elements  = %li\n", initNumBadElement);
-    printf("Starting triangulation...");
-    fflush(stdout);
-
-    /*
-     * Run benchmark
-     */
-
-    TIMER_T start;
-    TIMER_READ(start);
-    GOTO_SIM();
-    thread_begin_timing();
-#ifdef OTM
-#pragma omp parallel
-    {
-        process();
-    }
-#else
-    thread_start(process, NULL);
-#endif
-    thread_end_timing();
-    GOTO_REAL();
-    TIMER_T stop;
-    TIMER_READ(stop);
-
-    puts(" done.");
-    printf("Elapsed time                    = %0.3lf\n",
-           TIMER_DIFF_SECONDS(start, stop));
-    printf("STAMP time = %0.3lf\n",
-           TIMER_DIFF_SECONDS(start, stop));
-    fflush(stdout);
-
-    /*
-     * Check solution
-     */
-
-    long finalNumElement = initNumElement + XTM_LOCKABLE_VALUE(global_totalNumAdded);
-    printf("Final mesh size                 = %li\n", finalNumElement);
-    printf("Number of elements processed    = %li\n", XTM_LOCKABLE_VALUE(global_numProcess));
-    fflush(stdout);
-
-#if 0
-    bool_t isSuccess = mesh_check(global_meshPtr, finalNumElement);
-#else
-    bool_t isSuccess = TRUE;
-#endif
-    printf("Final mesh is %s\n", (isSuccess ? "valid." : "INVALID!"));
-    fflush(stdout);
-    assert(isSuccess);
-
-    /*
-     * TODO: deallocate mesh and work heap
-     */
-
-    TM_SHUTDOWN();
-    P_MEMORY_SHUTDOWN();
-
-    GOTO_SIM();
-
-    thread_shutdown();
-
-    MAIN_RETURN(0);
-}
-
-
-/* =============================================================================
- *
- * End of ruppert.c
- *
- * =============================================================================
- */
diff -x .git -x inputs -Naur stamp-0.9.10/yada/yada.cpp stamp-grun/yada/yada.cpp
--- stamp-0.9.10/yada/yada.cpp	1970-01-01 01:00:00.000000000 +0100
+++ stamp-grun/yada/yada.cpp	2017-03-20 15:19:45.000000000 +0000
@@ -0,0 +1,375 @@
+/* =============================================================================
+ *
+ * yada.c
+ *
+ * =============================================================================
+ *
+ * Copyright (C) Stanford University, 2006.  All Rights Reserved.
+ * Author: Chi Cao Minh
+ *
+ * =============================================================================
+ *
+ * For the license of bayes/sort.h and bayes/sort.c, please see the header
+ * of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of kmeans, please see kmeans/LICENSE.kmeans
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of ssca2, please see ssca2/COPYRIGHT
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/mt19937ar.c and lib/mt19937ar.h, please see the
+ * header of the files.
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * For the license of lib/rbtree.h and lib/rbtree.c, please see
+ * lib/LEGALNOTICE.rbtree and lib/LICENSE.rbtree
+ * 
+ * ------------------------------------------------------------------------
+ * 
+ * Unless otherwise noted, the following license applies to STAMP files:
+ * 
+ * Copyright (c) 2007, Stanford University
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ * 
+ *     * Neither the name of Stanford University nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY STANFORD UNIVERSITY ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STANFORD UNIVERSITY BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * =============================================================================
+ */
+
+#include "Galois/Galois.h"
+#include "Galois/Accumulator.h"
+#include "Galois/Bag.h"
+
+#include <assert.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "region.h"
+#include "list.h"
+#include "mesh.h"
+#include "heap.h"
+#include "thread.h"
+#include "timer.h"
+#include "tm.h"
+
+
+#define PARAM_DEFAULT_INPUTPREFIX ("")
+#define PARAM_DEFAULT_NUMTHREAD   (1L)
+#define PARAM_DEFAULT_ANGLE       (20.0)
+
+
+char*    global_inputPrefix     = PARAM_DEFAULT_INPUTPREFIX;
+long     global_numThread       = PARAM_DEFAULT_NUMTHREAD;
+double   global_angleConstraint = PARAM_DEFAULT_ANGLE;
+mesh_t*  global_meshPtr;
+heap_t*  global_workHeapPtr;
+long     global_totalNumAdded = 0;
+long     global_numProcess    = 0;
+
+
+/* =============================================================================
+ * displayUsage
+ * =============================================================================
+ */
+static void
+displayUsage (const char* appName)
+{
+    printf("Usage: %s [options]\n", appName);
+    puts("\nOptions:                              (defaults)\n");
+    printf("    a <FLT>   Min [a]ngle constraint  (%lf)\n", PARAM_DEFAULT_ANGLE);
+    printf("    i <STR>   [i]nput name prefix     (%s)\n",  PARAM_DEFAULT_INPUTPREFIX);
+    printf("    t <UINT>  Number of [t]hreads     (%li)\n", PARAM_DEFAULT_NUMTHREAD);
+    exit(1);
+}
+
+
+/* =============================================================================
+ * parseArgs
+ * =============================================================================
+ */
+static void
+parseArgs (long argc, char* const argv[])
+{
+    long i;
+    long opt;
+
+    opterr = 0;
+
+    while ((opt = getopt(argc, argv, "a:i:t:")) != -1) {
+        switch (opt) {
+            case 'a':
+                global_angleConstraint = atof(optarg);
+                break;
+            case 'i':
+                global_inputPrefix = optarg;
+                break;
+            case 't':
+                global_numThread = atol(optarg);
+                break;
+            case '?':
+            default:
+                opterr++;
+                break;
+        }
+    }
+
+    for (i = optind; i < argc; i++) {
+        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
+        opterr++;
+    }
+
+    if (opterr) {
+        displayUsage(argv[0]);
+    }
+}
+
+
+/* =============================================================================
+ * initializeWork
+ * =============================================================================
+ */
+static long
+initializeWork (std::deque<void*>& work, mesh_t* meshPtr)
+{
+    random_t* randomPtr = random_alloc();
+    random_seed(randomPtr, 0);
+    mesh_shuffleBad(meshPtr, randomPtr);
+    random_free(randomPtr);
+
+    long numBad = 0;
+
+    while (1) {
+        element_t* elementPtr = mesh_getBad(meshPtr);
+        if (!elementPtr) {
+            break;
+        }
+        numBad++;
+        work.push_back((void*)elementPtr);
+        element_setIsReferenced(elementPtr, TRUE);
+    }
+
+    return numBad;
+}
+
+
+struct Fn1 {
+    mesh_t* meshPtr;
+    Galois::GAccumulator<long>& numProcess;
+    Galois::GAccumulator<long>& totalNumAdded;
+    Galois::Runtime::PerThreadStorage<region_t*>& regionPtrs;
+
+    void operator()(void* voidPtr, Galois::UserContext<void*>& ctx) {
+        element_t* elementPtr = (element_t*) voidPtr;
+        bool_t isGarbage;
+        region_t*& regionPtr = *regionPtrs.getLocal();
+        if (!regionPtr)
+            regionPtr = PREGION_ALLOC();
+
+        TM_BEGIN();
+        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
+        TM_END();
+
+        if (isGarbage) {
+            /*
+             * Handle delayed deallocation
+             */
+            //PELEMENT_FREE(elementPtr);
+            TMELEMENT_FREE(elementPtr);
+            return;
+        }
+
+        long numAdded;
+
+        TM_BEGIN();
+        PREGION_CLEARBAD(regionPtr);
+        numAdded = TMREGION_REFINE(regionPtr, elementPtr, meshPtr);
+        TM_END();
+
+        TM_BEGIN();
+        TMELEMENT_SETISREFERENCED(elementPtr, FALSE);
+        isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
+        TM_END();
+
+        if (isGarbage) {
+            /*
+             * Handle delayed deallocation
+             */
+            //PELEMENT_FREE(elementPtr);
+            TMELEMENT_FREE(elementPtr);
+        }
+
+        TM_BEGIN();
+        vector_t* badVectorPtr = Pregion_getBadVector(regionPtr);
+        long numBad = PVECTOR_GETSIZE(badVectorPtr);
+        for (long i = 0; i < numBad; ++i) {
+            element_t* badElementPtr = (element_t*)vector_at(badVectorPtr, i);
+            if (TMELEMENT_ISGARBAGE(badElementPtr)) {
+                TMELEMENT_FREE(badElementPtr);
+            } else {
+                ctx.push(badElementPtr);
+            }
+        }
+        TM_END();
+
+        numProcess += 1;
+        totalNumAdded += numAdded;
+    }
+};
+
+/* =============================================================================
+ * process
+ * =============================================================================
+ */
+void
+process (std::deque<void*>& work)
+{
+    TM_THREAD_ENTER();
+
+    Galois::GAccumulator<long> numProcess;
+    Galois::GAccumulator<long> totalNumAdded;
+    Galois::Runtime::PerThreadStorage<region_t*> regionPtrs;
+
+    Fn1 fn1 = { global_meshPtr, numProcess, totalNumAdded, regionPtrs };
+
+    Galois::for_each(work.begin(), work.end(), fn1);
+
+    global_totalNumAdded += totalNumAdded.reduce();
+    global_numProcess += numProcess.reduce();
+    for (unsigned ii = 0; ii < regionPtrs.size(); ++ii) {
+    	if (*regionPtrs.getRemote(ii))
+           Pregion_free(*regionPtrs.getRemote(ii));
+    }
+    TM_THREAD_EXIT();
+}
+
+
+/* =============================================================================
+ * main
+ * =============================================================================
+ */
+MAIN(argc, argv)
+{
+    GOTO_REAL();
+
+    /*
+     * Initialization
+     */
+
+    parseArgs(argc, (char** const)argv);
+    SIM_GET_NUM_CPU(global_numThread);
+    TM_STARTUP(global_numThread);
+    P_MEMORY_STARTUP(global_numThread);
+    thread_startup(global_numThread);
+    global_meshPtr = mesh_alloc();
+    assert(global_meshPtr);
+    printf("Angle constraint = %lf\n", global_angleConstraint);
+    printf("Reading input... ");
+    long initNumElement = mesh_read(global_meshPtr, global_inputPrefix);
+    puts("done.");
+    global_workHeapPtr = heap_alloc(1, &element_heapCompare);
+    assert(global_workHeapPtr);
+    std::deque<void*> work;
+    long initNumBadElement = initializeWork(work, global_meshPtr);
+
+    printf("Initial number of mesh elements = %li\n", initNumElement);
+    printf("Initial number of bad elements  = %li\n", initNumBadElement);
+    printf("Starting triangulation...");
+    fflush(stdout);
+
+    /*
+     * Run benchmark
+     */
+
+    TIMER_T start;
+    GOTO_SIM();
+    thread_begin_timing();
+    TIMER_READ(start);
+    {
+        process(work);
+    }
+    TIMER_T stop;
+    TIMER_READ(stop);
+    thread_end_timing();
+    GOTO_REAL();
+
+    puts(" done.");
+    printf("Elapsed time                    = %0.3lf\n",
+           TIMER_DIFF_SECONDS(start, stop));
+    printf("STAMP time = %0.3lf\n",
+           TIMER_DIFF_SECONDS(start, stop));
+    fflush(stdout);
+
+    /*
+     * Check solution
+     */
+
+    long finalNumElement = initNumElement + global_totalNumAdded;
+    printf("Final mesh size                 = %li\n", finalNumElement);
+    printf("Number of elements processed    = %li\n", global_numProcess);
+    fflush(stdout);
+
+#if 0
+    bool_t isSuccess = mesh_check(global_meshPtr, finalNumElement);
+    // XXX(ddn): finalNumElement is likely to be wrong when running
+    // with tinySTM because the accumulation is not transactionalized
+    isSuccess = TRUE;
+#else
+    bool_t isSuccess = TRUE;
+#endif
+    printf("Final mesh is %s\n", (isSuccess ? "valid." : "INVALID!"));
+    fflush(stdout);
+    assert(isSuccess);
+
+    /*
+     * TODO: deallocate mesh and work heap
+     */
+
+    TM_SHUTDOWN();
+    P_MEMORY_SHUTDOWN();
+
+    GOTO_SIM();
+
+    thread_shutdown();
+
+    MAIN_RETURN(0);
+}
+
+
+/* =============================================================================
+ *
+ * End of ruppert.c
+ *
+ * =============================================================================
+ */
